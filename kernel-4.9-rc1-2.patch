Added files

diff --git a/arch/arm/boot/dts/sun8i-a83t-bananapi-m3.dts b/arch/arm/boot/dts/sun8i-a83t-bananapi-m3.dts
new file mode 100644
index 0000000..9559159
--- /dev/null
+++ b/arch/arm/boot/dts/sun8i-a83t-bananapi-m3.dts
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2016 Vishnu Patekar
+ * Vishnu Patekar <vishnupatekar0510@gmail.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+#include "sun8i-a83t.dtsi"
+#include "sunxi-common-regulators.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/pinctrl/sun4i-a10.h>
+
+/ {
+	model = "Sinovoip BananaPi M3 v1.2";
+	compatible = "sinovoip,bpi-m3", "allwinner,sun8i-a83t";
+
+	aliases {
+		serial0 = &uart0;
+		lcd1 = &lcd1;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		mmc2 = &mmc2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+#if 0
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwr_led_bpi_m3>;
+
+		green {
+			label = "bpi-m3:green:pwr";
+--fixme: axp GPIO0
+			gpios = <&r_pio 0 0 GPIO_ACTIVE_HIGH>; /* PL0 */
+			default-state = "off";
+		};
+		blue {
+			label = "bpi-m3:blue:pwr";
+--fixme: axp GPIO1
+			gpios = <&r_pio 0 1 GPIO_ACTIVE_HIGH>; /* PL1 */
+			default-state = "off";
+		};
+	};
+#endif
+
+	mmc1_pwrseq: mmc1_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mmc1_pwrseq_pin_bpi_m3>;
+		reset-gpios = <&r_pio 0 2 GPIO_ACTIVE_LOW>; /* PL2 WIFI_EN */
+	};
+};
+
+&de {
+	status = "okay";
+};
+
+&ehci0 {
+	/* Terminus Tech FE 1.1s 4-port USB 2.0 hub here */
+	status = "okay";
+
+	/* TODO GL830 USB-to-SATA bridge downstream w/ GPIO power controls */
+};
+
+&hdmi {
+	status = "okay";
+};
+
+&i2s2 {
+	status = "okay";
+};
+
+&lcd1 {
+	status = "okay";
+};
+
+&mmc0 {						/* SD card */
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc0_pins_a>, <&mmc0_cd_pin>;
+// bad voltage?
+//	vmmc-supply = <&reg_dcdc1>;
+	vmmc-supply = <&reg_vcc3v3>;
+	bus-width = <4>;
+	cd-gpios = <&pio 5 6 GPIO_ACTIVE_HIGH>; /* PF6 */
+	cd-inverted;
+	status = "okay";
+};
+
+&mmc1 {						/* wifi/BT */
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc1_pins_a>;
+	vmmc-supply = <&reg_dldo1>;
+	mmc-pwrseq = <&mmc1_pwrseq>;
+	bus-width = <4>;
+	non-removable;
+	status = "okay";
+
+	brcmf: bcrmf@1 {
+		reg = <1>;
+		compatible = "brcm,bcm4329-fmac";
+		interrupt-parent = <&r_pio>;
+		interrupts = <0 3 IRQ_TYPE_LEVEL_LOW>; /* PL3 */
+		interrupt-names = "host-wake";
+	};
+};
+&mmc1_pins_a {
+	/* AP6212 requires pull-up */
+	allwinner,pull = <SUN4I_PINCTRL_PULL_UP>;
+};
+
+&mmc2 {						/* eMMC */
+	pinctrl-names = "default";
+	pinctrl-0 = <&mmc2_8bit_pins>;
+	vmmc-supply = <&reg_vcc3v3>;
+	vqmmc-supply = <&reg_vcc3v3>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&r_pio {
+	mmc1_pwrseq_pin_bpi_m3: mmc1_pwrseq_pin@0 {
+		allwinner,pins = "PL2";
+		allwinner,function = "gpio_out";
+//		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,drive = <SUN4I_PINCTRL_20_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+	};
+#if 0
+	pwr_led_bpi_m3: pwr_led_bpi_m3 {		/* green & blue leds */
+--fixme
+		allwinner,pins = "PL0", "PL1";
+		allwinner,function = "gpio_out";
+		allwinner,drive = <SUN4I_PINCTRL_10_MA>;
+		allwinner,pull = <SUN4I_PINCTRL_NO_PULL>;
+};
+#endif
+};
+
+&r_rsb {
+	status = "okay";
+
+	pmic@3a3 {
+		compatible = "x-powers,axp813";
+		reg = <0x3a3>;
+		interrupt-parent = <&nmi_intc>;
+		interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
+		interrupt-controller;
+		#interrupt-cells = <1>;
+
+/* values from the BPI-M3 V1_2 schematic diagram */
+		regulators {
+			reg_aldo1: aldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc-hdmi-18";
+			};
+#if 0 // bad setting?
+			reg_dcdc1: dcdc1 {		/* vcc-card */
+				regulator-always-on;
+				regulator-min-microvolt = <3100000>;
+				regulator-max-microvolt = <3100000>;
+				regulator-name = "dcdc1";
+			};
+#endif
+#if 0 // set by u-boot
+			reg_dcdc2: dcdc2 {
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdd-cpua";
+			};
+			reg_dcdc3: dcdc3 {
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdd-cpub";
+			};
+#endif
+#if 0 // set by u-boot
+			reg_dcdc6: dcdc6 {
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdd-hdmi-09";
+			};
+#endif
+			reg_dldo1: dldo1 {
+				regulator-min-microvolt = <3100000>;
+				regulator-max-microvolt = <3100000>;
+				regulator-name = "vcc-wifi";
+			};
+		};
+	};
+};
+
+&reg_usb1_vbus {
+	gpio = <&pio 3 24 GPIO_ACTIVE_HIGH>; /* PD24 */
+	status = "okay";
+};
+
+&reg_vcc3v0 {
+	status = "disabled";
+};
+
+&reg_vcc5v0 {
+	status = "disabled";
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins_b>;
+	status = "okay";
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
+
+&usb_otg {
+	/* VBUS detection/drive support in PMIC required for OTG */
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usb1_vbus_pin_a {
+	allwinner,pins = "PD24";
+};
diff --git a/drivers/clk/sunxi/ccu-sun8i-a83t.c b/drivers/clk/sunxi/ccu-sun8i-a83t.c
new file mode 100644
index 0000000..ea9ae09
--- /dev/null
+++ b/drivers/clk/sunxi/ccu-sun8i-a83t.c
@@ -0,0 +1,1482 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Adapted from the sun8i SDK
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+
+#include <dt-bindings/clock/sun8i-a83t.h>
+#include <dt-bindings/reset/sun8i-a83t.h>
+
+#include "ccu.h"
+
+static const char losc[] __initconst = "osc32k";
+static const char hosc[] __initconst = "osc24M";
+static const char iosc[] __initconst = "osc16M";
+static const char * const child_hosc[] __initconst = { hosc };
+
+/* ---- CCU ---- */
+
+/* 2 * cpux */
+/*	rate = 24MHz * n / p */
+static const char pll_c0cpux[] __initconst = "pll-c0cpux";
+static const struct clk_init_data pll_c0cpux_init __initconst = {
+	CCU_HW(pll_c0cpux, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_c0cpux_clk __initconst = {
+	CCU_REG(0x000),
+	.hw.init = &pll_c0cpux_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 0),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_P(16, 1),			/* only when rate < 288MHz */
+	.features = CCU_FEATURE_N0,
+};
+
+static const char pll_c1cpux[] __initconst = "pll-c1cpux";
+static const struct clk_init_data pll_c1cpux_init __initconst = {
+	CCU_HW(pll_c1cpux, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_c1cpux_clk __initconst = {
+	CCU_REG(0x004),
+	.hw.init = &pll_c1cpux_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 1),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_P(16, 1),			/* only when rate < 288MHz */
+	.features = CCU_FEATURE_N0,
+};
+
+/* audio */
+/*	rate = 22579200Hz or 24576000Hz with sigma-delta */
+/*   or	rate = 24MHz * n / (d1 + 1) / (d2 + 1) / (p + 1) */
+static const char pll_audio[] __initconst = "pll-audio";
+#define NDP_MASK (GENMASK(15, 8) | BIT(16) | BIT(18) | GENMASK(5, 0))
+#define SDM_BIT BIT(24)
+static const struct frac audio_fracs[] = {
+	{
+		.rate = 22579200,
+		.mask =  SDM_BIT | NDP_MASK,
+		.val = SDM_BIT | (54 << 8) | BIT(18) | (28 << 0),
+						/* n=54 d1=0 d2=1 p=28 */
+		.sd_reg = 0x284,
+		.sd_val = 0xc00121ff,
+	},
+	{
+		.rate = 24576000,
+		.mask = SDM_BIT | NDP_MASK,
+		.val = SDM_BIT | (61 << 8) | BIT(18) | (29 << 0),
+						/* n=61 d1=0 d2=1 p=29 */
+		.sd_reg = 0x284,
+		.sd_val = 0xc000e147,
+	},
+	{
+		.rate = 0,
+		.mask = SDM_BIT,
+		.val = 0,
+	},
+};
+static const struct ccu_extra audio_extra = {
+	CCU_EXTRA_FRAC(audio_fracs),
+};
+static const struct clk_init_data pll_audio_init __initconst = {
+	CCU_HW(pll_audio, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_audio_clk __initconst = {
+	CCU_REG(0x008),
+	.hw.init = &pll_audio_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 2),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	CCU_M(0, 6),		/* p = divider */
+	.features = CCU_FEATURE_N0,
+	.extra = &audio_extra,
+};
+static const char * const child_pll_audio[] __initconst = { pll_audio };
+
+/* video 0 */
+/*	rate = 24MHz * n / (d1 + 1) >> p */
+static const char pll_video0[] __initconst = "pll-video0";
+static const struct clk_init_data pll_video0_init __initconst = {
+	CCU_HW(pll_video0, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_video0_clk __initconst = {
+	CCU_REG(0x010),
+	.hw.init = &pll_video0_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 3),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_P(0, 2),
+	.features = CCU_FEATURE_N0,
+};
+static const char * const child_pll_video0[] __initconst = { pll_video0 };
+
+/* video engine */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static const char pll_ve[] __initconst = "pll-ve";
+static const struct clk_init_data pll_ve_init __initconst = {
+	CCU_HW(pll_ve, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_ve_clk __initconst = {
+	CCU_REG(0x018),
+	.hw.init = &pll_ve_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 4),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+static const char * const child_pll_ve[] __initconst = { pll_ve };
+
+/* ddr */
+/*	rate = 24MHz * (n + 1) / (d1 + 1) / (d2 + 1)
+ *	bit 21: DDR_CLOCK = PLL_DDR / PLL_PERIPH (default DDR)
+ */
+static const char pll_ddr[] __initconst = "pll-ddr";
+static const struct clk_init_data pll_ddr_init __initconst = {
+	CCU_HW(pll_ddr, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_ddr_clk __initconst = {
+	CCU_REG(0x020),
+	.hw.init = &pll_ddr_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 5),
+	CCU_N(8, 6), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	CCU_UPD(30),
+};
+static const char * const child_pll_ddr[] __initconst = { pll_ddr };
+
+/* periph */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static const char pll_periph[] __initconst = "pll-periph";
+static const struct clk_init_data pll_periph_init __initconst = {
+	CCU_HW(pll_periph, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_periph_clk __initconst = {
+	CCU_REG(0x028),
+	.hw.init = &pll_periph_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 6),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+static const char * const child_pll_periph[] __initconst = { pll_periph };
+
+/* gpu */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static const char pll_gpu[] __initconst = "pll-gpu";
+static const struct clk_init_data pll_gpu_init __initconst = {
+	CCU_HW(pll_gpu, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_gpu_clk __initconst = {
+	CCU_REG(0x038),
+	.hw.init = &pll_gpu_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 7),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+static const char * const child_pll_gpu[] __initconst = { pll_gpu };
+
+/* hsic */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static const char pll_hsic[] __initconst = "pll-hsic";
+static const struct clk_init_data pll_hsic_init __initconst = {
+	CCU_HW(pll_hsic, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_hsic_clk __initconst = {
+	CCU_REG(0x044),
+	.hw.init = &pll_hsic_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 8),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* display engine */
+/*	rate = 24MHz * n / (d1 + 1) / (d2 + 1) */
+static const char pll_de[] __initconst = "pll-de";
+static const struct clk_init_data pll_de_init __initconst = {
+	CCU_HW(pll_de, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_de_clk __initconst = {
+	CCU_REG(0x048),
+	.hw.init = &pll_de_init,
+	CCU_RESET(0x2c4, 12),
+	CCU_BUS(0x64, 12),
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 9),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_D2(18, 1),
+	.features = CCU_FEATURE_N0,
+};
+
+/* video 1 */
+/*	rate = 24MHz * n / (d1 + 1) >> p */
+static const char pll_video1[] __initconst = "pll-video1";
+static const struct clk_init_data pll_video1_init __initconst = {
+	CCU_HW(pll_video1, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_video1_clk __initconst = {
+	CCU_REG(0x04c),
+	.hw.init = &pll_video1_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x20c, 10),
+	CCU_N(8, 8), .n_min = 12,
+	CCU_D1(16, 1),
+	CCU_P(0, 2),
+	.features = CCU_FEATURE_N0,
+};
+static const char * const child_pll_video1[] __initconst = { pll_video1 };
+
+static const char c0cpux[] __initconst = "c0cpux";
+static const char * const c0cpux_parents[] __initconst = {
+				hosc, pll_c0cpux
+};
+static const struct clk_init_data c0cpux_init __initconst = {
+	CCU_HW(c0cpux, c0cpux_parents, &ccu_periph_ops),
+	.flags = CLK_IS_CRITICAL,
+};
+static const struct ccu c0cpux_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &c0cpux_init,
+	CCU_MUX(12, 1),
+};
+static const char * const child_c0cpux[] = { c0cpux };
+
+static const char axi0[] __initconst = "axi0";
+static const struct clk_init_data axi0_init __initconst = {
+	CCU_HW(axi0, child_c0cpux, &ccu_periph_ops),
+};
+static const struct ccu axi0_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &axi0_init,
+	CCU_M(0, 2),
+};
+
+static const char c1cpux[] __initconst = "c1cpux";
+static const char * const c1cpux_parents[] __initconst = {
+					hosc, pll_c1cpux
+};
+static const struct clk_init_data c1cpux_init __initconst = {
+	CCU_HW(c1cpux, c1cpux_parents, &ccu_periph_ops),
+	.flags = CLK_IS_CRITICAL,
+};
+static const struct ccu c1cpux_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &c1cpux_init,
+	CCU_MUX(28, 1),
+};
+static const char * const child_c1cpux[] = { c1cpux };
+
+static const char axi1[] __initconst = "axi1";
+static const struct clk_init_data axi1_init __initconst = {
+	CCU_HW("axi1", child_c1cpux, &ccu_periph_ops),
+};
+static const struct ccu axi1_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &axi1_init,
+	CCU_M(16, 2),
+};
+
+static const char ahb1[] __initconst = "ahb1";
+static const char * const ahb1_parents[] __initconst = {
+					losc, hosc, pll_periph
+};
+static const struct ccu_extra ahb1_extra = {
+	.variable_prediv = { .index = 2, .shift = 6, .width = 2 },
+};
+static const struct clk_init_data ahb1_init __initconst = {
+	CCU_HW(ahb1, ahb1_parents, &ccu_periph_ops),
+};
+static const struct ccu ahb1_clk __initconst = {
+	CCU_REG(0x054),
+	.hw.init = &ahb1_init,
+	CCU_MUX(12, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &ahb1_extra,
+};
+static const char * const child_ahb1[] __initconst = { ahb1 };
+
+static const char apb1[] __initconst = "apb1";
+static const struct clk_init_data apb1_init __initconst = {
+	CCU_HW("apb1", child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu apb1_clk __initconst = {
+	CCU_REG(0x054),
+
+	.hw.init = &apb1_init,
+	CCU_M(8, 2),
+};
+static const char * const child_apb1[] __initconst = { apb1 };
+
+static const char apb2[] __initconst = "apb2";
+static const char * const apb2_parents[] __initconst = {
+				losc, hosc, pll_periph, pll_periph
+};
+static const struct clk_init_data apb2_init __initconst = {
+	CCU_HW(apb2, apb2_parents, &ccu_periph_ops),
+};
+static const struct ccu apb2_clk __initconst = {
+	CCU_REG(0x058),
+	.hw.init = &apb2_init,
+	CCU_MUX(24, 2),
+	CCU_M(0, 5),
+	CCU_P(16, 2),
+};
+static const char * const child_apb2[] __initconst = { "apb2" };
+
+static const char ahb2[] __initconst = "ahb2";
+#if 1 // from bpi-m3 code
+static const struct clk_init_data ahb2_init __initconst = {
+	CCU_HW(ahb2, child_pll_periph, &ccu_fixed_factor_ops),
+};
+static const struct ccu ahb2_clk __initconst = {
+	.hw.init = &ahb2_init,
+	CCU_FIXED(1, 2),
+};
+#else // from doc
+static const char * const ahb2_parents[] __initconst = {
+				ahb1, pll_periph
+};
+static const struct ccu_extra ahb2_extra = {
+	.fixed_div = { 1, 2},
+};
+static const struct clk_init_data ahb2_init __initconst = {
+	CCU_HW(ahb2, ahb2_parents, &ccu_periph_ops),
+};
+static const struct ccu ahb2_clk __initconst = {
+	CCU_REG(0x05c),
+	.hw.init = &ahb2_init,
+	CCU_MUX(0, 2),
+	.features = CCU_FEATURE_MUX_FIXED_PREDIV,
+	.extra = &ahb2_extra,
+};
+#endif
+static const char * const child_ahb2[] __initconst = { ahb2 };
+
+#if 0 //useless
+static const char bus_mipi_dsi[] __initconst = "bus-mipi-dsi";
+static const struct clk_init_data bus_mipi_dsi_init __initconst = {
+	CCU_HW(bus_mipi_dsi, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mipi_dsi_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_mipi_dsi_init,
+	CCU_GATE(1),
+};
+static const char bus_ss[] __initconst = "bus-ss";
+static const struct clk_init_data bus_ss_init __initconst = {
+	CCU_HW(bus_ss, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ss_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ss_init,
+	CCU_GATE(5),
+};
+#endif
+static const char bus_dma[] __initconst = "bus-dma";
+static const struct clk_init_data bus_dma_init __initconst = {
+	CCU_HW(bus_dma, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_dma_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_dma_init,
+	CCU_GATE(6),
+};
+static const char bus_mmc0[] __initconst = "bus-mmc0";
+static const struct clk_init_data bus_mmc0_init __initconst = {
+	CCU_HW(bus_mmc0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc0_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc0_init,
+////	CCU_GATE(8),
+};
+static const char bus_mmc1[] __initconst = "bus-mmc1";
+static const struct clk_init_data bus_mmc1_init __initconst = {
+	CCU_HW(bus_mmc1, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc1_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc1_init,
+////	CCU_GATE(9),
+};
+static const char bus_mmc2[] __initconst = "bus-mmc2";
+static const struct clk_init_data bus_mmc2_init __initconst = {
+	CCU_HW(bus_mmc2, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc2_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc2_init,
+////	CCU_GATE(10),
+};
+#if 0 //useless
+static const char bus_nand[] __initconst = "bus-nand";
+static const struct clk_init_data bus_nand_init __initconst = {
+	CCU_HW(bus_nand, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_nand_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_nand_init,
+	CCU_GATE(13),
+};
+static const char bus_dram[] __initconst = "bus-dram";
+static const struct clk_init_data bus_dram_init __initconst = {
+	CCU_HW(bus_dram, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_dram_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_dram_init,
+	CCU_GATE(14),
+};
+static const char bus_emac[] __initconst = "bus-emac";
+static const struct clk_init_data bus_emac_init __initconst = {
+	CCU_HW(bus_emac, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_emac_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_emac_init,
+	CCU_GATE(17),
+};
+static const char bus_hstimer[] __initconst = "bus-hstimer";
+static const struct clk_init_data bus_hstimer_init __initconst = {
+	CCU_HW(bus_hstimer, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_hstimer_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_hstimer_init,
+	CCU_GATE(19),
+};
+static const char bus_spi0[] __initconst = "bus-spi0";
+static const struct clk_init_data bus_spi0_init __initconst = {
+	CCU_HW(bus_spi0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spi0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_spi0_init
+	CCU_GATE(20),
+};
+static const char bus_spi1[] __initconst = "bus-spi1";
+static const struct clk_init_data bus_spi1_init __initconst = {
+	CCU_HW(bus_spi1, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spi1_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_spi1_init,
+	CCU_GATE(21),
+};
+#endif
+static const char bus_usbdrd[] __initconst = "bus-usbdrd";
+static const struct clk_init_data bus_usbdrd_init __initconst = {
+	CCU_HW(bus_usbdrd, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_usbdrd_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_usbdrd_init,
+	CCU_GATE(24),
+};
+static const char bus_ehci0[] __initconst = "bus-ehci0";
+static const struct clk_init_data bus_ehci0_init __initconst = {
+	CCU_HW(bus_ehci0, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci0_init,
+	CCU_GATE(26),
+};
+static const char bus_ehci1[] __initconst = "bus-ehci1";
+static const struct clk_init_data bus_ehci1_init __initconst = {
+	CCU_HW(bus_ehci1, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci1_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci1_init,
+	CCU_GATE(27),
+};
+static const char bus_ohci0[] __initconst = "bus-ohci0";
+static const struct clk_init_data bus_ohci0_init __initconst = {
+	CCU_HW(bus_ohci0, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ohci0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ohci0_init,
+	CCU_GATE(29),
+};
+#if 0 //useless
+static const char bus_ve[] __initconst = "bus-ve";
+static const struct clk_init_data bus_ve_init __initconst = {
+	CCU_HW(bus_ve, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ve_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_ve_init,
+	CCU_GATE(0),
+};
+static const char bus_csie[] __initconst = "bus-csi";
+static const struct clk_init_data bus_csi_init __initconst = {
+	CCU_HW(bus_csi, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_csi_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_csi_init,
+	CCU_GATE(8),
+};
+static const char bus_gpu[] __initconst = "bus-gpu";
+static const struct clk_init_data bus_gpu_init __initconst = {
+	CCU_HW(bus_gpu, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_gpu_clk= {
+	CCU_REG(0x064),
+	.hw.init = &bus_gpu_init,
+	CCU_GATE(20),
+};
+static const char bus_msgbox[] __initconst = "bus-msgbox";
+static const struct clk_init_data bus_msgbox_init __initconst = {
+	CCU_HW(bus_msgbox, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_msgbox_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_msgbox_init,
+	CCU_GATE(21),
+};
+static const char bus_spinlock[] __initconst = "bus-spinlock";
+static const struct clk_init_data bus_spinlock_init __initconst = {
+	CCU_HW(bus_spinlock, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spinlock_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_spinlock_init,
+	CCU_GATE(22),
+};
+
+static const char bus_spdif[] __initconst = "bus-spdif";
+static const struct clk_init_data bus_spdif_init __initconst = {
+	CCU_HW(bus_spdif, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spdif_clk __initconst = {
+	CCU_REG(0x068),
+	.hw.init = &bus_spdif_init,
+	CCU_GATE(1),
+};
+#endif
+static const char bus_pio[] __initconst = "bus-pio";
+static const struct clk_init_data bus_pio_init __initconst = {
+	CCU_HW(bus_pio, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_pio_clk __initconst = {
+	CCU_REG(0x068),
+	.hw.init = &bus_pio_init,
+	CCU_GATE(5),
+};
+#if 0 //useless
+static const char bus_i2c0[] __initconst = "bus-i2c0";
+static const struct clk_init_data bus_i2c0_init __initconst = {
+	CCU_HW(bus_i2c0, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c0_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c0_init,
+	CCU_GATE(0),
+};
+static const char bus_i2c1[] __initconst = "bus-i2c1";
+static const struct clk_init_data bus_i2c1_init __initconst = {
+	CCU_HW(bus_i2c1, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c1_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c1_init,
+	CCU_GATE(1),
+};
+static const char bus_i2c2[] __initconst = "bus-i2c2";
+static const struct clk_init_data bus_i2c2_init __initconst = {
+	CCU_HW(bus_i2c2, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c2_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c2_init,
+	CCU_GATE(2),
+};
+#endif
+static const char bus_uart0[] __initconst = "bus-uart0";
+static const struct clk_init_data bus_uart0_init __initconst = {
+	CCU_HW(bus_uart0, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart0_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart0_init,
+	CCU_GATE(16),
+};
+static const char bus_uart1[] __initconst = "bus-uart1";
+static const struct clk_init_data bus_uart1_init __initconst = {
+	CCU_HW(bus_uart1, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart1_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart1_init,
+	CCU_GATE(17),
+};
+static const char bus_uart2[] __initconst = "bus-uart2";
+static const struct clk_init_data bus_uart2_init __initconst = {
+	CCU_HW(bus_uart2, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart2_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart2_init,
+	CCU_GATE(18),
+};
+static const char bus_uart3[] __initconst = "bus-uart3";
+static const struct clk_init_data bus_uart3_init __initconst = {
+	CCU_HW(bus_uart3, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart3_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart3_init,
+	CCU_GATE(19),
+};
+static const char bus_uart4[] __initconst = "bus-uart4";
+static const struct clk_init_data bus_uart4_init __initconst = {
+	CCU_HW(bus_uart4, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart4_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart4_init,
+	CCU_GATE(20),
+};
+
+static const char cci400[] __initconst = "cci400";
+static const char * const cci400_parents[] __initconst = {
+				hosc, pll_periph, pll_hsic
+};
+static const struct clk_init_data cci400_init __initconst = {
+	CCU_HW(cci400, cci400_parents, &ccu_periph_ops),
+};
+static const struct ccu cci400_clk __initconst = {
+	CCU_REG(0x078),
+	.hw.init = &cci400_init,
+	CCU_MUX(24, 2),
+	CCU_M(0, 2),
+};
+
+static const char nand[] __initconst = "nand";
+static const char * const mmc_parents[] __initconst = { hosc, pll_periph };
+static const struct clk_init_data nand_init __initconst = {
+	CCU_HW(nand, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu nand_clk __initconst = {
+	CCU_REG(0x080),
+	.hw.init = &nand_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x060, 13),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char mmc0[] __initconst = "mmc0";
+static const struct clk_init_data mmc0_init __initconst = {
+	CCU_HW(mmc0, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc0_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 8),
+	CCU_BUS(0x060, 8),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static const char * const child_mmc0[] __initconst = { mmc0 };
+static const char mmc0_sample[] __initconst = "mmc0-sample";
+static const struct clk_init_data mmc0_sample_init __initconst = {
+	CCU_HW(mmc0_sample, child_mmc0, &ccu_phase_ops),
+};
+static const struct ccu mmc0_sample_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_sample_init,
+	CCU_PHASE(20, 3),
+};
+static const char mmc0_output[] __initconst = "mmc0-output";
+static const struct clk_init_data mmc0_output_init __initconst = {
+	CCU_HW(mmc0_output, child_mmc0, &ccu_phase_ops),
+};
+static const struct ccu mmc0_output_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_output_init,
+	CCU_PHASE(8, 3),
+};
+
+static const char mmc1[] __initconst = "mmc1";
+static const struct clk_init_data mmc1_init __initconst = {
+	CCU_HW(mmc1, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc1_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 9),
+	CCU_BUS(0x060, 9),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static const char * const child_mmc1[] __initconst = { mmc1 };
+static const char mmc1_sample[] __initconst = "mmc1-sample";
+static const struct clk_init_data mmc1_sample_init __initconst = {
+	CCU_HW(mmc1_sample, child_mmc1, &ccu_phase_ops),
+};
+static const struct ccu mmc1_sample_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_sample_init,
+	CCU_PHASE(20, 3),
+};
+static const char mmc1_output[] __initconst = "mmc1-output";
+static const struct clk_init_data mmc1_output_init __initconst = {
+	CCU_HW(mmc1_output, child_mmc1, &ccu_phase_ops),
+};
+static const struct ccu mmc1_output_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_output_init,
+	CCU_PHASE(8, 3),
+};
+
+static const char mmc2[] __initconst = "mmc2";
+static const struct ccu_extra mmc_extra = {
+	.mode_select.rate = 50000000,
+	.mode_select.bit = 30,
+};
+static const struct clk_init_data mmc2_init __initconst = {
+	CCU_HW(mmc2, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc2_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 10),
+	CCU_BUS(0x060, 10),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char * const child_mmc2[] __initconst = { mmc2 };
+static const char mmc2_sample[] __initconst = "mmc2-sample";
+static const struct clk_init_data mmc2_sample_init __initconst = {
+	CCU_HW(mmc2_sample, child_mmc2, &ccu_phase_ops),
+};
+static const struct ccu mmc2_sample_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_sample_init,
+	CCU_PHASE(20, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char mmc2_output[] __initconst = "mmc2-output";
+static const struct clk_init_data mmc2_output_init __initconst = {
+	CCU_HW(mmc2_output, child_mmc2, &ccu_phase_ops),
+};
+static const struct ccu mmc2_output_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_output_init,
+	CCU_PHASE(8, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+
+static const char ss[] __initconst = "ss";
+static const struct clk_init_data ss_init __initconst = {
+	CCU_HW(ss, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu ss_clk __initconst = {
+	CCU_REG(0x09c),
+	.hw.init = &ss_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x060, 5),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char spi0[] __initconst = "spi0";
+static const struct clk_init_data spi0_init __initconst = {
+	CCU_HW(spi0, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu spi0_clk __initconst = {
+	CCU_REG(0x0a0),
+	.hw.init = &spi0_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x060, 20),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char spi1[] __initconst = "spi1";
+static const struct clk_init_data spi1_init __initconst = {
+	CCU_HW(spi1, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu spi1_clk __initconst = {
+	CCU_REG(0x0a4),
+	.hw.init = &spi1_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x060, 21),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char i2s0[] __initconst = "i2s0";
+static const struct clk_init_data i2s0_init __initconst = {
+	CCU_HW(i2s0, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s0_clk __initconst = {
+	CCU_REG(0x0b0),
+	.hw.init = &i2s0_init,
+	CCU_BUS(0x068, 12),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+static const char i2s1[] __initconst = "i2s1";
+static const struct clk_init_data i2s1_init __initconst = {
+	CCU_HW(i2s1, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s1_clk __initconst = {
+	CCU_REG(0x0b4),
+	.hw.init = &i2s1_init,
+	CCU_GATE(31),
+	CCU_BUS(0x068, 13),
+	CCU_M(0, 4),
+};
+
+static const char i2s2[] __initconst = "i2s2";
+static const struct clk_init_data i2s2_init __initconst = {
+	CCU_HW(i2s2, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s2_clk __initconst = {
+	CCU_REG(0x0b8),
+	.hw.init = &i2s2_init,
+	CCU_GATE(31),
+	CCU_BUS(0x068, 14),
+	CCU_M(0, 4),
+};
+
+static const char tdm[] __initconst = "tdm";
+static const struct clk_init_data tdm_init __initconst = {
+	CCU_HW(tdm, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu tdm_clk __initconst = {
+	CCU_REG(0x0bc),
+	.hw.init = &tdm_init,
+	CCU_BUS(0x068, 15),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char spdif[] __initconst = "spdif";
+static const struct clk_init_data spdif_init __initconst = {
+	CCU_HW(spdif, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu spdif_clk __initconst = {
+	CCU_REG(0x0c0),
+	.hw.init = &spdif_init,
+	CCU_BUS(0x068, 1),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char usb_phy0[] __initconst = "usb-phy0";
+static const struct clk_init_data usb_phy0_init __initconst = {
+	CCU_HW(usb_phy0, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy0_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy0_init,
+	CCU_GATE(8),
+};
+
+static const char usb_phy1[] __initconst = "usb-phy1";
+static const struct clk_init_data usb_phy1_init __initconst = {
+	CCU_HW(usb_phy1, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy1_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy1_init,
+	CCU_GATE(9),
+};
+
+static const char usb_hsic[] __initconst = "usb-hsic";
+static const struct clk_init_data usb_hsic_init __initconst = {
+	CCU_HW(usb_hsic, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_hsic_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_hsic_init,
+	CCU_GATE(10),
+};
+
+static const char osc12M[] __initconst = "osc12M";
+static const struct clk_init_data osc12M_init __initconst = {
+	CCU_HW(osc12M, child_hosc, &ccu_fixed_factor_ops),
+};
+static const struct ccu osc12M_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &osc12M_init,
+	CCU_GATE(11),
+	CCU_FIXED(1, 2),
+};
+
+static const char ohci0[] __initconst = "ohci0";
+static const struct clk_init_data ohci0_init __initconst = {
+	CCU_HW(ohci0, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ohci0_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &ohci0_init,
+	CCU_GATE(16),
+};
+
+static const char dram[] __initconst = "dram";
+static const struct clk_init_data dram_init __initconst = {
+	CCU_HW(dram, child_pll_ddr, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu dram_clk __initconst = {
+	CCU_REG(0x0f4),
+	.hw.init = &dram_init,
+	CCU_BUS(0x060, 14),
+	CCU_M(0, 4),
+	CCU_UPD(16),
+};
+static const char * const child_dram[] __initconst = { "dram" };
+
+/* pll_ddr config not done */
+
+static const char dram_ve[] __initconst = "dram-ve";
+static const struct clk_init_data dram_ve_init __initconst = {
+	CCU_HW(dram_ve, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_ve_clk __initconst = {
+	CCU_REG(0x0100),
+	.hw.init = &dram_ve_init,
+	CCU_BUS(0x064, 0),
+	CCU_GATE(0),
+};
+
+static const char dram_csi[] __initconst = "dram-csi";
+static const struct clk_init_data dram_csi_init __initconst = {
+	CCU_HW(dram_csi, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_csi_clk __initconst = {
+	CCU_REG(0x0100),
+	.hw.init = &dram_csi_init,
+	CCU_GATE(1),
+};
+
+static const char tcon0[] __initconst = "tcon0";
+static const struct clk_init_data tcon0_init __initconst = {
+	CCU_HW(tcon0, child_pll_video0, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu tcon0_clk __initconst = {
+	CCU_REG(0x118),
+	.hw.init = &tcon0_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c4, 4),
+	CCU_BUS(0x064, 4),
+	CCU_GATE(31),
+};
+
+static const char tcon1[] __initconst = "tcon1";
+static const struct clk_init_data tcon1_init __initconst = {
+	CCU_HW(tcon1, child_pll_video1, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu tcon1_clk __initconst = {
+	CCU_REG(0x11c),
+	.hw.init = &tcon1_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c4, 5),
+	CCU_BUS(0x064, 5),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char csi_misc[] __initconst = "csi-misc";
+static const struct clk_init_data csi_misc_init __initconst = {
+	CCU_HW(csi_misc, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu csi_misc_clk __initconst = {
+	CCU_REG(0x0130),
+	.hw.init = &csi_misc_init,
+	CCU_GATE(16),
+};
+
+static const char mipi_csi[] __initconst = "mipi-csi";
+static const struct clk_init_data mipi_csi_init __initconst = {
+	CCU_HW(mipi_csi, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu mipi_csi_clk __initconst = {
+	CCU_REG(0x0130),
+	.hw.init = &mipi_csi_init,
+	CCU_GATE(31),
+};
+
+static const char csi_sclk[] __initconst = "csi-sclk";
+static const char * const csi_sclk_parents[] __initconst = {
+			pll_periph, "", "", "", "", pll_ve
+};
+static const struct clk_init_data csi_sclk_init __initconst = {
+	CCU_HW(csi_sclk, csi_sclk_parents, &ccu_periph_ops),
+};
+static const struct ccu csi_sclk_clk __initconst = {
+	CCU_REG(0x134),
+	.hw.init = &csi_sclk_init,
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(16, 4),
+};
+
+static const char csi_mclk[] __initconst = "csi-mclk";
+static const char * const csi_mclk_parents[] __initconst = {
+			"", "", "", pll_periph, "", hosc
+};
+static const struct clk_init_data csi_mclk_init __initconst = {
+	CCU_HW(csi_mclk, csi_mclk_parents, &ccu_periph_ops),
+};
+static const struct ccu csi_mclk_clk __initconst = {
+	CCU_REG(0x134),
+	.hw.init = &csi_mclk_init,
+	CCU_MUX(8, 3),
+	CCU_GATE(15),
+	CCU_M(0, 5),
+};
+
+static const char ve[] __initconst = "ve";
+static const struct clk_init_data ve_init __initconst = {
+	CCU_HW(ve, child_pll_ve, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu ve_clk __initconst = {
+	CCU_REG(0x13c),
+	.hw.init = &ve_init,
+	CCU_GATE(31),
+	CCU_M(16, 3),
+};
+
+static const char avs[] __initconst = "avs";
+static const struct clk_init_data avs_init __initconst = {
+	CCU_HW(avs, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu avs_clk __initconst = {
+	CCU_REG(0x0144),
+	.hw.init = &avs_init,
+	CCU_GATE(31),
+};
+
+static const char hdmi[] __initconst = "hdmi";
+static const struct clk_init_data hdmi_init __initconst = {
+	CCU_HW(hdmi, child_pll_video1, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu hdmi_clk __initconst = {
+	CCU_REG(0x150),
+	.hw.init = &hdmi_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x064, 11),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char hdmi_ddc[] __initconst = "hdmi-ddc";
+static const struct clk_init_data hdmi_ddc_init __initconst = {
+	CCU_HW(hdmi_ddc, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu hdmi_ddc_clk __initconst = {
+	CCU_REG(0x0154),
+	.hw.init = &hdmi_ddc_init,
+	CCU_GATE(31),
+};
+
+static const char mbus[] __initconst = "mbus";
+static const char * const mbus_parents[] __initconst = {
+				hosc, pll_periph, pll_ddr
+};
+static const struct clk_init_data mbus_init __initconst = {
+	CCU_HW(mbus, mbus_parents, &ccu_periph_ops),
+	.flags = CLK_IS_CRITICAL,
+};
+static const struct ccu mbus_clk __initconst = {
+	CCU_REG(0x15c),
+	.hw.init = &mbus_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static const char mipi_dsi0[] __initconst = "mipi-dsi0";
+static const struct clk_init_data mipi_dsi0_init __initconst = {
+	CCU_HW(mipi_dsi0, child_pll_video0, &ccu_periph_ops),
+};
+static const struct ccu mipi_dsi0_clk __initconst = {
+	CCU_REG(0x168),
+	.hw.init = &mipi_dsi0_init,
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char mipi_dsi1[] __initconst = "mipi-dsi1";
+static const char * const mipi_dsi1_parents[] __initconst = {
+			hosc, "", "", "", "", "", "", "", "", pll_video0
+};
+static const struct clk_init_data mipi_dsi1_init __initconst = {
+	CCU_HW(mipi_dsi1, mipi_dsi1_parents, &ccu_periph_ops),
+};
+static const struct ccu mipi_dsi1_clk __initconst = {
+	CCU_REG(0x16c),
+	.hw.init = &mipi_dsi1_init,
+	CCU_MUX(24, 4),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char gpu_core[] __initconst = "gpu-core";
+static const struct clk_init_data gpu_core_init __initconst = {
+	CCU_HW(gpu_core, child_pll_gpu, &ccu_periph_ops),
+};
+static const struct ccu gpu_core_clk __initconst = {
+	CCU_REG(0x1a0),
+	.hw.init = &gpu_core_init,
+	CCU_BUS(0x064, 20),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static const char gpu_mem[] __initconst = "gpu-mem";
+static const char * const gpu_mem_parents[] __initconst = {
+			pll_gpu, pll_periph
+};
+static const struct clk_init_data gpu_mem_init __initconst = {
+	CCU_HW(gpu_mem, gpu_mem_parents, &ccu_periph_ops),
+};
+static const struct ccu gpu_mem_clk __initconst = {
+	CCU_REG(0x1a4),
+	.hw.init = &gpu_mem_init,
+	CCU_MUX(24, 1),
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+static const char gpu_hyd[] __initconst = "gpu-hyd";
+static const struct clk_init_data gpu_hyd_init __initconst = {
+	CCU_HW(gpu_hyd, child_pll_gpu, &ccu_periph_ops),
+};
+static const struct ccu gpu_hyd_clk __initconst = {
+	CCU_REG(0x1a8),
+	.hw.init = &gpu_hyd_init,
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+/* ---- PRCM ---- */
+static const char * const cpus_parents[] __initconst = {
+			losc, hosc, pll_periph, iosc
+};
+//fixme: postdiv, not prediv...
+static const char cpus[] __initconst = "cpus";
+static const struct ccu_extra cpus_extra = {
+	.variable_prediv = { .index = 2, .shift = 8, .width = 4 },
+};
+static const struct clk_init_data cpus_init __initconst = {
+	CCU_HW(cpus, cpus_parents, &ccu_periph_ops),
+};
+static const struct ccu cpus_clk __initconst = {	/* = ahb0 */
+	CCU_REG1(0x000),
+	.hw.init = &cpus_init,
+	CCU_MUX(16, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &cpus_extra,
+};
+static const char * const child_cpus[] __initconst = { cpus };
+
+static const char apb0[] __initconst = "apb0";
+static const struct clk_init_data apb0_init __initconst = {
+	CCU_HW(apb0, child_cpus, &ccu_periph_ops),
+};
+static const struct ccu apb0_clk __initconst = {
+	CCU_REG1(0x00c),
+	.hw.init = &apb0_init,
+	CCU_M(0, 2),
+};
+static const char * const child_apb0[] __initconst = { apb0 };
+
+static const char bus_r_pio[] __initconst = "bus-r_pio";
+static const struct clk_init_data bus_r_pio_init __initconst = {
+	CCU_HW(bus_r_pio, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_pio_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_pio_init,
+	CCU_GATE(0),
+};
+static const char bus_r_cir[] __initconst = "bus-r_cir";
+static const struct clk_init_data bus_r_cir_init __initconst = {
+	CCU_HW(bus_r_cir, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_cir_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_cir_init,
+	CCU_GATE(1),
+};
+
+static const char bus_r_timer[] __initconst = "bus-r_timer";
+static const struct clk_init_data bus_r_timer_init __initconst = {
+	CCU_HW(bus_r_timer, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_timer_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_timer_init,
+	CCU_GATE(2),
+};
+static const char bus_r_rsb[] __initconst = "bus-r_rsb";
+static const struct clk_init_data bus_r_rsb_init __initconst = {
+	CCU_HW(bus_r_rsb, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_rsb_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_rsb_init,
+	CCU_GATE(3),
+};
+static const char bus_r_uart[] __initconst = "bus-r_uart";
+static const struct clk_init_data bus_r_uart_init __initconst = {
+	CCU_HW(bus_r_uart, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_uart_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_uart_init,
+	CCU_GATE(4),
+};
+static const char bus_r_twi[] __initconst = "bus-r_twi";
+static const struct clk_init_data bus_r_twi_init __initconst = {
+	CCU_HW(bus_r_twi, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_twi_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_twi_init,
+	CCU_GATE(6),
+};
+static const char bus_r_twd[] __initconst = "bus-r_twd";
+static const struct clk_init_data bus_r_twd_init __initconst = {
+	CCU_HW(bus_r_twd, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_twd_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_twd_init,
+	CCU_GATE(7),
+};
+
+/* system clocks and resets */
+static const struct ccu * const sun8i_a83t_ccu_clks[] __initconst = {
+	[CLK_BUS_DMA]		= &bus_dma_clk,
+	[CLK_BUS_EHCI0]		= &bus_ehci0_clk,
+	[CLK_BUS_EHCI1]		= &bus_ehci1_clk,
+	[CLK_BUS_MMC0]		= &bus_mmc0_clk,
+	[CLK_BUS_MMC1]		= &bus_mmc1_clk,
+	[CLK_BUS_MMC2]		= &bus_mmc2_clk,
+	[CLK_BUS_OHCI0]		= &bus_ohci0_clk,
+	[CLK_BUS_PIO]		= &bus_pio_clk,
+	[CLK_BUS_UART0]		= &bus_uart0_clk,
+	[CLK_BUS_UART1]		= &bus_uart1_clk,
+	[CLK_BUS_UART2]		= &bus_uart2_clk,
+	[CLK_BUS_UART3]		= &bus_uart3_clk,
+	[CLK_BUS_UART4]		= &bus_uart4_clk,
+	[CLK_BUS_USBDRD]	= &bus_usbdrd_clk,
+	[CLK_I2S0]		= &i2s0_clk,
+	[CLK_I2S1]		= &i2s1_clk,
+	[CLK_I2S2]		= &i2s2_clk,
+	[CLK_HDMI]		= &hdmi_clk,
+	[CLK_HDMI_DDC]		= &hdmi_ddc_clk,
+	[CLK_MMC0]		= &mmc0_clk,
+	[CLK_MMC0_SAMPLE]	= &mmc0_sample_clk,
+	[CLK_MMC0_OUTPUT]	= &mmc0_output_clk,
+	[CLK_MMC1]		= &mmc1_clk,
+	[CLK_MMC1_SAMPLE]	= &mmc1_sample_clk,
+	[CLK_MMC1_OUTPUT]	= &mmc1_output_clk,
+	[CLK_MMC2]		= &mmc2_clk,
+	[CLK_MMC2_SAMPLE]	= &mmc2_sample_clk,
+	[CLK_MMC2_OUTPUT]	= &mmc2_output_clk,
+	[CLK_OHCI0]		= &ohci0_clk,
+	[CLK_OSC12M]		= &osc12M_clk,
+	[CLK_PLL_AUDIO]		= &pll_audio_clk,
+	[CLK_PLL_DE]		= &pll_de_clk,
+	[CLK_PLL_GPU]		= &pll_gpu_clk,
+	[CLK_PLL_HSIC]		= &pll_hsic_clk,
+	[CLK_PLL_PERIPH]	= &pll_periph_clk,
+	[CLK_PLL_VE]		= &pll_ve_clk,
+	[CLK_PLL_VIDEO0]	= &pll_video0_clk,
+	[CLK_PLL_VIDEO1]	= &pll_video1_clk,
+	[CLK_SPDIF]		= &spdif_clk,
+	[CLK_SPI0]		= &spi0_clk,
+	[CLK_SPI1]		= &spi1_clk,
+	[CLK_TCON0]		= &tcon0_clk,
+	[CLK_TCON1]		= &tcon1_clk,
+	[CLK_TDM]		= &tdm_clk,
+	[CLK_USB_PHY0]		= &usb_phy0_clk,
+	[CLK_USB_PHY1]		= &usb_phy1_clk,
+	[CLK_USB_HSIC]		= &usb_hsic_clk,
+	[CLK_VE]		= &ve_clk,
+	[CLK_BUS_R_PIO]		= &bus_r_pio_clk,
+	[CLK_BUS_R_RSB]		= &bus_r_rsb_clk,
+	&pll_c0cpux_clk,
+	&pll_c1cpux_clk,
+	&pll_ddr_clk,
+	&c0cpux_clk,
+	&axi0_clk,
+	&c1cpux_clk,
+	&axi1_clk,
+	&ahb1_clk,
+	&apb1_clk,
+	&apb2_clk,
+	&ahb2_clk,
+//	&bus_mipi_dsi_clk,
+//	&bus_ss_clk,
+//	&bus_nand_clk,
+//	&bus_dram_clk,
+//	&bus_emac_clk,
+//	&bus_hstimer_clk,
+//	&bus_spi0_clk,
+//	&bus_spi1_clk,
+//	&bus_ve_clk,
+//	&bus_csi_clk,
+//	&bus_gpu_clk,
+//	&bus_msgbox_clk,
+//	&bus_spinlock_clk,
+//	&bus_spdif_clk,
+//	&bus_i2c0_clk,
+//	&bus_i2c1_clk,
+//	&bus_i2c2_clk,
+	&cci400_clk,
+	&nand_clk,
+	&ss_clk,
+	&dram_clk,
+	&dram_ve_clk,
+	&dram_csi_clk,
+	&csi_misc_clk,
+	&mipi_csi_clk,
+	&csi_sclk_clk,
+	&csi_mclk_clk,
+	&avs_clk,
+	&mbus_clk,
+	&mipi_dsi0_clk,
+	&mipi_dsi1_clk,
+	&gpu_core_clk,
+	&gpu_mem_clk,
+	&gpu_hyd_clk,
+	&cpus_clk,
+	&apb0_clk,
+	&bus_r_cir_clk,
+	&bus_r_timer_clk,
+	&bus_r_uart_clk,
+	&bus_r_twi_clk,
+	&bus_r_twd_clk,
+};
+
+static const struct ccu_reset_map sun8i_a83t_ccu_resets[] __initconst = {
+	[RST_USB_PHY0]	= { 0x0cc, 0 },
+	[RST_USB_PHY1]	= { 0x0cc, 1 },
+	[RST_USB_HSIC]	= { 0x0cc, 2 },
+
+	[RST_DRAM_CTR]	= { 0x0f4, 31 },
+	[RST_MBUS]	= { 0x0fc, 31 },
+
+	[RST_MIPI_DSI]	= { 0x2c0, 1 },
+	[RST_CE]	= { 0x2c0, 5 },
+	[RST_DMA]	= { 0x2c0, 6 },
+//	[RST_DE]	= { 0x2c0, 5 },
+//	[RST_MMC0]	= { 0x2c0, 8 },
+//	[RST_MMC1]	= { 0x2c0, 9 },
+//	[RST_MMC2]	= { 0x2c0, 10 },
+	[RST_NAND]	= { 0x2c0, 13 },
+	[RST_DRAM]	= { 0x2c0, 14 },
+	[RST_EMAC]	= { 0x2c0, 17 },
+	[RST_HSTIMER]	= { 0x2c0, 19 },
+	[RST_SPI0]	= { 0x2c0, 20 },
+	[RST_SPI1]	= { 0x2c0, 21 },
+	[RST_USBDRD]	= { 0x2c0, 24 },
+	[RST_EHCI0]	= { 0x2c0, 26 },
+	[RST_EHCI1]	= { 0x2c0, 27 },
+	[RST_OHCI0]	= { 0x2c0, 29 },
+
+	[RST_VE]	= { 0x2c4, 0 },
+//	[RST_TCON0]	= { 0x2c4, 4 },
+//	[RST_TCON1]	= { 0x2c4, 5 },
+	[RST_CSI]	= { 0x2c4, 8 },
+	[RST_HDMI0]	= { 0x2c4, 10 },
+	[RST_HDMI1]	= { 0x2c4, 11 },
+	[RST_GPU]	= { 0x2c4, 20 },
+	[RST_MSGBOX]	= { 0x2c4, 21 },
+	[RST_SPINLOCK]	= { 0x2c4, 22 },
+
+	[RST_LVDS]	= { 0x2c8, 0 },
+
+	[RST_SPDIF]	= { 0x2d0, 1 },
+	[RST_I2S0]	= { 0x2d0, 12 },
+	[RST_I2S1]	= { 0x2d0, 13 },
+	[RST_I2S2]	= { 0x2d0, 14 },
+	[RST_TDM]	= { 0x2d0, 15 },
+
+	[RST_I2C0]	= { 0x2d8, 0 },
+	[RST_I2C1]	= { 0x2d8, 1 },
+	[RST_I2C2]	= { 0x2d8, 2 },
+	[RST_UART0]	= { 0x2d8, 16 },
+	[RST_UART1]	= { 0x2d8, 17 },
+	[RST_UART2]	= { 0x2d8, 18 },
+	[RST_UART3]	= { 0x2d8, 19 },
+	[RST_UART4]	= { 0x2d8, 20 },
+
+	[RST_R_CIR]	= { 0x0b0, 1, 1 },
+	[RST_R_TIMER]	= { 0x0b0, 2, 1 },
+	[RST_R_RSB]	= { 0x0b0, 3, 1 },
+	[RST_R_UART]	= { 0x0b0, 4, 1 },
+	[RST_R_TWI]	= { 0x0b0, 6, 1 },
+};
+
+static void __init sun8i_a83t_ccu_setup(struct device_node *node)
+{
+	ccu_probe(node, sun8i_a83t_ccu_clks,
+			ARRAY_SIZE(sun8i_a83t_ccu_clks),
+			sun8i_a83t_ccu_resets,
+			ARRAY_SIZE(sun8i_a83t_ccu_resets));
+}
+CLK_OF_DECLARE(sun8i_a83t_ccu, "allwinner,sun8i-a83t-ccu",
+	       sun8i_a83t_ccu_setup);
diff --git a/drivers/clk/sunxi/ccu-sun8i-h3.c b/drivers/clk/sunxi/ccu-sun8i-h3.c
new file mode 100644
index 0000000..b3c501c
--- /dev/null
+++ b/drivers/clk/sunxi/ccu-sun8i-h3.c
@@ -0,0 +1,1581 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on 'sunxi-ng' from
+ * Copyright (c) 2016 Maxime Ripard. All rights reserved.
+ * and sun8i SDK
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+
+#include <dt-bindings/clock/sun8i-h3.h>
+#include <dt-bindings/reset/sun8i-h3.h>
+
+#include "ccu.h"
+
+static const char losc[] __initconst = "osc32k";
+static const char hosc[] __initconst = "osc24M";
+static const char * const child_hosc[] __initconst = { hosc };
+
+/* ---- CCU ---- */
+
+/* cpux */
+/*	rate = 24MHz * (n - 1) * (k - 1) / (m - 1) >> p */
+static const char pll_cpux[] __initconst = "pll-cpux";
+static const struct clk_init_data pll_cpux_init __initconst = {
+	CCU_HW(pll_cpux, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_cpux_clk __initconst = {
+	CCU_REG(0x000),
+	.hw.init = &pll_cpux_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x000, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	CCU_M(0, 2),
+	CCU_P(16, 2),		/* only if rate < 288MHz */
+	.features = CCU_FEATURE_FLAT_FACTORS,
+};
+
+/* audio */
+/*	rate = 22579200Hz or 24576000Hz with sigma-delta */
+/*   or	rate = 24Hz * (n + 1) / (m + 1) / (p + 1) */
+static const char pll_audio[] __initconst = "pll-audio";
+#define NMP_MASK (GENMASK(14, 8) | GENMASK(4, 0) | GENMASK(19, 16))
+#define SDM_BIT BIT(24)
+static const struct frac audio_fracs[] = {
+	{
+		.rate = 22579200,
+		.mask = SDM_BIT | NMP_MASK,
+		.val = SDM_BIT | (6 << 8) | (7 << 16), /* n=6 p=7 */
+		.sd_reg = 0x284,
+		.sd_val = 0xc0010d84,
+	},
+	{
+		.rate = 24576000,
+		.mask =  SDM_BIT | NMP_MASK,
+		.val = SDM_BIT | (13 << 8) | (13 << 16), /* n=13 p=13 */
+		.sd_reg = 0x284,
+		.sd_val = 0xc000ac02,
+	},
+	{
+		.rate = 0,
+		.mask = SDM_BIT | NMP_MASK,
+		.val = 3 << 16,				/* p=4 */
+	},
+};
+static const struct ccu_extra audio_extra = {
+	CCU_EXTRA_FRAC(audio_fracs),
+	CCU_EXTRA_POST_DIV(4),		/* not used when sigma-delta */
+};
+static const struct clk_init_data pll_audio_init __initconst = {
+	CCU_HW(pll_audio, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_audio_clk __initconst = {
+	CCU_REG(0x008),
+	.hw.init = &pll_audio_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x008, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 5),
+	/* p set by fractional table */
+	.features = CCU_FEATURE_FIXED_POSTDIV,
+	.extra = &audio_extra,
+};
+static const char * const child_pll_audio[] __initconst = { pll_audio };
+
+static const char pll_audio_2x[] __initconst = "pll-audio-2x";
+static const struct clk_init_data pll_audio_2x_init __initconst = {
+	CCU_HW(pll_audio_2x, child_pll_audio, &ccu_fixed_factor_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu pll_audio_2x_clk __initconst = {
+	.hw.init = &pll_audio_2x_init,
+	CCU_FIXED(2, 1),
+};
+
+static const char pll_audio_4x[] __initconst = "pll-audio-4x";
+static const struct clk_init_data pll_audio_4x_init __initconst = {
+	CCU_HW(pll_audio_4x, child_pll_audio, &ccu_fixed_factor_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu pll_audio_4x_clk __initconst = {
+	.hw.init = &pll_audio_4x_init,
+	CCU_FIXED(4, 1),
+};
+
+static const char pll_audio_8x[] __initconst = "pll-audio-8x";
+static const struct clk_init_data pll_audio_8x_init __initconst = {
+	CCU_HW(pll_audio_8x, child_pll_audio, &ccu_fixed_factor_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu pll_audio_8x_clk __initconst = {
+	.hw.init = &pll_audio_8x_init,
+	CCU_FIXED(8, 1),
+};
+
+/* video */
+/*	rate = 24MHz * (n + 1) / (m + 1) */
+static const char pll_video[] __initconst = "pll-video";
+#define M_MASK_0_3 0x0f
+static const struct frac video_fracs[] = {
+/*	   rate		mask			    val */
+	{270000000, M_MASK_0_3 | BIT(24) | BIT(25), 0},
+	{297000000, M_MASK_0_3 | BIT(24) | BIT(25), BIT(25)},
+	{0,			 BIT(24) | BIT(25), BIT(24)},
+};
+static const struct ccu_extra video_extra = {
+	CCU_EXTRA_FRAC(video_fracs),
+};
+static const struct clk_init_data pll_video_init __initconst = {
+	CCU_HW(pll_video, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_video_clk __initconst = {
+	CCU_REG(0x010),
+	.hw.init = &pll_video_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x010, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+static const char * const child_pll_video[] __initconst = { pll_video };
+
+/* video engine */
+/*	rate = 24MHz * (n + 1) / (m + 1) */
+static const char pll_ve[] __initconst = "pll-ve";
+static const struct clk_init_data pll_ve_init __initconst = {
+	CCU_HW(pll_ve, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_ve_clk __initconst = {
+	CCU_REG(0x018),
+	.hw.init = &pll_ve_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x018, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+static const char * const child_pll_ve[] __initconst = { pll_ve };
+
+/* ddr */
+/*	rate = 24MHz * (n + 1) * (k + 1) / (m + 1)
+ *	bit 21: DDR_CLOCK = PLL_DDR / PLL_PERIPH (default DDR)
+ */
+static const char pll_ddr[] __initconst = "pll-ddr";
+static const struct clk_init_data pll_ddr_init __initconst = {
+	CCU_HW(pll_ddr, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_ddr_clk __initconst = {
+	CCU_REG(0x020),
+	.hw.init = &pll_ddr_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x020, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	CCU_M(0, 2),
+	CCU_UPD(20),
+};
+static const char * const child_pll_ddr[] __initconst = { pll_ddr };
+
+/* periph0 */
+/*	rate = 24MHz * (n + 1) * (k + 1) / 2 */
+static const char pll_periph0[] __initconst = "pll-periph0";
+static const struct ccu_extra periph_extra = {
+	CCU_EXTRA_POST_DIV(2),
+};
+static const struct clk_init_data pll_periph0_init __initconst = {
+	CCU_HW(pll_periph0, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_periph0_clk __initconst = {
+	CCU_REG(0x028),
+	.hw.init = &pll_periph0_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x028, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	.features = CCU_FEATURE_FIXED_POSTDIV,
+	.extra = &periph_extra,
+};
+static const char * const child_pll_periph0[] = { pll_periph0 };
+
+static const char pll_periph0_2x[] __initconst = "pll-periph0-2x";
+static const struct clk_init_data pll_periph0_2x_init __initconst = {
+	CCU_HW(pll_periph0_2x, child_pll_periph0, &ccu_fixed_factor_ops),
+};
+static const struct ccu pll_periph0_2x_clk __initconst = {
+	.hw.init = &pll_periph0_2x_init,
+	CCU_FIXED(2, 1),
+};
+
+/* gpu */
+/*	rate = 24MHz * (n + 1) / (m + 1) */
+static const char pll_gpu[] __initconst = "pll-gpu";
+static const struct clk_init_data pll_gpu_init __initconst = {
+	CCU_HW(pll_gpu, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_gpu_clk __initconst = {
+	CCU_REG(0x038),
+	.hw.init = &pll_gpu_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x038, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+static const char * const child_pll_gpu[] __initconst = { pll_gpu };
+
+/* periph1 */
+/*	rate = 24MHz * (n + 1) * (k + 1) / 2 */
+static const char pll_periph1[] __initconst = "pll-periph1";
+static const struct clk_init_data pll_periph1_init __initconst = {
+	CCU_HW(pll_periph1, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_periph1_clk __initconst = {
+	CCU_REG(0x044),
+	.hw.init = &pll_periph1_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x044, 28),
+	CCU_N(8, 5),
+	CCU_K(4, 2),
+	.features = CCU_FEATURE_FIXED_POSTDIV,
+	.extra = &periph_extra,
+};
+
+/* display engine */
+/*	rate = 24MHz * (n + 1) / (m + 1) */
+static const char pll_de[] __initconst = "pll-de";
+static const struct clk_init_data pll_de_init __initconst = {
+	CCU_HW(pll_de, child_hosc, &ccu_pll_ops),
+};
+static const struct ccu pll_de_clk __initconst = {
+	CCU_REG(0x048),
+	.hw.init = &pll_de_init,
+	CCU_GATE(31),
+	CCU_LOCK(0x048, 28),
+	CCU_N(8, 7),
+	CCU_M(0, 4),
+	.extra = &video_extra,
+};
+
+static const char * const cpux_parents[] __initconst = {
+				losc, hosc, pll_cpux, pll_cpux
+};
+static const char cpux[] __initconst = "cpux";
+static const struct clk_init_data cpux_init __initconst = {
+	CCU_HW(cpux, cpux_parents, &ccu_periph_ops),
+	.flags = CLK_IS_CRITICAL,
+};
+static const struct ccu cpux_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &cpux_init,
+	CCU_MUX(16, 2),
+};
+static const char * const child_cpux[] __initconst = { cpux };
+
+static const char axi[] __initconst = "axi";
+static const struct clk_init_data axi_init __initconst = {
+	CCU_HW(axi, child_cpux, &ccu_periph_ops),
+};
+static const struct ccu axi_clk __initconst = {
+	CCU_REG(0x050),
+	.hw.init = &axi_init,
+	CCU_M(0, 2),
+};
+
+static const char ahb1[] __initconst = "ahb1";
+static const char * const ahb1_parents[] __initconst = {
+				losc, hosc, axi, pll_periph0
+};
+static const struct ccu_extra ahb1_extra = {
+	.variable_prediv = { .index = 3, .shift = 6, .width = 2 },
+};
+static const struct clk_init_data ahb1_init __initconst = {
+	CCU_HW(ahb1, ahb1_parents, &ccu_periph_ops),
+};
+static const struct ccu ahb1_clk __initconst = {
+	CCU_REG(0x054),
+	.hw.init = &ahb1_init,
+	CCU_MUX(12, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &ahb1_extra,
+};
+static const char * const child_ahb1[] __initconst = { ahb1 };
+
+static const char apb1[] __initconst = "apb1";
+static const struct ccu_extra apb1_extra = {
+	.m_table = { 2, 2, 4, 8 },
+};
+static const struct clk_init_data apb1_init __initconst = {
+	CCU_HW(apb1, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu apb1_clk __initconst = {
+	CCU_REG(0x054),
+	.hw.init = &apb1_init,
+	CCU_M(8, 2),
+	.features = CCU_FEATURE_M_TABLE,
+	.extra = &apb1_extra,
+};
+static const char * const child_apb1[] __initconst = { apb1 };
+
+static const char apb2[] __initconst = "apb2";
+static const char * const apb2_parents[] __initconst = {
+				losc, hosc, pll_periph0, pll_periph0
+};
+static const struct clk_init_data apb2_init __initconst = {
+	CCU_HW(apb2, apb2_parents, &ccu_periph_ops),
+};
+static const struct ccu apb2_clk __initconst = {
+	CCU_REG(0x058),
+	.hw.init = &apb2_init,
+	CCU_MUX(24, 2),
+	CCU_M(0, 5),
+	CCU_P(16, 2),
+};
+static const char * const child_apb2[] __initconst = { apb2 };
+
+static const char ahb2[] __initconst = "ahb2";
+static const char * const ahb2_parents[] __initconst = {
+				ahb1, pll_periph0
+};
+static const struct ccu_extra ahb2_extra = {
+	.fixed_div = { 1, 2 },
+};
+static const struct clk_init_data ahb2_init __initconst = {
+	CCU_HW(ahb2, ahb2_parents, &ccu_periph_ops),
+};
+static const struct ccu ahb2_clk __initconst = {
+	CCU_REG(0x05c),
+	.hw.init = &ahb2_init,
+	CCU_MUX(0, 2),
+	.features = CCU_FEATURE_MUX_FIXED_PREDIV,
+	.extra = &ahb2_extra,
+};
+static const char * const child_ahb2[] __initconst = { ahb2 };
+
+static const char bus_ce[] __initconst = "bus-ce";
+static const struct clk_init_data bus_ce_init __initconst = {
+	CCU_HW(bus_ce, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ce_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ce_init,
+	CCU_GATE(5),
+};
+static const char bus_dma[] __initconst = "bus-dma";
+static const struct clk_init_data bus_dma_init __initconst = {
+	CCU_HW(bus_dma, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_dma_clk __initconst = {
+	CCU_REG(0x060),
+//	CCU_HW(bus_dma", "ahb1", &ccu_periph_ops, 0),
+	.hw.init = &bus_dma_init,
+	CCU_GATE(6),
+};
+static const char bus_mmc0[] __initconst = "bus-mmc0";
+static const struct clk_init_data bus_mmc0_init __initconst = {
+	CCU_HW(bus_mmc0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc0_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc0_init,
+////	CCU_GATE(8),
+};
+static const char bus_mmc1[] __initconst = "bus-mmc1";
+static const struct clk_init_data bus_mmc1_init __initconst = {
+	CCU_HW(bus_mmc1, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc1_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc1_init,
+////	CCU_GATE(9),
+};
+static const char bus_mmc2[] __initconst = "bus-mmc2";
+static const struct clk_init_data bus_mmc2_init __initconst = {
+	CCU_HW(bus_mmc2, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_mmc2_clk __initconst = {
+////	CCU_REG(0x060),
+	.hw.init = &bus_mmc2_init,
+////	CCU_GATE(10),
+};
+static const char bus_nand[] __initconst = "bus-nand";
+static const struct clk_init_data bus_nand_init __initconst = {
+	CCU_HW(bus_nand, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_nand_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_nand_init,
+	CCU_GATE(13),
+};
+static const char bus_dram[] __initconst = "bus-dram";
+static const struct clk_init_data bus_dram_init __initconst = {
+	CCU_HW(bus_dram, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_dram_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_dram_init,
+	CCU_GATE(14),
+};
+static const char bus_emac[] __initconst = "bus-emac";
+static const struct clk_init_data bus_emac_init __initconst = {
+	CCU_HW(bus_emac, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_emac_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_emac_init,
+	CCU_GATE(17),
+};
+static const char bus_ts[] __initconst = "bus-ts";
+static const struct clk_init_data bus_ts_init __initconst = {
+	CCU_HW(bus_ts, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ts_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ts_init,
+	CCU_GATE(18),
+};
+static const char bus_hstimer[] __initconst = "bus-hstimer";
+static const struct clk_init_data bus_hstimer_init __initconst = {
+	CCU_HW(bus_hstimer, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_hstimer_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_hstimer_init,
+	CCU_GATE(19),
+};
+static const char bus_spi0[] __initconst = "bus-spi0";
+static const struct clk_init_data bus_spi0_init __initconst = {
+	CCU_HW(bus_spi0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spi0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_spi0_init,
+	CCU_GATE(20),
+};
+static const char bus_spi1[] __initconst = "bus-spi1";
+static const struct clk_init_data bus_spi1_init __initconst = {
+	CCU_HW(bus_spi1, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spi1_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_spi1_init,
+	CCU_GATE(21),
+};
+static const char bus_otg[] __initconst = "bus-otg";
+static const struct clk_init_data bus_otg_init __initconst = {
+	CCU_HW(bus_otg, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_otg_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_otg_init,
+	CCU_GATE(23),
+};
+static const char bus_ehci0[] __initconst = "bus-ehci0";
+static const struct clk_init_data bus_ehci0_init __initconst = {
+	CCU_HW(bus_ehci0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci0_init,
+	CCU_GATE(24),
+};
+static const char bus_ehci1[] __initconst = "bus-ehci1";
+static const struct clk_init_data bus_ehci1_init __initconst = {
+	CCU_HW(bus_ehci1, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci1_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci1_init,
+	CCU_GATE(25),
+};
+static const char bus_ehci2[] __initconst = "bus-ehci2";
+static const struct clk_init_data bus_ehci2_init __initconst = {
+	CCU_HW(bus_ehci2, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci2_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci2_init,
+	CCU_GATE(26),
+};
+static const char bus_ehci3[] __initconst = "bus-ehci3";
+static const struct clk_init_data bus_ehci3_init __initconst = {
+	CCU_HW(bus_ehci3, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ehci3_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ehci3_init,
+	CCU_GATE(27),
+};
+static const char bus_ohci0[] __initconst = "bus-ohci0";
+static const struct clk_init_data bus_ohci0_init __initconst = {
+	CCU_HW(bus_ohci0, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ohci0_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ohci0_init,
+	CCU_GATE(28),
+};
+static const char bus_ohci1[] __initconst = "bus-ohci1";
+static const struct clk_init_data bus_ohci1_init __initconst = {
+	CCU_HW(bus_ohci1, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ohci1_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ohci1_init,
+	CCU_GATE(29),
+};
+static const char bus_ohci2[] __initconst = "bus-ohci2";
+static const struct clk_init_data bus_ohci2_init __initconst = {
+	CCU_HW(bus_ohci2, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ohci2_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ohci2_init,
+	CCU_GATE(30),
+};
+static const char bus_ohci3[] __initconst = "bus-ohci3";
+static const struct clk_init_data bus_ohci3_init __initconst = {
+	CCU_HW(bus_ohci3, child_ahb2, &ccu_periph_ops),
+};
+static const struct ccu bus_ohci3_clk __initconst = {
+	CCU_REG(0x060),
+	.hw.init = &bus_ohci3_init,
+	CCU_GATE(31),
+};
+
+static const char bus_ve[] __initconst = "bus-ve";
+static const struct clk_init_data bus_ve_init __initconst = {
+	CCU_HW(bus_ve, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ve_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_ve_init,
+	CCU_GATE(0),
+};
+static const char bus_deinterlace[] __initconst = "bus-deinterlace";
+static const struct clk_init_data bus_deinterlace_init __initconst = {
+	CCU_HW(bus_deinterlace, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_deinterlace_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_deinterlace_init,
+	CCU_GATE(5),
+};
+static const char bus_csi[] __initconst = "bus-csi";
+static const struct clk_init_data bus_csi_init __initconst = {
+	CCU_HW(bus_csi, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_csi_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_csi_init,
+	CCU_GATE(8),
+};
+static const char bus_tve[] __initconst = "bus-tve";
+static const struct clk_init_data bus_tve_init __initconst = {
+	CCU_HW(bus_tve, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_tve_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_tve_init,
+	CCU_GATE(9),
+};
+static const char bus_gpu[] __initconst = "bus-gpu";
+static const struct clk_init_data bus_gpu_init __initconst = {
+	CCU_HW(bus_gpu, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_gpu_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_gpu_init,
+	CCU_GATE(20),
+};
+static const char bus_msgbox[] __initconst = "bus-msgbox";
+static const struct clk_init_data bus_msgbox_init __initconst = {
+	CCU_HW(bus_msgbox, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_msgbox_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_msgbox_init,
+	CCU_GATE(21),
+};
+static const char bus_spinlock[] __initconst = "bus-spinlock";
+static const struct clk_init_data bus_spinlock_init __initconst = {
+	CCU_HW(bus_spinlock, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spinlock_clk __initconst = {
+	CCU_REG(0x064),
+	.hw.init = &bus_spinlock_init,
+	CCU_GATE(22),
+};
+
+static const char bus_codec[] __initconst = "bus-codec";
+static const struct clk_init_data bus_codec_init __initconst = {
+	CCU_HW(bus_codec, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_codec_clk __initconst = {
+	CCU_REG(0x068),
+	.hw.init = &bus_codec_init,
+	CCU_GATE(0),
+};
+static const char bus_spdif[] __initconst = "bus-spdif";
+static const struct clk_init_data bus_spdif_init __initconst = {
+	CCU_HW(bus_spdif, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_spdif_clk __initconst = {
+	CCU_REG(0x068),
+	.hw.init = &bus_spdif_init,
+	CCU_GATE(1),
+};
+static const char bus_pio[] __initconst = "bus-pio";
+static const struct clk_init_data bus_pio_init __initconst = {
+	CCU_HW(bus_pio, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_pio_clk __initconst = {
+	CCU_REG(0x068),
+	.hw.init = &bus_pio_init,
+	CCU_GATE(5),
+};
+//static const char bus_ths[] __initconst = "bus-ths";
+//static const struct clk_init_data bus_ths_init __initconst = {
+//	CCU_HW(bus_ths, child_apb1, &ccu_periph_ops),
+//};
+//static const struct ccu bus_ths_clk __initconst = {
+//	CCU_REG(0x068),
+//	.hw.init = &bus_ths_init,
+//	CCU_GATE(8),
+//};
+
+static const char bus_i2c0[] __initconst = "bus-i2c0";
+static const struct clk_init_data bus_i2c0_init __initconst = {
+	CCU_HW(bus_i2c0, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c0_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c0_init,
+	CCU_GATE(0),
+};
+static const char bus_i2c1[] __initconst = "bus-i2c1";
+static const struct clk_init_data bus_i2c1_init __initconst = {
+	CCU_HW(bus_i2c1, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c1_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c1_init,
+	CCU_GATE(1),
+};
+static const char bus_i2c2[] __initconst = "bus-i2c2";
+static const struct clk_init_data bus_i2c2_init __initconst = {
+	CCU_HW(bus_i2c2, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_i2c2_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_i2c2_init,
+	CCU_GATE(2),
+};
+static const char bus_uart0[] __initconst = "bus-uart0";
+static const struct clk_init_data bus_uart0_init __initconst = {
+	CCU_HW(bus_uart0, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart0_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart0_init,
+	CCU_GATE(16),
+};
+static const char bus_uart1[] __initconst = "bus-uart1";
+static const struct clk_init_data bus_uart1_init __initconst = {
+	CCU_HW(bus_uart1, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart1_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart1_init,
+	CCU_GATE(17),
+};
+static const char bus_uart2[] __initconst = "bus-uart2";
+static const struct clk_init_data bus_uart2_init __initconst = {
+	CCU_HW(bus_uart2, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart2_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart2_init,
+	CCU_GATE(18),
+};
+static const char bus_uart3[] __initconst = "bus-uart3";
+static const struct clk_init_data bus_uart3_init __initconst = {
+	CCU_HW(bus_uart3, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_uart3_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_uart3_init,
+	CCU_GATE(19),
+};
+static const char bus_scr[] __initconst = "bus-scr";
+static const struct clk_init_data bus_scr_init __initconst = {
+	CCU_HW(bus_scr, child_apb2, &ccu_periph_ops),
+};
+static const struct ccu bus_scr_clk __initconst = {
+	CCU_REG(0x06c),
+	.hw.init = &bus_scr_init,
+	CCU_GATE(20),
+};
+
+static const char bus_ephy[] __initconst = "bus-ephy";
+static const struct clk_init_data bus_ephy_init __initconst = {
+	CCU_HW(bus_ephy, child_apb1, &ccu_periph_ops),
+};
+static const struct ccu bus_ephy_clk __initconst = {
+	CCU_REG(0x070),
+	.hw.init = &bus_ephy_init,
+	CCU_GATE(0),
+};
+static const char bus_dbg[] __initconst = "bus-dbg";
+static const struct clk_init_data bus_dbg_init __initconst = {
+	CCU_HW(bus_dbg, child_ahb1, &ccu_periph_ops),
+};
+static const struct ccu bus_dbg_clk __initconst = {
+	CCU_REG(0x070),
+	.hw.init = &bus_dbg_init,
+	CCU_GATE(7),
+};
+
+static const char ths[] __initconst = "ths";
+static const struct ccu_extra ths_extra = {
+	.m_table = { 1, 2, 4, 6 },
+};
+static const struct clk_init_data ths_init __initconst = {
+	CCU_HW(ths, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ths_clk __initconst = {
+	CCU_REG(0x074),
+	.hw.init = &ths_init,
+	CCU_MUX(24, 2),
+	CCU_BUS(0x068, 8),
+	CCU_GATE(31),
+	CCU_M(0, 2),
+	.features = CCU_FEATURE_M_TABLE,
+	.extra = &ths_extra,
+};
+
+static const char nand[] __initconst = "nand";
+static const char * const mmc_parents[] __initconst = {
+				hosc, pll_periph0, pll_periph1
+};
+static const struct clk_init_data nand_init __initconst = {
+	CCU_HW(nand, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu nand_clk __initconst = {
+	CCU_REG(0x080),
+	.hw.init = &nand_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char mmc0[] __initconst = "mmc0";
+static const struct clk_init_data mmc0_init __initconst = {
+	CCU_HW(mmc0, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc0_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 8),
+	CCU_BUS(0x060, 8),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE,
+};
+static const char * const child_mmc0[] __initconst = { mmc0 };
+static const char mmc0_sample[] __initconst = "mmc0-sample";
+static const struct clk_init_data mmc0_sample_init __initconst = {
+	CCU_HW(mmc0_sample, child_mmc0, &ccu_phase_ops),
+};
+static const struct ccu mmc0_sample_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_sample_init,
+	CCU_PHASE(20, 3),
+};
+static const char mmc0_output[] __initconst = "mmc0-output";
+static const struct clk_init_data mmc0_output_init __initconst = {
+	CCU_HW(mmc0_output, child_mmc0, &ccu_phase_ops),
+};
+static const struct ccu mmc0_output_clk __initconst = {
+	CCU_REG(0x088),
+	.hw.init = &mmc0_output_init,
+	CCU_PHASE(8, 3),
+};
+
+static const char mmc1[] __initconst = "mmc1";
+static const struct ccu_extra mmc_extra = {
+	.mode_select.rate = 50000000,
+	.mode_select.bit = 30,
+};
+static const struct clk_init_data mmc1_init __initconst = {
+	CCU_HW(mmc1, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc1_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 9),
+	CCU_BUS(0x060, 9),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char * const child_mmc1[] __initconst = { mmc1 };
+static const char mmc1_sample[] __initconst = "mmc1-sample";
+static const struct clk_init_data mmc1_sample_init __initconst = {
+	CCU_HW(mmc1_sample, child_mmc1, &ccu_phase_ops),
+};
+static const struct ccu mmc1_sample_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_sample_init,
+	CCU_PHASE(20, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char mmc1_output[] __initconst = "mmc1-output";
+static const struct clk_init_data mmc1_output_init __initconst = {
+	CCU_HW(mmc1_output, child_mmc1, &ccu_phase_ops),
+};
+static const struct ccu mmc1_output_clk __initconst = {
+	CCU_REG(0x08c),
+	.hw.init = &mmc1_output_init,
+	CCU_PHASE(8, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+
+static const char mmc2[] __initconst = "mmc2";
+static const struct clk_init_data mmc2_init __initconst = {
+	CCU_HW(mmc2, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu mmc2_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_init,
+	CCU_MUX(24, 2),
+	CCU_RESET(0x2c0, 10),
+	CCU_BUS(0x060, 10),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+	.features = CCU_FEATURE_SET_RATE_GATE |
+			CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char * const child_mmc2[] __initconst = { "mmc2" };
+static const char mmc2_sample[] __initconst = "mmc2-sample";
+static const struct clk_init_data mmc2_sample_init __initconst = {
+	CCU_HW(mmc2_sample, child_mmc2, &ccu_phase_ops),
+};
+static const struct ccu mmc2_sample_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_sample_init,
+	CCU_PHASE(20, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+static const char mmc2_output[] __initconst = "mmc2-output";
+static const struct clk_init_data mmc2_output_init __initconst = {
+	CCU_HW(mmc2_output, child_mmc2, &ccu_phase_ops),
+};
+static const struct ccu mmc2_output_clk __initconst = {
+	CCU_REG(0x090),
+	.hw.init = &mmc2_output_init,
+	CCU_PHASE(8, 3),
+	.features = CCU_FEATURE_MODE_SELECT,
+	.extra = &mmc_extra,
+};
+
+static const char ts[] __initconst = "ts";
+static const char * const ts_parents[] __initconst = { hosc, pll_periph0 };
+static const struct clk_init_data ts_init __initconst = {
+	CCU_HW(ts, ts_parents, &ccu_periph_ops),
+};
+static const struct ccu ts_clk __initconst = {
+	CCU_REG(0x098),
+	.hw.init = &ts_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char ce[] __initconst = "ce";
+static const struct clk_init_data ce_init __initconst = {
+	CCU_HW(ce, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu ce_clk __initconst = {
+	CCU_REG(0x09c),
+	.hw.init = &ce_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char spi0[] __initconst = "spi0";
+static const struct clk_init_data spi0_init __initconst = {
+	CCU_HW(spi0, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu spi0_clk __initconst = {
+	CCU_REG(0x0a0),
+	.hw.init = &spi0_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char spi1[] __initconst = "spi1";
+static const struct clk_init_data spi1_init __initconst = {
+	CCU_HW(spi1, mmc_parents, &ccu_periph_ops),
+};
+static const struct ccu spi1_clk __initconst = {
+	CCU_REG(0x0a4),
+	.hw.init = &spi1_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+static const char i2s0[] __initconst = "i2s0";
+static const char * const i2s_parents[] __initconst = {
+		pll_audio_8x, pll_audio_4x, pll_audio_2x, pll_audio
+};
+static const struct clk_init_data i2s0_init __initconst = {
+	CCU_HW(i2s0, i2s_parents, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s0_clk __initconst = {
+	CCU_REG(0x0b0),
+	.hw.init = &i2s0_init,
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 12),
+	CCU_GATE(31),
+};
+static const char i2s1[] __initconst = "i2s1";
+static const struct clk_init_data i2s1_init __initconst = {
+	CCU_HW(i2s1, i2s_parents, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s1_clk __initconst = {
+	CCU_REG(0x0b4),
+	.hw.init = &i2s1_init,
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 13),
+	CCU_GATE(31),
+};
+
+static const char i2s2[] __initconst = "i2s2";
+static const struct clk_init_data i2s2_init __initconst = {
+	CCU_HW(i2s2, i2s_parents, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu i2s2_clk __initconst = {
+	CCU_REG(0x0b8),
+	.hw.init = &i2s2_init,
+	CCU_MUX(16, 2),
+	CCU_BUS(0x068, 14),
+	CCU_GATE(31),
+};
+
+static const char spdif[] __initconst = "spdif";
+static const struct clk_init_data spdif_init __initconst = {
+	CCU_HW(spdif, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu spdif_clk __initconst = {
+	CCU_REG(0x0c0),
+	.hw.init = &spdif_init,
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char usb_phy0[] __initconst = "usb-phy0";
+static const struct clk_init_data usb_phy0_init __initconst = {
+	CCU_HW(usb_phy0, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy0_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy0_init,
+	CCU_GATE(8),
+};
+
+static const char usb_phy1[] __initconst = "usb-phy1";
+static const struct clk_init_data usb_phy1_init __initconst = {
+	CCU_HW(usb_phy1, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy1_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy1_init,
+	CCU_GATE(9),
+};
+
+static const char usb_phy2[] __initconst = "usb-phy2";
+static const struct clk_init_data usb_phy2_init __initconst = {
+	CCU_HW(usb_phy2, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy2_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy2_init,
+	CCU_GATE(10),
+};
+
+static const char usb_phy3[] __initconst = "usb-phy3";
+static const struct clk_init_data usb_phy3_init __initconst = {
+	CCU_HW(usb_phy3, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu usb_phy3_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &usb_phy3_init,
+	CCU_GATE(11),
+};
+
+static const char ohci0[] __initconst = "ohci0";
+static const struct clk_init_data ohci0_init __initconst = {
+	CCU_HW(ohci0, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ohci0_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &ohci0_init,
+	CCU_GATE(16),
+};
+
+static const char ohci1[] __initconst = "ohci1";
+static const struct clk_init_data ohci1_init __initconst = {
+	CCU_HW(ohci1, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ohci1_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &ohci1_init,
+	CCU_GATE(17),
+};
+
+static const char ohci2[] __initconst = "ohci2";
+static const struct clk_init_data ohci2_init __initconst = {
+	CCU_HW(ohci2, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ohci2_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &ohci2_init,
+	CCU_GATE(18),
+};
+
+static const char ohci3[] __initconst = "ohci3";
+static const struct clk_init_data ohci3_init __initconst = {
+	CCU_HW(ohci3, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu ohci3_clk __initconst = {
+	CCU_REG(0x0cc),
+	.hw.init = &ohci3_init,
+	CCU_GATE(19),
+};
+
+static const char dram[] __initconst = "dram";
+static const struct clk_init_data dram_init __initconst = {
+	CCU_HW(dram, child_pll_ddr, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu dram_clk __initconst = {
+	CCU_REG(0x0f4),
+	.hw.init = &dram_init,
+	CCU_MUX(20, 2),
+	CCU_M(0, 4),
+	CCU_UPD(16),
+};
+static const char * const child_dram[] __initconst = { dram };
+
+static const char dram_ve[] __initconst = "dram-ve";
+static const struct clk_init_data dram_ve_init __initconst = {
+	CCU_HW(dram_ve, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_ve_clk __initconst = {
+	CCU_REG(0x0100),
+	.hw.init = &dram_ve_init,
+	CCU_GATE(0),
+};
+
+static const char dram_csi[] __initconst = "dram-csi";
+static const struct clk_init_data dram_csi_init __initconst = {
+	CCU_HW(dram_csi, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_csi_clk __initconst = {
+	CCU_REG(0x100),
+	.hw.init = &dram_csi_init,
+	CCU_GATE(1),
+};
+
+static const char dram_deinterlace[] __initconst = "dram-deinterlace";
+static const struct clk_init_data dram_deinterlace_init __initconst = {
+	CCU_HW(dram_deinterlace, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_deinterlace_clk __initconst = {
+	CCU_REG(0x0100),
+	.hw.init = &dram_deinterlace_init,
+	CCU_GATE(2),
+};
+
+static const char dram_ts[] __initconst = "dram-ts";
+static const struct clk_init_data dram_ts_init __initconst = {
+	CCU_HW(dram_ts, child_dram, &ccu_periph_ops),
+};
+static const struct ccu dram_ts_clk __initconst = {
+	CCU_REG(0x0100),
+	.hw.init = &dram_ts_init,
+	CCU_GATE(3),
+};
+
+static const char * const de_parents[] __initconst = {
+				pll_periph0_2x, pll_de
+};
+static const char de[] __initconst = "de";
+static const struct clk_init_data de_init __initconst = {
+	CCU_HW(de, de_parents, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu de_clk __initconst = {
+	CCU_REG(0x104),
+	.hw.init = &de_init,
+	CCU_MUX(24, 3),
+	CCU_RESET(0x2c4, 12),
+	CCU_BUS(0x064, 12),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char tcon0[] __initconst = "tcon0";
+static const struct clk_init_data tcon0_init __initconst = {
+	CCU_HW(tcon0, child_pll_video, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu tcon0_clk __initconst = {
+	CCU_REG(0x118),
+	.hw.init = &tcon0_init,
+	CCU_MUX(24, 3),
+	CCU_RESET(0x2c4, 3),
+	CCU_BUS(0x064, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char tve[] __initconst = "tve";
+static const char * const tve_parents[] __initconst = {
+				pll_de, pll_periph1
+};
+static const struct clk_init_data tve_init __initconst = {
+	CCU_HW(tve, tve_parents, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu tve_clk __initconst = {
+	CCU_REG(0x120),
+	.hw.init = &tve_init,
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char deinterlace[] __initconst = "deinterlace";
+static const char * const ph0_ph1[] __initconst = { pll_periph0, pll_periph1 };
+static const struct clk_init_data deinterlace_init __initconst = {
+	CCU_HW(deinterlace, ph0_ph1, &ccu_periph_ops),
+};
+static const struct ccu deinterlace_clk __initconst = {
+	CCU_REG(0x124),
+	.hw.init = &deinterlace_init,
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+};
+
+static const char csi_misc[] __initconst = "csi-misc";
+static const struct clk_init_data csi_misc_init __initconst = {
+	CCU_HW(csi_misc, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu csi_misc_clk __initconst = {
+	CCU_REG(0x0130),
+	.hw.init = &csi_misc_init,
+	CCU_GATE(16),
+};
+
+static const char csi_sclk[] __initconst = "csi-sclk";
+static const struct clk_init_data csi_sclk_init __initconst = {
+	CCU_HW(csi_sclk, ph0_ph1, &ccu_periph_ops),
+};
+static const struct ccu csi_sclk_clk __initconst = {
+	CCU_REG(0x134),
+	.hw.init = &csi_sclk_init,
+	CCU_MUX(24, 3),
+	CCU_GATE(31),
+	CCU_M(16, 4),
+};
+
+static const char csi_mclk[] __initconst = "csi-mclk";
+static const char * const csi_mclk_parents[] __initconst = {
+				hosc, pll_video, pll_periph0
+};
+static const struct clk_init_data csi_mclk_init __initconst = {
+	CCU_HW(csi_mclk, csi_mclk_parents, &ccu_periph_ops),
+};
+static const struct ccu csi_mclk_clk __initconst = {
+	CCU_REG(0x134),
+	.hw.init = &csi_mclk_init,
+	CCU_MUX(8, 3),
+	CCU_GATE(15),
+	CCU_M(0, 5),
+};
+
+static const char ve[] __initconst = "ve";
+static const struct clk_init_data ve_init __initconst = {
+	CCU_HW(ve, child_pll_ve, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu ve_clk __initconst = {
+	CCU_REG(0x13c),
+	.hw.init = &ve_init,
+	CCU_GATE(31),
+	CCU_M(16, 3),
+};
+
+static const char ac_dig[] __initconst = "ac-dig";
+static const struct clk_init_data ac_dig_init __initconst = {
+	CCU_HW(ac_dig, child_pll_audio, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu ac_dig_clk __initconst = {
+	CCU_REG(0x0140),
+	.hw.init = &ac_dig_init,
+	CCU_GATE(31),
+};
+
+static const char avs[] __initconst = "avs";
+static const struct clk_init_data avs_init __initconst = {
+	CCU_HW(avs, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu avs_clk __initconst = {
+	CCU_REG(0x0144),
+	.hw.init = &avs_init,
+	CCU_GATE(31),
+};
+
+static const char hdmi[] __initconst = "hdmi";
+static const struct clk_init_data hdmi_init __initconst = {
+	CCU_HW(hdmi, child_pll_video, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu hdmi_clk __initconst = {
+	CCU_REG(0x150),
+	.hw.init = &hdmi_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_BUS(0x064, 11),
+	CCU_M(0, 4),
+};
+
+static const char hdmi_ddc[] __initconst = "hdmi-ddc";
+static const struct clk_init_data hdmi_ddc_init __initconst = {
+	CCU_HW(hdmi_ddc, child_hosc, &ccu_periph_ops),
+};
+static const struct ccu hdmi_ddc_clk __initconst = {
+	CCU_REG(0x0154),
+	.hw.init = &hdmi_ddc_init,
+	CCU_GATE(31),
+};
+
+static const char mbus[] __initconst = "mbus";
+static const char * const mbus_parents[] __initconst = {
+				hosc, pll_periph0_2x, pll_ddr
+};
+static const struct clk_init_data mbus_init __initconst = {
+	CCU_HW(mbus, mbus_parents, &ccu_periph_ops),
+	.flags = CLK_IS_CRITICAL,
+};
+static const struct ccu mbus_clk __initconst = {
+	CCU_REG(0x15c),
+	.hw.init = &mbus_init,
+	CCU_GATE(31),
+	CCU_MUX(24, 2),
+	CCU_M(0, 3),
+};
+
+static const char gpu[] __initconst = "gpu";
+static const struct clk_init_data gpu_init __initconst = {
+	CCU_HW(gpu, child_pll_gpu, &ccu_periph_ops),
+	.flags = CLK_SET_RATE_PARENT,
+};
+static const struct ccu gpu_clk __initconst = {
+	CCU_REG(0x1a0),
+	.hw.init = &gpu_init,
+	CCU_GATE(31),
+	CCU_M(0, 3),
+};
+
+/* ---- PRCM ---- */
+static const char * const cpus_parents[] __initconst = {
+			losc, hosc, pll_periph0, ""	/* ?? */
+};
+//fixme: postdiv, not prediv...
+static const char cpus[] __initconst = "cpus";
+static const struct ccu_extra cpus_extra = {
+	.variable_prediv = { .index = 2, .shift = 8, .width = 4 },
+};
+static const struct clk_init_data cpus_init __initconst = {
+	CCU_HW(cpus, cpus_parents, &ccu_periph_ops),
+};
+static const struct ccu cpus_clk __initconst = {	/* = ahb0 */
+	CCU_REG1(0x000),
+	.hw.init = &cpus_init,
+	CCU_MUX(16, 2),
+	CCU_P(4, 2),
+	.features = CCU_FEATURE_MUX_VARIABLE_PREDIV,
+	.extra = &cpus_extra,
+};
+static const char * const child_cpus[] __initconst = { cpus };
+
+static const char apb0[] __initconst = "apb0";
+
+static const struct clk_init_data apb0_init __initconst = {
+	CCU_HW(apb0, child_cpus, &ccu_periph_ops),
+};
+static const struct ccu apb0_clk __initconst = {
+	CCU_REG1(0x00c),
+	.hw.init = &apb0_init,
+	CCU_M(0, 2),
+};
+static const char * const child_apb0[] __initconst = { apb0 };
+
+static const char bus_r_pio[] __initconst = "bus-r_pio";
+static const struct clk_init_data bus_r_pio_init __initconst = {
+	CCU_HW(bus_r_pio, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_pio_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_pio_init,
+	CCU_GATE(0),
+};
+static const char bus_r_cir[] __initconst = "bus-r_cir";
+static const struct clk_init_data bus_r_cir_init __initconst = {
+	CCU_HW(bus_r_cir, child_apb0, &ccu_periph_ops),
+};
+static const struct ccu bus_r_cir_clk __initconst = {
+	CCU_REG1(0x028),
+	.hw.init = &bus_r_cir_init,
+	CCU_GATE(1),
+};
+
+static const char * const r_cir_parents[] __initconst = { losc, hosc };
+static const char r_cir[] __initconst = "r_cir";
+static const struct clk_init_data r_cir_init __initconst = {
+	CCU_HW(r_cir, r_cir_parents, &ccu_periph_ops),
+};
+static const struct ccu r_cir_clk __initconst = {
+	CCU_REG1(0x054),
+	.hw.init = &r_cir_init,
+	CCU_MUX(24, 2),
+	CCU_GATE(31),
+	CCU_M(0, 4),
+	CCU_P(16, 2),
+};
+
+/* system clocks and resets */
+static const struct ccu * const sun8i_h3_ccu_clks[] __initconst = {
+	[CLK_BUS_DMA]		= &bus_dma_clk,
+	[CLK_BUS_EHCI0]		= &bus_ehci0_clk,
+	[CLK_BUS_EHCI1]		= &bus_ehci1_clk,
+	[CLK_BUS_EHCI2]		= &bus_ehci2_clk,
+	[CLK_BUS_EHCI3]		= &bus_ehci3_clk,
+	[CLK_BUS_MMC0]		= &bus_mmc0_clk,
+	[CLK_BUS_MMC1]		= &bus_mmc1_clk,
+	[CLK_BUS_MMC2]		= &bus_mmc2_clk,
+	[CLK_BUS_OHCI0]		= &bus_ohci0_clk,
+	[CLK_BUS_OHCI1]		= &bus_ohci1_clk,
+	[CLK_BUS_OHCI2]		= &bus_ohci2_clk,
+	[CLK_BUS_OHCI3]		= &bus_ohci3_clk,
+	[CLK_BUS_PIO]		= &bus_pio_clk,
+	[CLK_BUS_UART0]		= &bus_uart0_clk,
+	[CLK_BUS_UART1]		= &bus_uart1_clk,
+	[CLK_BUS_UART2]		= &bus_uart2_clk,
+	[CLK_BUS_UART3]		= &bus_uart3_clk,
+	[CLK_DE]		= &de_clk,
+	[CLK_HDMI]		= &hdmi_clk,
+	[CLK_HDMI_DDC]		= &hdmi_ddc_clk,
+	[CLK_I2S0]		= &i2s0_clk,
+	[CLK_I2S1]		= &i2s1_clk,
+	[CLK_I2S2]		= &i2s2_clk,
+	[CLK_MMC0]		= &mmc0_clk,
+	[CLK_MMC0_SAMPLE]	= &mmc0_sample_clk,
+	[CLK_MMC0_OUTPUT]	= &mmc0_output_clk,
+	[CLK_MMC1]		= &mmc1_clk,
+	[CLK_MMC1_SAMPLE]	= &mmc1_sample_clk,
+	[CLK_MMC1_OUTPUT]	= &mmc1_output_clk,
+	[CLK_MMC2]		= &mmc2_clk,
+	[CLK_MMC2_SAMPLE]	= &mmc2_sample_clk,
+	[CLK_MMC2_OUTPUT]	= &mmc2_output_clk,
+	[CLK_PLL_AUDIO]		= &pll_audio_clk,
+	[CLK_PLL_DE]		= &pll_de_clk,
+	[CLK_PLL_GPU]		= &pll_gpu_clk,
+	[CLK_PLL_PERIPH0]	= &pll_periph0_clk,
+	[CLK_PLL_PERIPH1]	= &pll_periph1_clk,
+	[CLK_PLL_VE]		= &pll_ve_clk,
+	[CLK_PLL_VIDEO]		= &pll_video_clk,
+	[CLK_SPDIF]		= &spdif_clk,
+	[CLK_SPI0]		= &spi0_clk,
+	[CLK_SPI1]		= &spi1_clk,
+	[CLK_TCON0]		= &tcon0_clk,
+	[CLK_THS]		= &ths_clk,
+	[CLK_TVE]		= &tve_clk,
+	[CLK_USB_OHCI0]		= &ohci0_clk,
+	[CLK_USB_OHCI1]		= &ohci1_clk,
+	[CLK_USB_OHCI2]		= &ohci2_clk,
+	[CLK_USB_OHCI3]		= &ohci3_clk,
+	[CLK_USB_PHY0]		= &usb_phy0_clk,
+	[CLK_USB_PHY1]		= &usb_phy1_clk,
+	[CLK_USB_PHY2]		= &usb_phy2_clk,
+	[CLK_USB_PHY3]		= &usb_phy3_clk,
+	[CLK_VE]		= &ve_clk,
+	[CLK_BUS_R_PIO]		= &bus_r_pio_clk,
+	[CLK_BUS_R_CIR]		= &bus_r_cir_clk,
+	[CLK_R_CIR]		= &r_cir_clk,
+	[CLK_PLL_CPUX]		= &pll_cpux_clk,
+	[CLK_BUS_EMAC]		= &bus_emac_clk,
+	[CLK_BUS_EPHY]		= &bus_ephy_clk,
+	[CLK_BUS_I2C0]		= &bus_i2c0_clk,
+	[CLK_BUS_I2C1]		= &bus_i2c1_clk,
+	[CLK_BUS_I2C2]		= &bus_i2c2_clk,
+	&pll_audio_2x_clk,
+	&pll_audio_4x_clk,
+	&pll_audio_8x_clk,
+	&pll_periph0_2x_clk,
+	&pll_ddr_clk,
+	&cpux_clk,
+	&axi_clk,
+	&ahb1_clk,
+	&apb1_clk,
+	&apb2_clk,
+	&ahb2_clk,
+	&bus_ce_clk,
+	&bus_nand_clk,
+	&bus_dram_clk,
+	&bus_ts_clk,
+	&bus_hstimer_clk,
+	&bus_spi0_clk,
+	&bus_spi1_clk,
+	&bus_otg_clk,
+	&bus_ve_clk,
+	&bus_deinterlace_clk,
+	&bus_csi_clk,
+	&bus_tve_clk,
+	&bus_gpu_clk,
+	&bus_msgbox_clk,
+	&bus_spinlock_clk,
+	&bus_codec_clk,
+	&bus_spdif_clk,
+	&bus_scr_clk,
+	&bus_dbg_clk,
+	&nand_clk,
+	&ts_clk,
+	&ce_clk,
+	&dram_clk,
+	&dram_ve_clk,
+	&dram_csi_clk,
+	&dram_deinterlace_clk,
+	&dram_ts_clk,
+	&deinterlace_clk,
+	&csi_misc_clk,
+	&csi_sclk_clk,
+	&csi_mclk_clk,
+	&ac_dig_clk,
+	&avs_clk,
+	&mbus_clk,
+	&gpu_clk,
+	&cpus_clk,
+	&apb0_clk,
+};
+
+static const struct ccu_reset_map sun8i_h3_ccu_resets[] __initconst = {
+	[RST_USB_PHY0]	= { 0x0cc, 0 },
+	[RST_USB_PHY1]	= { 0x0cc, 1 },
+	[RST_USB_PHY2]	= { 0x0cc, 2 },
+	[RST_USB_PHY3]	= { 0x0cc, 3 },
+
+	[RST_MBUS]	= { 0x0fc, 31 },
+
+	[RST_BUS_CE]	= { 0x2c0, 5 },
+	[RST_BUS_DMA]	= { 0x2c0, 6 },
+//	[RST_BUS_MMC0]	= { 0x2c0, 8 },
+//	[RST_BUS_MMC1]	= { 0x2c0, 9 },
+//	[RST_BUS_MMC2]	= { 0x2c0, 10 },
+//	[RST_BUS_DE]	= { 0x2c0, 12 },
+	[RST_BUS_NAND]	= { 0x2c0, 13 },
+	[RST_BUS_DRAM]	= { 0x2c0, 14 },
+	[RST_BUS_EMAC]	= { 0x2c0, 17 },
+	[RST_BUS_TS]	= { 0x2c0, 18 },
+	[RST_BUS_HSTIMER]	= { 0x2c0, 19 },
+	[RST_BUS_SPI0]	= { 0x2c0, 20 },
+	[RST_BUS_SPI1]	= { 0x2c0, 21 },
+	[RST_BUS_OTG]	= { 0x2c0, 23 },
+	[RST_BUS_EHCI0]	= { 0x2c0, 24 },
+	[RST_BUS_EHCI1]	= { 0x2c0, 25 },
+	[RST_BUS_EHCI2]	= { 0x2c0, 26 },
+	[RST_BUS_EHCI3]	= { 0x2c0, 27 },
+	[RST_BUS_OHCI0]	= { 0x2c0, 28 },
+	[RST_BUS_OHCI1]	= { 0x2c0, 29 },
+	[RST_BUS_OHCI2]	= { 0x2c0, 30 },
+	[RST_BUS_OHCI3]	= { 0x2c0, 31 },
+
+	[RST_BUS_VE]	= { 0x2c4, 0 },
+//	[RST_BUS_TCON0]	= { 0x2c4, 3 },
+//	[RST_BUS_TCON1]	= { 0x2c4, 4 },
+	[RST_BUS_DEINTERLACE] = { 0x2c4, 5 },
+	[RST_BUS_CSI]	= { 0x2c4, 8 },
+	[RST_BUS_TVE]	= { 0x2c4, 9 },
+	[RST_BUS_HDMI0]	= { 0x2c4, 10 },
+	[RST_BUS_HDMI1]	= { 0x2c4, 11 },
+	[RST_BUS_GPU]	= { 0x2c4, 20 },
+	[RST_BUS_MSGBOX]	= { 0x2c4, 21 },
+	[RST_BUS_SPINLOCK]	= { 0x2c4, 22 },
+	[RST_BUS_DBG]	= { 0x2c4, 31 },
+
+	[RST_BUS_EPHY]	= { 0x2c8, 2 },
+
+	[RST_BUS_CODEC]	= { 0x2d0, 0 },
+	[RST_BUS_SPDIF]	= { 0x2d0, 1 },
+	[RST_BUS_THS]	= { 0x2d0, 8 },
+	[RST_BUS_I2S0]	= { 0x2d0, 12 },
+	[RST_BUS_I2S1]	= { 0x2d0, 13 },
+	[RST_BUS_I2S2]	= { 0x2d0, 14 },
+
+	[RST_BUS_I2C0]	= { 0x2d8, 0 },
+	[RST_BUS_I2C1]	= { 0x2d8, 1 },
+	[RST_BUS_I2C2]	= { 0x2d8, 2 },
+	[RST_BUS_UART0]	= { 0x2d8, 16 },
+	[RST_BUS_UART1]	= { 0x2d8, 17 },
+	[RST_BUS_UART2]	= { 0x2d8, 18 },
+	[RST_BUS_UART3]	= { 0x2d8, 19 },
+	[RST_BUS_SCR]	= { 0x2d8, 20 },
+
+	[RST_R_PIO]	= { 0x0b0, 0, 1 },
+	[RST_R_CIR]	= { 0x0b0, 1, 1 },
+};
+
+static void __init sun8i_h3_ccu_setup(struct device_node *node)
+{
+	ccu_probe(node, sun8i_h3_ccu_clks,
+			ARRAY_SIZE(sun8i_h3_ccu_clks),
+			sun8i_h3_ccu_resets,
+			ARRAY_SIZE(sun8i_h3_ccu_resets));
+}
+CLK_OF_DECLARE(sun8i_h3_ccu, "allwinner,sun8i-h3-ccu",
+	       sun8i_h3_ccu_setup);
diff --git a/drivers/clk/sunxi/ccu.c b/drivers/clk/sunxi/ccu.c
new file mode 100644
index 0000000..186e616
--- /dev/null
+++ b/drivers/clk/sunxi/ccu.c
@@ -0,0 +1,1145 @@
+/*
+ * Allwinner system CCU
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Rewrite from 'sunxi-ng':
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ * and sun8i SDK
+ * Copyright (C) 2013 Allwinnertech, kevin.z.m <kevin@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/reset-controller.h>
+#include <linux/iopoll.h>
+#include <linux/slab.h>
+#include <linux/rational.h>
+#include <linux/of_address.h>
+
+#include "ccu.h"
+
+#define CCU_DEBUG 0
+
+#if CCU_DEBUG
+#define ccu_dbg(fmt, ...) pr_info("*ccu* " fmt, ##__VA_ARGS__)
+#else
+#define ccu_dbg(fmt, ...)
+#endif
+
+#define CCU_MASK(shift, width) (((1 << width) - 1) << shift)
+
+/*
+ * factors:
+ *	n: multiplier (PLL)
+ *	d1, d2: boolean dividers by 2 (d2 is p with 1 bit width - PLL)
+ *	k: multiplier (PLL)
+ *	m: divider
+ *	p: (pre-)divider by power of 2
+ */
+struct val_pll {
+	int n, d1, k, m, p;
+};
+struct val_periph {
+	int m, p;
+};
+
+static void __iomem *bases[2];		/* CCU = 0, PRCM = 1 */
+static DEFINE_SPINLOCK(ccu_lock);
+
+static inline struct ccu *hw2ccu(struct clk_hw *hw)
+{
+	return container_of(hw, struct ccu, hw);
+}
+
+static void ccu_set_field(struct ccu *ccu, int reg, u32 mask, u32 val)
+{
+	void __iomem *rega = bases[ccu->index] + reg;
+
+	ccu_dbg("%s set %03x %08x\n",
+		clk_hw_get_name(&ccu->hw), reg,
+		(readl(rega) & ~mask) | val);
+
+	spin_lock(&ccu_lock);
+	writel((readl(rega) & ~mask) | val, rega);
+	spin_unlock(&ccu_lock);
+}
+
+static void ccu_wait_pll_stable(struct ccu *ccu)
+{
+	void __iomem *base = bases[ccu->index];
+	u32 lock;
+//	u32 reg;
+	unsigned int cnt;
+
+	if (ccu->has_gate &&
+	    !(readl(base + ccu->reg) & BIT(ccu->gate_bit)))
+		return;				/* clock not enabled */
+
+	if (ccu->lock_reg || ccu->lock_bit) {
+		lock = BIT(ccu->lock_bit);
+#if 1 // readl_relaxed_poll_timeout() does not work at startup time
+		cnt = 500;
+		while (1) {
+			udelay(200);
+			if (readl(base + ccu->lock_reg) & lock)
+				break;
+			if (--cnt == 0) {
+				pr_err("%s: no rate lock!\n",
+					clk_hw_get_name(&ccu->hw));
+				break;
+			}
+		}
+#else
+		WARN_ON(readl_relaxed_poll_timeout(base + ccu->lock_reg,
+							reg, reg & lock,
+							100, 70000));
+#endif
+	} else {
+		udelay(500);
+	}
+}
+
+/* --- enable / disable --- */
+static int ccu_enable(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	ccu_dbg("%s enable\n", clk_hw_get_name(&ccu->hw));
+
+	if (ccu->reset_reg)
+		ccu_set_field(ccu, ccu->reset_reg, BIT(ccu->reset_bit),
+						BIT(ccu->reset_bit));
+	if (ccu->bus_reg)
+		ccu_set_field(ccu, ccu->bus_reg, BIT(ccu->bus_bit),
+						BIT(ccu->bus_bit));
+	if (ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit),
+						BIT(ccu->gate_bit));
+	ccu_wait_pll_stable(ccu);
+
+	return 0;
+}
+
+void ccu_disable(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	ccu_dbg("%s disable\n", clk_hw_get_name(&ccu->hw));
+
+	if (ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit), 0);
+	if (ccu->bus_reg)
+		ccu_set_field(ccu, ccu->bus_reg, BIT(ccu->bus_bit), 0);
+	if (ccu->reset_reg)
+		ccu_set_field(ccu, ccu->reset_reg, BIT(ccu->reset_bit), 0);
+}
+
+/* --- PLL --- */
+static unsigned long ccu_pll_find_best(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_pll *p_v)
+{
+	long new_rate, best_rate = 0;
+	long delta, best_delta = 2000000000;
+	unsigned long lmul, ldiv;
+	int n, k, m, p, tmp;
+	int n_max = 1 << ccu->n_width;
+	int d1_max = 1 << ccu->d1_width;
+	int k_max = 1 << ccu->k_width;
+	int m_max = 1 << ccu->m_width;
+	int p_max = (1 << ccu->p_width) - 1;
+
+	/* set the default values */
+	p_v->d1 = 1;
+	p_v->m = 1;
+	p_v->k = 1;
+	p_v->p = 0;
+
+	if (ccu->features & CCU_FEATURE_N0)
+		n_max--;
+
+	/* no divider: parent_rate * n * k */
+	if (d1_max == 1 && m_max == 1 && p_max == 0) {
+		for (k = k_max; k > 0; k--) {
+			int mul;
+
+			mul = rate / parent_rate / k;
+			for (n = mul; n <= mul + 1; n++) {
+				if (n < ccu->n_min)
+					continue;
+				if (n > n_max)
+					break;
+				new_rate = parent_rate * n * k;
+				delta = rate - new_rate;
+				if (delta == 0) {
+					p_v->n = n;
+					p_v->k = k;
+					return new_rate;
+				}
+				if (delta < 0)
+					delta = -delta;
+				if (delta < best_delta) {
+					best_delta = delta;
+					best_rate = new_rate;
+					p_v->n = n;
+					p_v->k = k;
+				}
+			}
+		}
+		return best_rate;
+	}
+
+	/* only one multiplier: parent_rate / d1 * n / m >> p */
+	if (k_max == 1) {
+		for (p = 0; p <= p_max + d1_max - 1; p++) {	/* try min p */
+			if (m_max > 1) {
+				rational_best_approximation(rate, parent_rate,
+							n_max - 1,
+							m_max - 1,
+							&lmul, &ldiv);
+				n = lmul;
+				m = ldiv;
+			} else {
+				m = 0;
+			}
+			if (m == 0) {
+				n = rate / (parent_rate >> p);
+				if (n > n_max)
+					continue;
+				m = 1;
+			}
+			if (n < ccu->n_min) {
+				tmp = (ccu->n_min + n - 1) / n;
+				n *= tmp;
+				m *= tmp;
+				if (n > n_max || m > m_max)
+					continue;
+			}
+			new_rate = parent_rate * n / m >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				if (p > 1 && d1_max > 1) {
+					p--;
+					p_v->d1 = 2;
+				} else {
+					p_v->d1 = 1;
+				}
+				p_v->n = n;
+				p_v->m = m;
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->n = n;
+				p_v->m = m;
+				if (p > 1 && d1_max > 1) {
+					p--;
+					p_v->d1 = 2;
+				} else {
+					p_v->d1 = 1;
+				}
+				p_v->p = p;
+			}
+		}
+		return best_rate;
+	}
+
+	/* general case: parent * n / m * k >> p */
+	for (p = 0; p <= p_max; p++) {			/* try min p */
+		for (k = k_max; k > 0; k--) {		/* try max k */
+			if (m_max > 1) {
+				rational_best_approximation(rate, parent_rate,
+							n_max - 1,
+							m_max - 1,
+							&lmul, &ldiv);
+				n = lmul;
+				m = ldiv;
+			} else {
+				m = 0;
+			}
+			if (m == 0) {
+				n = rate / k / (parent_rate >> p);
+				if (n > n_max)
+					continue;
+				m = 1;
+			}
+			if (n < ccu->n_min) {
+				tmp = (ccu->n_min + n - 1) / n;
+				n *= tmp;
+				m *= tmp;
+				if (n > n_max || m > m_max)
+					continue;
+			}
+			new_rate = parent_rate * n / m * k >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				rational_best_approximation(k, m,
+						k_max - 1,
+						m_max - 1,
+						&lmul, &ldiv);
+				p_v->n = n;
+				if (ldiv != 0) {
+					p_v->k = lmul;
+					p_v->m = ldiv;
+				} else {
+					p_v->k = k;
+					p_v->m = m;
+				}
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->n = n;
+				p_v->m = m;
+				p_v->k = k;
+				p_v->p = p;
+			}
+		}
+	}
+	return best_rate;
+}
+
+static unsigned long ccu_pll_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	unsigned long rate;
+	int i, n, d1, m, k, p;
+	u32 reg;
+
+	reg = readl(rega);
+
+	if (extra) {
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if ((reg & extra->frac[i].mask) == extra->frac[i].val)
+				return rate = extra->frac[i].rate;
+		}
+	}
+
+	rate = parent_rate;
+
+	if (ccu->d1_width) {
+		d1 = reg >> ccu->d1_shift;
+		d1 &= (1 << ccu->d1_width) - 1;
+		rate /= (d1 + 1);
+	}
+
+	if (ccu->n_width) {
+		n = reg >> ccu->n_shift;
+		n &= (1 << ccu->n_width) - 1;
+		if (!(ccu->features & CCU_FEATURE_N0))
+			n++;
+		rate *= n;
+	}
+
+	if (ccu->m_width) {
+		m = reg >> ccu->m_shift;
+		m &= (1 << ccu->m_width) - 1;
+		rate /= (m + 1);
+	}
+
+	if (ccu->k_width) {
+		k = reg >> ccu->k_shift;
+		k &= (1 << ccu->k_width) - 1;
+		rate *= (k + 1);
+	}
+
+	if (ccu->p_width) {
+		p = reg >> ccu->p_shift;
+		p &= (1 << ccu->p_width) - 1;
+		rate >>= p;
+	}
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate /= extra->fixed_div[0];
+
+	return rate;
+}
+
+static int ccu_pll_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long rate = req->rate;
+	unsigned long parent_rate = req->best_parent_rate;
+	struct val_pll v;
+	int i;
+
+	if (extra) {
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if (extra->frac[i].rate == rate)
+				return 0;
+		}
+
+		if (ccu->features & CCU_FEATURE_FIXED_POSTDIV)
+			rate *= extra->fixed_div[0];
+	}
+
+	rate = ccu_pll_find_best(ccu, rate, parent_rate, &v);
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate /= extra->fixed_div[0];
+
+	req->rate = rate;
+
+	return 0;
+}
+
+static void ccu_pll_set_flat_factors(struct ccu *ccu, u32 mask, u32 val)
+{
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	u32 reg, m_val, p_val;
+	u32 m_mask = CCU_MASK(ccu->m_shift, ccu->m_width);
+	u32 p_mask = CCU_MASK(ccu->p_shift, ccu->p_width);
+
+	reg = readl(rega);
+	m_val = reg & m_mask;
+	p_val = reg & p_mask;
+
+	spin_lock(&ccu_lock);
+
+	/* increase p, then m */
+	if (ccu->p_width && p_val < (val & p_mask)) {
+		reg &= ~p_mask;
+		reg |= val & p_mask;
+		writel(reg, rega);
+		udelay(10);
+	}
+	if (ccu->m_width && m_val < (val & m_mask)) {
+		reg &= ~m_mask;
+		reg |= val & m_mask;
+		writel(reg, rega);
+		udelay(10);
+	}
+
+	/* set other factors */
+	reg &= ~(mask & ~(p_mask | m_mask));
+	reg |= val & ~(p_mask | m_mask);
+	writel(reg, rega);
+
+	/* decrease m */
+	if (ccu->m_width && m_val > (val & m_mask)) {
+		reg &= ~m_mask;
+		reg |= val & m_mask;
+		writel(reg, rega);
+		udelay(10);
+	}
+
+	/* wait for PLL stable */
+	ccu_wait_pll_stable(ccu);
+
+	/* decrease p */
+	if (ccu->p_width && p_val > (val & p_mask)) {
+		reg &= ~p_mask;
+		reg |= val & p_mask;
+		writel(reg, rega);
+		udelay(10);
+	}
+
+	spin_unlock(&ccu_lock);
+}
+
+static int ccu_pll_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	struct val_pll v;
+	u32 mask, val;
+
+	mask =  CCU_MASK(ccu->n_shift, ccu->n_width) |
+		CCU_MASK(ccu->d1_shift, ccu->d1_width) |
+		CCU_MASK(ccu->k_shift, ccu->k_width) |
+		CCU_MASK(ccu->m_shift, ccu->m_width) |
+		CCU_MASK(ccu->p_shift, ccu->p_width);
+	val = 0;
+
+	if (extra && extra->num_frac) {
+		int i;
+
+		for (i = 0; i < extra->num_frac - 1; i++) {
+			if (extra->frac[i].rate == rate) {
+				if (extra->frac[i].sd_reg)
+					ccu_set_field(ccu,
+							extra->frac[i].sd_reg,
+							~0,
+							extra->frac[i].sd_val);
+				ccu_set_field(ccu, ccu->reg,
+						extra->frac[i].mask,
+						extra->frac[i].val);
+				return 0;
+			}
+		}
+		mask |= extra->frac[i].mask;
+		val |= extra->frac[i].val;
+	}
+
+	if (extra && (ccu->features & CCU_FEATURE_FIXED_POSTDIV))
+		rate *= extra->fixed_div[0];
+
+
+	rate = ccu_pll_find_best(ccu, rate, parent_rate, &v);
+
+	if (!(ccu->features & CCU_FEATURE_N0))
+		v.n--;
+
+	val |=  (v.n << ccu->n_shift) |
+		((v.d1 - 1) << ccu->d1_shift) |
+		((v.k - 1) << ccu->k_shift) |
+		((v.m - 1) << ccu->m_shift) |
+		(v.p << ccu->p_shift);
+
+	if (ccu->upd_bit)			/* (upd_bit is never 0) */
+		val |= BIT(ccu->upd_bit);
+
+	if (ccu->features & CCU_FEATURE_FLAT_FACTORS) {
+		ccu_pll_set_flat_factors(ccu, mask, val);
+		return 0;
+	}
+	ccu_set_field(ccu, ccu->reg, mask, val);
+	ccu_wait_pll_stable(ccu);
+
+	return 0;
+}
+
+const struct clk_ops ccu_pll_ops = {
+	.enable		= ccu_enable,
+	.disable	= ccu_disable,
+/*	.is_enabled	= NULL;	(don't disable the clocks at startup time) */
+
+	.determine_rate	= ccu_pll_determine_rate,
+	.recalc_rate	= ccu_pll_recalc_rate,
+	.set_rate	= ccu_pll_set_rate,
+};
+
+/* --- mux parent --- */
+static u8 ccu_get_parent(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+
+	if (!ccu->mux_width)
+		return 0;
+
+	return (readl(rega) >> ccu->mux_shift) &
+				((1 << ccu->mux_width) - 1);
+}
+
+static int ccu_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	u32 mask;
+
+	if (!ccu->mux_width)
+		return 0;
+
+	mask = CCU_MASK(ccu->mux_shift, ccu->mux_width);
+
+	ccu_set_field(ccu, ccu->reg, mask, index << ccu->mux_shift);
+
+	return 0;
+}
+
+/* --- mux --- */
+static void ccu_mux_adjust_parent_for_prediv(struct ccu *ccu,
+					     int parent_index,
+					     unsigned long *parent_rate)
+{
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	const struct ccu_extra *extra = ccu->extra;
+	int prediv = 1;
+	u32 reg;
+
+	if (!(extra &&
+	      (ccu->features & (CCU_FEATURE_MUX_FIXED_PREDIV |
+				CCU_FEATURE_MUX_VARIABLE_PREDIV))))
+		return;
+
+	reg = readl(rega);
+	if (parent_index < 0)
+		parent_index = (reg >> ccu->mux_shift) &
+					((1 << ccu->mux_width) - 1);
+
+	if (ccu->features & CCU_FEATURE_MUX_FIXED_PREDIV) {
+		if (parent_index < ARRAY_SIZE(extra->fixed_div))
+			prediv = extra->fixed_div[parent_index];
+	}
+
+	if (ccu->features & CCU_FEATURE_MUX_VARIABLE_PREDIV)
+		if (parent_index == extra->variable_prediv.index) {
+			u8 div;
+
+			div = reg >> extra->variable_prediv.shift;
+			div &= (1 << extra->variable_prediv.width) - 1;
+			prediv = div + 1;
+		}
+
+	*parent_rate /= prediv;
+}
+
+/* --- periph --- */
+static unsigned long ccu_p_best_rate(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_periph *p_v)
+{
+	int p;
+	int p_max = (1 << ccu->p_width) - 1;
+
+	p_v->m = 1;
+
+	for (p = p_max - 1; p >= 0 ; p--) {
+		if (parent_rate >> p > rate)
+			break;
+	}
+	p_v->p = ++p;
+
+	return parent_rate >> p;
+}
+
+static unsigned long ccu_mp_best_rate(struct ccu *ccu,
+					unsigned long rate,
+					unsigned long parent_rate,
+					struct val_periph *p_v)
+{
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long new_rate, best_rate = 0;
+	long delta, best_delta = 2000000000;
+	unsigned int m_max = 1 << ccu->m_width;
+	unsigned int p_max = (1 << ccu->p_width) - 1;
+	int i, m, p, div;
+
+	p_v->m = 1;
+	p_v->p = 0;
+
+	if (extra && (ccu->features & CCU_FEATURE_M_TABLE)) {
+		for (i = 0; i < ARRAY_SIZE(extra->m_table); i++) {
+			m = extra->m_table[i];
+			if (m == 0)
+				break;
+			for (p = p_max; p >= 0; p--) {	/* try max p */
+				new_rate = parent_rate / m >> p;
+				delta = rate - new_rate;
+				if (delta == 0) {
+					p_v->m = i + 1;
+					p_v->p = p;
+					return new_rate;
+				}
+				if (delta < 0)
+					delta = -delta;
+				if (delta < best_delta) {
+					best_delta = delta;
+					best_rate = new_rate;
+					p_v->m = i + 1;
+					p_v->p = p;
+				}
+			}
+		}
+
+		return best_rate;
+	}
+
+	for (p = p_max; p >= 0; p--) {			/* try max p */
+		div = parent_rate / rate >> p;
+		for (m = div; m <= div + 1; m++) {
+			if (m > m_max)
+				break;
+			new_rate = parent_rate / m >> p;
+			delta = rate - new_rate;
+			if (delta == 0) {
+				p_v->m = m;
+				p_v->p = p;
+				return new_rate;
+			}
+			if (delta < 0)
+				delta = -delta;
+			if (delta < best_delta) {
+				best_delta = delta;
+				best_rate = new_rate;
+				p_v->m = m;
+				p_v->p = p;
+			}
+		}
+	}
+
+	return best_rate;
+}
+
+static unsigned long ccu_periph_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	const struct ccu_extra *extra = ccu->extra;
+	int m, p;
+	u32 reg;
+
+	ccu_mux_adjust_parent_for_prediv(ccu, -1, &parent_rate);
+
+	if (!ccu->m_width && !ccu->p_width)
+		return parent_rate;
+
+	reg = readl(rega);
+	m = ((reg >> ccu->m_shift) & ((1 << ccu->m_width) - 1)) + 1;
+
+	if (extra) {
+		if (ccu->features & CCU_FEATURE_M_TABLE)
+			m = extra->m_table[m - 1];
+		if ((ccu->features & CCU_FEATURE_MODE_SELECT) &&
+		    (reg & BIT(extra->mode_select.bit)))
+			m *= 2;
+	}
+
+	if (!ccu->p_width)
+		return parent_rate / m;
+
+	p = (reg >> ccu->p_shift) & ((1 << ccu->p_width) - 1);
+
+	return parent_rate / m >> p;
+}
+
+static int ccu_periph_determine_rate(struct clk_hw *hw,
+				struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	unsigned long best_parent_rate = 0, best_rate = 0;
+	struct clk_hw *best_parent;
+	unsigned long (*round)(struct ccu *,
+				unsigned long,
+				unsigned long,
+				struct val_periph *p_v);
+	struct val_periph v;
+	unsigned int i;
+
+	if (ccu->m_width)
+		round = ccu_mp_best_rate;
+	else if (ccu->p_width)
+		round = ccu_p_best_rate;
+	else
+		return __clk_mux_determine_rate(hw, req);
+
+	for (i = 0; i < clk_hw_get_num_parents(hw); i++) {
+		unsigned long new_rate, parent_rate;
+		struct clk_hw *parent;
+
+		parent = clk_hw_get_parent_by_index(hw, i);
+		if (!parent)
+			continue;
+
+		if (ccu->features & CCU_FEATURE_SET_RATE_PARENT) {
+			struct clk_rate_request parent_req = *req;
+			int ret;
+
+			ret = __clk_determine_rate(parent, &parent_req);
+			if (ret)
+				continue;
+			parent_rate = parent_req.rate;
+		} else {
+			parent_rate = clk_hw_get_rate(parent);
+		}
+		ccu_mux_adjust_parent_for_prediv(ccu, i, &parent_rate);
+		new_rate = round(ccu, req->rate, parent_rate, &v);
+
+		if (new_rate == req->rate) {
+			best_rate = new_rate;
+			best_parent = parent;
+			best_parent_rate = parent_rate;
+			goto out;
+		}
+
+		if ((req->rate - new_rate) < (req->rate - best_rate)) {
+			best_rate = new_rate;
+			best_parent = parent;
+			best_parent_rate = parent_rate;
+		}
+	}
+
+	if (best_rate == 0)
+		return -EINVAL;
+
+out:
+	req->best_parent_hw = best_parent;
+	req->best_parent_rate = best_parent_rate;
+	req->rate = best_rate;
+
+	return 0;
+}
+
+static int ccu_periph_set_rate(struct clk_hw *hw,
+				unsigned long rate,
+				unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	const struct ccu_extra *extra = ccu->extra;
+	struct val_periph v;
+	u32 mask = 0;
+	u32 mode = 0;
+
+	if (!ccu->m_width && !ccu->p_width)
+		return 0;
+
+	ccu_mux_adjust_parent_for_prediv(ccu, -1, &parent_rate);
+
+	if (extra && (ccu->features & CCU_FEATURE_MODE_SELECT)) {
+		mask = BIT(extra->mode_select.bit);
+		if (rate >= extra->mode_select.rate) {
+			mode = mask;			/* MMC new mode */
+			rate *= 2;
+		}
+	}
+
+	if (ccu->m_width)				/* m and p */
+		ccu_mp_best_rate(ccu, rate, parent_rate, &v);
+	else
+		ccu_p_best_rate(ccu, rate, parent_rate, &v);
+
+	mask |= CCU_MASK(ccu->m_shift, ccu->m_width) |
+		CCU_MASK(ccu->p_shift, ccu->p_width);
+
+	if ((ccu->features & CCU_FEATURE_SET_RATE_GATE) &&
+	    ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit), 0);
+	ccu_set_field(ccu, ccu->reg, mask, (mode |
+						(v.m - 1) << ccu->m_shift) |
+						(v.p << ccu->p_shift));
+	if ((ccu->features & CCU_FEATURE_SET_RATE_GATE) &&
+	    ccu->has_gate)
+		ccu_set_field(ccu, ccu->reg, BIT(ccu->gate_bit),
+						BIT(ccu->gate_bit));
+
+	return 0;
+}
+
+const struct clk_ops ccu_periph_ops = {
+	.enable		= ccu_enable,
+	.disable	= ccu_disable,
+/*	.is_enabled	= NULL;	(don't disable the clocks at startup time) */
+
+	.get_parent	= ccu_get_parent,
+	.set_parent	= ccu_set_parent,
+
+	.determine_rate	= ccu_periph_determine_rate,
+	.recalc_rate	= ccu_periph_recalc_rate,
+	.set_rate	= ccu_periph_set_rate,
+};
+
+/* --- fixed factor --- */
+/* mul is n_width - div is m_width */
+static unsigned long ccu_fixed_factor_recalc_rate(struct clk_hw *hw,
+						unsigned long parent_rate)
+{
+	struct ccu *ccu = hw2ccu(hw);
+
+	return parent_rate / ccu->m_width * ccu->n_width;
+}
+
+static int ccu_fixed_factor_determine_rate(struct clk_hw *hw,
+					struct clk_rate_request *req)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	unsigned long *parent_rate = &req->best_parent_rate;
+
+	if (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {
+		unsigned long best_parent;
+
+		best_parent = req->rate / ccu->n_width * ccu->m_width;
+		*parent_rate = clk_hw_round_rate(clk_hw_get_parent(hw),
+						 best_parent);
+	}
+
+	req->rate = *parent_rate / ccu->m_width * ccu->n_width;
+	return 0;
+}
+
+static int ccu_fixed_factor_set_rate(struct clk_hw *hw, unsigned long rate,
+				     unsigned long parent_rate)
+{
+	return 0;
+}
+
+const struct clk_ops ccu_fixed_factor_ops = {
+	.disable	= ccu_disable,
+	.enable		= ccu_enable,
+/*	.is_enabled	= NULL, */
+
+	.determine_rate	= ccu_fixed_factor_determine_rate,
+	.recalc_rate	= ccu_fixed_factor_recalc_rate,
+	.set_rate	= ccu_fixed_factor_set_rate,
+};
+
+/* --- phase --- */
+static int ccu_phase_get_phase(struct clk_hw *hw)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	const struct ccu_extra *extra = ccu->extra;
+	struct clk_hw *parent, *grandparent;
+	unsigned long parent_rate, grandparent_rate;
+	u16 step, parent_div;
+	u32 reg;
+	u8 delay;
+
+	reg = readl(rega);
+
+	if (extra &&
+	   (ccu->features & CCU_FEATURE_MODE_SELECT) &&
+	   (reg & BIT(extra->mode_select.bit)))
+		return -ENODATA;
+
+	delay = (reg >> ccu->p_shift);
+	delay &= (1 << ccu->p_width) - 1;
+
+	if (!delay)
+		return 180;
+
+	/* Get our parent clock, it's the one that can adjust its rate */
+	parent = clk_hw_get_parent(hw);
+	if (!parent)
+		return -EINVAL;
+
+	/* And its rate */
+	parent_rate = clk_hw_get_rate(parent);
+	if (!parent_rate)
+		return -EINVAL;
+
+	/* Now, get our parent's parent (most likely some PLL) */
+	grandparent = clk_hw_get_parent(parent);
+	if (!grandparent)
+		return -EINVAL;
+
+	/* And its rate */
+	grandparent_rate = clk_hw_get_rate(grandparent);
+	if (!grandparent_rate)
+		return -EINVAL;
+
+	/* Get our parent clock divider */
+	parent_div = grandparent_rate / parent_rate;
+
+	step = DIV_ROUND_CLOSEST(360, parent_div);
+	return delay * step;
+}
+
+static int ccu_phase_set_phase(struct clk_hw *hw, int degrees)
+{
+	struct ccu *ccu = hw2ccu(hw);
+	void __iomem *rega = bases[ccu->index] + ccu->reg;
+	struct clk_hw *parent, *grandparent;
+	const struct ccu_extra *extra = ccu->extra;
+	unsigned long parent_rate, grandparent_rate;
+	u32 reg, mask;
+	u8 delay = 0;
+	u16 step, parent_div;
+
+	/* cannot set the phase in new mode */
+	if (extra &&
+	   (ccu->features & CCU_FEATURE_MODE_SELECT)) {
+		reg = readl(rega);
+		if (reg & BIT(extra->mode_select.bit))
+			return -EPERM;
+	}
+
+	if (degrees == 180)
+		goto set_phase;
+
+	/* Get our parent clock, it's the one that can adjust its rate */
+	parent = clk_hw_get_parent(hw);
+	if (!parent)
+		return -EINVAL;
+
+	/* And its rate */
+	parent_rate = clk_hw_get_rate(parent);
+	if (!parent_rate)
+		return -EINVAL;
+
+	/* Now, get our parent's parent (most likely some PLL) */
+	grandparent = clk_hw_get_parent(parent);
+	if (!grandparent)
+		return -EINVAL;
+
+	/* And its rate */
+	grandparent_rate = clk_hw_get_rate(grandparent);
+	if (!grandparent_rate)
+		return -EINVAL;
+
+	/* Get our parent divider */
+	parent_div = grandparent_rate / parent_rate;
+
+	/*
+	 * We can only outphase the clocks by multiple of the
+	 * PLL's period.
+	 *
+	 * Since our parent clock is only a divider, and the
+	 * formula to get the outphasing in degrees is deg =
+	 * 360 * delta / period
+	 *
+	 * If we simplify this formula, we can see that the
+	 * only thing that we're concerned about is the number
+	 * of period we want to outphase our clock from, and
+	 * the divider set by our parent clock.
+	 */
+	step = DIV_ROUND_CLOSEST(360, parent_div);
+	delay = DIV_ROUND_CLOSEST(degrees, step);
+
+set_phase:
+	mask = CCU_MASK(ccu->p_shift, ccu->p_width);
+	ccu_set_field(ccu, ccu->reg, mask, delay << ccu->p_shift);
+
+	return 0;
+}
+
+const struct clk_ops ccu_phase_ops = {
+	.get_phase	= ccu_phase_get_phase,
+	.set_phase	= ccu_phase_set_phase,
+};
+
+/* --- reset --- */
+struct ccu_reset {
+	const struct ccu_reset_map	*reset_map;
+	struct reset_controller_dev	rcdev;
+};
+
+static inline
+struct ccu_reset *rcdev_to_ccu_reset(struct reset_controller_dev *rcdev)
+{
+	return container_of(rcdev, struct ccu_reset, rcdev);
+}
+
+static int ccu_reset_de_assert(struct reset_controller_dev *rcdev,
+				unsigned long id,
+				int enable)
+{
+	struct ccu_reset *ccu_reset = rcdev_to_ccu_reset(rcdev);
+	const struct ccu_reset_map *map = &ccu_reset->reset_map[id];
+	void __iomem *rega = bases[map->index] + map->reg;
+	u32 mask;
+
+	if (!map->reg)			/* compatibility */
+		return 0;
+
+	ccu_dbg("reset %p %d %sassert\n",
+		rega, map->bit, enable ? "de-" : "");
+
+	mask = BIT(map->bit);
+
+	spin_lock(&ccu_lock);
+	if (enable)
+		writel(readl(rega) | mask, rega);
+	else
+		writel(readl(rega) & ~mask, rega);
+	spin_unlock(&ccu_lock);
+
+	return 0;
+}
+
+static int ccu_reset_assert(struct reset_controller_dev *rcdev,
+			    unsigned long id)
+{
+	return ccu_reset_de_assert(rcdev, id, 0);
+}
+
+static int ccu_reset_deassert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	return ccu_reset_de_assert(rcdev, id, 1);
+}
+
+const struct reset_control_ops ccu_reset_ops = {
+	.assert		= ccu_reset_assert,
+	.deassert	= ccu_reset_deassert,
+};
+
+static struct ccu_reset ccu_resets = {
+	.rcdev.ops = &ccu_reset_ops,
+	.rcdev.owner = THIS_MODULE,
+};
+
+/* --- init --- */
+static struct clk_hw_onecell_data *ccu_onecell;
+
+int __init ccu_probe(struct device_node *node,
+			const struct ccu * const ccu_clks[],
+			int nr_clks,
+			const struct ccu_reset_map *reset_map,
+			int nr_resets)
+{
+	struct clk_hw *hw;
+	struct ccu *ccu;
+	int i, ret;
+
+	bases[0] = of_iomap(node, 0);
+	if (!bases[0]) {
+		pr_err("%s: Clock mapping failed\n",
+			of_node_full_name(node));
+		return -EINVAL;
+	}
+	bases[1] = of_iomap(node, 1);		/* PRCM optional */
+
+	/* register the clocks */
+	ccu_onecell = kmalloc(sizeof(*ccu_onecell) +
+					nr_clks * sizeof(struct clk_hw *),
+					GFP_KERNEL);
+	if (!ccu_onecell) {
+		pr_err("%s: Out of memory\n", of_node_full_name(node));
+		return -EINVAL;
+	}
+
+	for (i = 0; i < nr_clks; i++) {
+		ccu = kmemdup(ccu_clks[i], sizeof(*ccu), GFP_KERNEL);
+		if (!ccu) {
+			pr_err("%s: clock[%d] Out of memory\n",
+				of_node_full_name(node), i);
+			break;
+		}
+		hw = &ccu->hw;
+		if (hw->init->flags & CLK_SET_RATE_PARENT)
+			ccu->features |= CCU_FEATURE_SET_RATE_PARENT;
+		ccu_onecell->hws[i] = hw;
+		ret = clk_hw_register(NULL, hw);
+		if (ret < 0) {
+			pr_err("%s: Register clock[%d] %s failed %d\n",
+				of_node_full_name(node), i,
+				hw->init->name, ret);
+			break;
+		}
+	}
+	ccu_onecell->num = i;
+	ret = of_clk_add_hw_provider(node, of_clk_hw_onecell_get, ccu_onecell);
+	if (ret < 0)
+		goto err;
+
+	/* register the resets */
+	ccu_resets.rcdev.of_node = node;
+	ccu_resets.rcdev.nr_resets = nr_resets;
+	ccu_resets.reset_map = kmemdup(reset_map,
+					nr_resets * sizeof(reset_map[0]),
+					GFP_KERNEL);
+
+	ret = reset_controller_register(&ccu_resets.rcdev);
+	if (ret) {
+		pr_err("%s: Reset register failed %d\n",
+			of_node_full_name(node), ret);
+		goto err;
+	}
+
+	return ret;
+
+err:
+	/* don't do anything, otherwise no uart anymore */
+	return ret;
+}
diff --git a/drivers/clk/sunxi/ccu.h b/drivers/clk/sunxi/ccu.h
new file mode 100644
index 0000000..b902874
--- /dev/null
+++ b/drivers/clk/sunxi/ccu.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or 
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef _CCU_H_
+#define _CCU_H_
+
+struct device_node;
+
+#define CCU_HW(_name, _parents, _ops)		\
+	.name		= _name,		\
+	.parent_names	= _parents,		\
+	.num_parents	= ARRAY_SIZE(_parents),	\
+	.ops 		= _ops
+
+#define CCU_REG(_reg) .reg = _reg
+#define CCU_REG1(_reg) .reg = _reg, .index = 1
+#define CCU_RESET(_reg, _bit) .reset_reg = _reg, .reset_bit = _bit
+#define CCU_BUS(_reg, _bit) .bus_reg = _reg, .bus_bit = _bit
+#define CCU_GATE(_bit) .has_gate = 1, .gate_bit = _bit
+#define CCU_LOCK(_reg, _bit) .lock_reg = _reg, .lock_bit = _bit
+#define CCU_MUX(_shift, _width) .mux_shift = _shift, .mux_width = _width
+#define CCU_N(_shift, _width) .n_shift = _shift, .n_width = _width
+#define CCU_D1(_shift, _width) .d1_shift = _shift, .d1_width = _width
+#define CCU_D2(_shift, _width) .p_shift = _shift, .p_width = _width
+#define CCU_K(_shift, _width) .k_shift = _shift, .k_width = _width
+#define CCU_M(_shift, _width) .m_shift = _shift, .m_width = _width
+#define CCU_P(_shift, _width) .p_shift = _shift, .p_width = _width
+#define CCU_UPD(_bit) .upd_bit = _bit
+/* with ccu_fixed_factor_ops */
+#define CCU_FIXED(_mul, _div) .n_width = _mul, .m_width = _div
+/* with ccu_phase_ops */
+#define CCU_PHASE(_shift, _width) .p_shift = _shift, .p_width = _width
+
+#define CCU_FEATURE_MUX_VARIABLE_PREDIV	BIT(0)
+#define CCU_FEATURE_MUX_FIXED_PREDIV	BIT(1)
+#define CCU_FEATURE_FIXED_POSTDIV	BIT(2)
+#define CCU_FEATURE_N0			BIT(3)
+#define CCU_FEATURE_MODE_SELECT		BIT(4)
+#define CCU_FEATURE_FLAT_FACTORS	BIT(5)
+#define CCU_FEATURE_SET_RATE_GATE	BIT(6)
+#define CCU_FEATURE_M_TABLE		BIT(7)
+#define CCU_FEATURE_SET_RATE_PARENT	BIT(8)
+
+/* extra */
+#define CCU_EXTRA_FRAC(_frac) .frac = _frac, .num_frac = ARRAY_SIZE(_frac)
+#define CCU_EXTRA_POST_DIV(_div) .fixed_div[0] = _div
+
+/* fractional and Sigma-Delta items */
+struct frac {
+	unsigned long rate;
+	u32 mask;
+	u32 val;
+	u32 sd_reg;
+	u32 sd_val;
+};
+
+/* extra features */
+struct ccu_extra {
+	const struct frac *frac; /* array - last is the fractional mask/value */
+	u8 num_frac;
+
+	u16 fixed_div[4];		/* index = parent */
+
+	struct {
+		u8 index;
+		u8 shift;
+		u8 width;
+	} variable_prediv;
+
+	struct {
+		unsigned long rate;
+		u8 bit;
+	} mode_select;
+
+	u8 m_table[8];
+};
+
+struct ccu {
+	struct clk_hw hw;
+
+	u16 reg;
+
+	u16 reset_reg, bus_reg, lock_reg;
+	u8  reset_bit, bus_bit, lock_bit;
+	u8 has_gate, gate_bit;
+	u8 index;			/* CCU = 0, PRCM = 1 */
+
+	u8 mux_shift, mux_width;
+	u8 n_shift, n_width, n_min;
+	u8 d1_shift, d1_width;
+//	u8 d2_shift, d2_width;		/* d2 is p (never d2 + p) */
+	u8 k_shift, k_width;
+	u8 m_shift, m_width;
+	u8 p_shift, p_width;
+
+	u8 upd_bit;
+
+	u16 features;
+
+	const struct ccu_extra *extra;
+};
+
+struct ccu_reset_map {
+	u16	reg;
+	u8	bit;
+	u8	index;			/* CCU = 0, PRCM = 1 */
+};
+
+extern const struct clk_ops ccu_fixed_factor_ops;
+extern const struct clk_ops ccu_periph_ops;
+extern const struct clk_ops ccu_pll_ops;
+extern const struct clk_ops ccu_phase_ops;
+
+int ccu_probe(struct device_node *node,
+		const struct ccu * const ccu_clks[],
+		int nr_clks,
+		const struct ccu_reset_map *reset_map,
+		int nr_resets);
+
+#endif /* _CCU_H_ */
diff --git a/drivers/gpu/drm/sunxi/Kconfig b/drivers/gpu/drm/sunxi/Kconfig
new file mode 100644
index 0000000..4c82153
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Kconfig
@@ -0,0 +1,29 @@
+#
+# Allwinner Video configuration
+#
+
+config DRM_SUNXI
+	tristate "DRM Support for Allwinner Video"
+	depends on DRM && OF
+	depends on ARCH_SUNXI || COMPILE_TEST
+	select DRM_KMS_HELPER
+	select DRM_KMS_CMA_HELPER
+	select DRM_GEM_CMA_HELPER
+	help
+	  Choose this option if you have a Allwinner chipset.
+
+config DRM_SUNXI_DE2
+	tristate "Support for Allwinner Video with DE2 interface"
+	depends on DRM_SUNXI
+	help
+	  Choose this option if your Allwinner chipset has the DE2 interface
+	  as the A64, A83T and H3. If M is selected the module will be called
+	  sunxi-de2-drm.
+
+config DRM_SUNXI_DE2_HDMI
+	tristate "Support for DE2 HDMI"
+	depends on DRM_SUNXI_DE2
+	select SND_SOC_SUNXI_HDMI if SND_SOC
+	help
+	  Choose this option if you use want HDMI on DE2.
+	  If M is selected the module will be called sunxi-de2-hdmi.
diff --git a/drivers/gpu/drm/sunxi/Makefile b/drivers/gpu/drm/sunxi/Makefile
new file mode 100644
index 0000000..a268069
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for Allwinner's sun8i DRM device driver
+#
+
+sunxi-de2-drm-objs := de2_drv.o de2_de.o de2_crtc.o de2_plane.o
+sunxi-de2-hdmi-objs := de2_hdmi.o de2_hdmi_io.o
+
+obj-$(CONFIG_DRM_SUNXI_DE2) += sunxi-de2-drm.o
+obj-$(CONFIG_DRM_SUNXI_DE2_HDMI) += sunxi-de2-hdmi.o
diff --git a/drivers/gpu/drm/sunxi/de2_crtc.c b/drivers/gpu/drm/sunxi/de2_crtc.c
new file mode 100644
index 0000000..e476d00
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_crtc.c
@@ -0,0 +1,546 @@
+/*
+ * Allwinner DRM driver - DE2 CRTC
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/component.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <asm/io.h>
+#include <linux/of_irq.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+/* I/O map */
+
+struct tcon {
+	u32 gctl;
+#define		TCON_GCTL_TCON_En BIT(31)
+	u32 gint0;
+#define		TCON_GINT0_TCON1_Vb_Int_En BIT(30)
+#define		TCON_GINT0_TCON1_Vb_Int_Flag BIT(14)
+	u32 gint1;
+	u32 dum0[13];
+	u32 tcon0_ctl;				/* 0x40 */
+#define		TCON0_CTL_TCON_En BIT(31)
+	u32 dum1[19];
+	u32 tcon1_ctl;				/* 0x90 */
+#define		TCON1_CTL_TCON_En BIT(31)
+#define		TCON1_CTL_Interlace_En BIT(20)
+#define		TCON1_CTL_Start_Delay_SHIFT 4
+#define		TCON1_CTL_Start_Delay_MASK GENMASK(8, 4)
+	u32 basic0;			/* XI/YI */
+	u32 basic1;			/* LS_XO/LS_YO */
+	u32 basic2;			/* XO/YO */
+	u32 basic3;			/* HT/HBP */
+	u32 basic4;			/* VT/VBP */
+	u32 basic5;			/* HSPW/VSPW */
+	u32 dum2;
+	u32 ps_sync;				/* 0xb0 */
+	u32 dum3[15];
+	u32 io_pol;				/* 0xf0 */
+#define		TCON1_IO_POL_IO0_inv BIT(24)
+#define		TCON1_IO_POL_IO1_inv BIT(25)
+#define		TCON1_IO_POL_IO2_inv BIT(26)
+	u32 io_tri;
+	u32 dum4[2];
+
+	u32 ceu_ctl;				/* 0x100 */
+#define     TCON_CEU_CTL_ceu_en BIT(31)
+	u32 dum5[3];
+	u32 ceu_rr;
+	u32 ceu_rg;
+	u32 ceu_rb;
+	u32 ceu_rc;
+	u32 ceu_gr;
+	u32 ceu_gg;
+	u32 ceu_gb;
+	u32 ceu_gc;
+	u32 ceu_br;
+	u32 ceu_bg;
+	u32 ceu_bb;
+	u32 ceu_bc;
+	u32 ceu_rv;
+	u32 ceu_gv;
+	u32 ceu_bv;
+	u32 dum6[45];
+
+	u32 mux_ctl;				/* 0x200 */
+//#define		TCON_MUX_CTL_HDMI_SRC_SHIFT 8
+//#define		TCON_MUX_CTL_HDMI_SRC_MASK GENMASK(9, 8)
+	u32 dum7[63];
+
+	u32 fill_ctl;				/* 0x300 */
+	u32 fill_start0;
+	u32 fill_end0;
+	u32 fill_data0;
+};
+
+#define XY(x, y) (((x) << 16) | (y))
+
+#define tcon_read(base, member) \
+	readl_relaxed(base + offsetof(struct tcon, member))
+#define tcon_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct tcon, member))
+
+#if 0 // try without moving state now -> ok
+//needed in kernel 4.8 ?
+/* move state */
+static void de2_atomic_begin(struct drm_crtc *crtc,
+			struct drm_crtc_state *old_state)
+{
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	unsigned long flags;
+
+	if (crtc->state->event && !crtc->state->active) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		lcd->event = crtc->state->event;
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		crtc->state->event = NULL;
+	}
+}
+#endif
+
+/* vertical blank functions */
+static void de2_atomic_flush(struct drm_crtc *crtc,
+			struct drm_crtc_state *old_state)
+{
+	struct drm_pending_vblank_event *event = crtc->state->event;
+
+	if (event) {
+		crtc->state->event = NULL;
+		spin_lock_irq(&crtc->dev->event_lock);
+		if (drm_crtc_vblank_get(crtc) == 0)
+			drm_crtc_arm_vblank_event(crtc, event);
+		else
+			drm_crtc_send_vblank_event(crtc, event);
+		spin_unlock_irq(&crtc->dev->event_lock);
+	}
+}
+
+static irqreturn_t de2_lcd_irq(int irq, void *dev_id)
+{
+	struct lcd *lcd = (struct lcd *) dev_id;
+	u32 isr;
+//	unsigned long flags;
+
+	isr = tcon_read(lcd->mmio, gint0);
+
+	drm_crtc_handle_vblank(&lcd->crtc);
+#if 0 // is this needed? - see atomic_begin
+	spin_lock_irqsave(&dev->event_lock, flags);
+	if (lcd->event) {
+		drm_crtc_send_vblank_event(&lcd->crtc, lcd->event);
+		drm_crtc_vblank_put(&lcd->crtc);
+		lcd->event = NULL;
+	}
+	spin_unlock_irqrestore(&dev->event_lock, flags);
+#endif
+
+	tcon_write(lcd->mmio, gint0, isr & ~TCON_GINT0_TCON1_Vb_Int_Flag);
+
+	return IRQ_HANDLED;
+}
+
+int de2_enable_vblank(struct drm_device *drm, unsigned crtc)
+{
+	struct priv *priv = drm_to_priv(drm);
+	struct lcd *lcd = priv->lcds[crtc];
+
+	tcon_write(lcd->mmio, gint0,
+		   tcon_read(lcd->mmio, gint0) | TCON_GINT0_TCON1_Vb_Int_En);
+	return 0;
+}
+
+void de2_disable_vblank(struct drm_device *drm, unsigned crtc)
+{
+	struct priv *priv = drm_to_priv(drm);
+	struct lcd *lcd = priv->lcds[crtc];
+
+	tcon_write(lcd->mmio, gint0,
+			 tcon_read(lcd->mmio, gint0) &
+					~TCON_GINT0_TCON1_Vb_Int_En);
+}
+
+/* dumb panel functions */
+static void de2_set_frame_timings(struct lcd *lcd)
+{
+	struct drm_crtc *crtc = &lcd->crtc;
+	const struct drm_display_mode *mode = &crtc->mode;
+	int interlace = mode->flags & DRM_MODE_FLAG_INTERLACE ? 2 : 1;
+	int start_delay;
+	u32 data;
+
+	data = XY(mode->hdisplay - 1, mode->vdisplay / interlace - 1);
+	tcon_write(lcd->mmio, basic0, data);
+	tcon_write(lcd->mmio, basic1, data);
+	tcon_write(lcd->mmio, basic2, data);
+	tcon_write(lcd->mmio, basic3,
+			XY(mode->htotal - 1,
+				mode->htotal - mode->hsync_start - 1));
+	tcon_write(lcd->mmio, basic4,
+			XY(mode->vtotal * (3 - interlace),
+				mode->vtotal - mode->vsync_start - 1));
+	tcon_write(lcd->mmio, basic5,
+			 XY(mode->hsync_end - mode->hsync_start - 1,
+				mode->vsync_end - mode->vsync_start - 1));
+
+	tcon_write(lcd->mmio, ps_sync, XY(1, 1));
+
+	data = TCON1_IO_POL_IO2_inv;
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC)
+		data |= TCON1_IO_POL_IO0_inv;
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC)
+		data |= TCON1_IO_POL_IO1_inv;
+	tcon_write(lcd->mmio, io_pol, data);
+
+	tcon_write(lcd->mmio, ceu_ctl,
+		tcon_read(lcd->mmio, ceu_ctl) & ~TCON_CEU_CTL_ceu_en);
+
+	data = tcon_read(lcd->mmio, tcon1_ctl);
+	if (interlace == 2)
+		data |= TCON1_CTL_Interlace_En;
+	else
+		data &= ~TCON1_CTL_Interlace_En;
+	tcon_write(lcd->mmio, tcon1_ctl, data);
+
+	tcon_write(lcd->mmio, fill_ctl, 0);
+	tcon_write(lcd->mmio, fill_start0, mode->vtotal + 1);
+	tcon_write(lcd->mmio, fill_end0, mode->vtotal);
+	tcon_write(lcd->mmio, fill_data0, 0);
+
+	start_delay = (mode->vtotal - mode->vdisplay) / interlace - 5;
+	if (start_delay > 31)
+		start_delay = 31;
+	data = tcon_read(lcd->mmio, tcon1_ctl);
+	data &= ~TCON1_CTL_Start_Delay_MASK;
+	data |= start_delay << TCON1_CTL_Start_Delay_SHIFT;
+	tcon_write(lcd->mmio, tcon1_ctl, data);
+
+	tcon_write(lcd->mmio, io_tri, 0x0fffffff);
+}
+
+static void de2_crtc_enable(struct drm_crtc *crtc)
+{
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	struct drm_display_mode *mode = &crtc->mode;
+//	struct drm_connector *connector;
+//	u32 data;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	clk_set_rate(lcd->clk, mode->clock * 1000);
+
+	de2_set_frame_timings(lcd);
+
+// useless (from tests on A83T and H3 with lichee u-boot)
+//	/* if HDMI, set the link */
+//	connector = list_first_entry(&crtc->dev->mode_config.connector_list,
+//				struct drm_connector, head);
+//if (connector) {
+// pr_info("*jfm* de2 connector %d (%d)\n",
+//  connector->connector_type, DRM_MODE_CONNECTOR_HDMIA);
+//	if (connector->connector_type == DRM_MODE_CONNECTOR_HDMIA) {
+//		data = tcon_read(lcd->mmio, mux_ctl);
+//		data &= ~TCON_MUX_CTL_HDMI_SRC_MASK;
+//		data |= lcd->num << TCON_MUX_CTL_HDMI_SRC_SHIFT;
+//		tcon_write(lcd->mmio, mux_ctl, data);
+//	}
+//}
+
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) | TCON1_CTL_TCON_En);
+
+	de2_de_dumb_panel_init(lcd->priv, lcd->num, mode);
+
+	drm_mode_debug_printmodeline(mode);
+}
+
+static void de2_crtc_disable(struct drm_crtc *crtc)
+{
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	unsigned long flags;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) & ~TCON1_CTL_TCON_En);
+
+	if (crtc->state->event && !crtc->state->active) {
+		spin_lock_irqsave(&crtc->dev->event_lock, flags);
+		drm_crtc_send_vblank_event(crtc, crtc->state->event);
+		spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+		crtc->state->event = NULL;
+	}
+}
+
+static const struct drm_crtc_funcs de2_crtc_funcs = {
+	.destroy	= drm_crtc_cleanup,
+	.set_config	= drm_atomic_helper_set_config,
+	.page_flip	= drm_atomic_helper_page_flip,
+	.reset		= drm_atomic_helper_crtc_reset,
+	.atomic_duplicate_state = drm_atomic_helper_crtc_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_crtc_destroy_state,
+};
+
+static const struct drm_crtc_helper_funcs de2_crtc_helper_funcs = {
+	.atomic_flush	= de2_atomic_flush,
+	.enable		= de2_crtc_enable,
+	.disable	= de2_crtc_disable,
+};
+
+static void de2_tcon_init(struct lcd *lcd)
+{
+	tcon_write(lcd->mmio, tcon0_ctl,
+		tcon_read(lcd->mmio, tcon0_ctl) & ~TCON0_CTL_TCON_En);
+	tcon_write(lcd->mmio, tcon1_ctl,
+		tcon_read(lcd->mmio, tcon1_ctl) & ~TCON1_CTL_TCON_En);
+	tcon_write(lcd->mmio, gctl,
+		tcon_read(lcd->mmio, gctl) & ~TCON_GCTL_TCON_En);
+
+	/* disable/ack interrupts */
+	tcon_write(lcd->mmio, gint0, 0);
+}
+
+static void de2_tcon_enable(struct lcd *lcd)
+{
+	tcon_write(lcd->mmio, gctl,
+		tcon_read(lcd->mmio, gctl) | TCON_GCTL_TCON_En);
+}
+
+static int de2_crtc_init(struct drm_device *drm, struct lcd *lcd)
+{
+	struct drm_crtc *crtc = &lcd->crtc;
+	int ret;
+
+	ret = de2_plane_init(drm, lcd);
+	if (ret < 0)
+		return ret;
+
+	drm_crtc_helper_add(crtc, &de2_crtc_helper_funcs);
+
+//	/* fixme: only one UI in LCD 1, so, no hardware cursor... */
+	ret = drm_crtc_init_with_planes(drm, crtc,
+					&lcd->planes[DE2_PRIMARY_PLANE],
+//					lcd->num == 0 ?
+//						&lcd->planes[DE2_CURSOR_PLANE] :
+//						NULL,
+					&lcd->planes[DE2_CURSOR_PLANE],
+					&de2_crtc_funcs, NULL);
+	if (ret < 0)
+		return ret;
+
+	de2_tcon_enable(lcd);
+
+	de2_de_enable(lcd->priv, lcd->num);
+
+	return 0;
+}
+
+/*
+ * device init
+ */
+static int de2_lcd_bind(struct device *dev, struct device *master,
+			void *data)
+{
+	struct drm_device *drm = data;
+	struct priv *priv = drm_to_priv(drm);
+	struct lcd *lcd = dev_get_drvdata(dev);
+	int ret;
+
+	lcd->priv = priv;
+
+	/* (only 2 LCDs) */
+	lcd->crtc_idx = priv->lcds[0] ? 1 : 0;
+	priv->lcds[lcd->crtc_idx] = lcd;
+
+	ret = de2_crtc_init(drm, lcd);
+	if (ret < 0) {
+		dev_err(dev, "failed to init the crtc\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void de2_lcd_unbind(struct device *dev, struct device *master,
+			void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct lcd *lcd = platform_get_drvdata(pdev);
+
+	if (lcd->mmio) {
+		if (lcd->priv)
+			de2_de_disable(lcd->priv, lcd->num);
+		tcon_write(lcd->mmio, gctl,
+			tcon_read(lcd->mmio, gctl) & ~TCON_GCTL_TCON_En);
+	}
+}
+
+static const struct component_ops de2_lcd_ops = {
+	.bind = de2_lcd_bind,
+	.unbind = de2_lcd_unbind,
+};
+
+static int de2_lcd_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *tmp, *parent, *port;
+	struct lcd *lcd;
+	struct resource *res;
+	int id, irq, ret;
+
+	id = of_alias_get_id(np, "lcd");
+	if (id < 0) {
+		dev_err(dev, "no alias for lcd\n");
+		id = 0;
+	}
+	lcd = devm_kzalloc(dev, sizeof *lcd, GFP_KERNEL);
+	if (!lcd) {
+		dev_err(dev, "failed to allocate private data\n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(dev, lcd);
+	lcd->dev = dev;
+	lcd->num = id;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get memory resource\n");
+		return -EINVAL;
+	}
+
+	lcd->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(lcd->mmio)) {
+		dev_err(dev, "failed to map registers\n");
+		return PTR_ERR(lcd->mmio);
+	}
+
+	snprintf(lcd->name, sizeof(lcd->name), "sunxi-lcd%d", id);
+
+	/* possible CRTCs */
+	parent = np;
+	tmp = of_get_child_by_name(np, "ports");
+	if (tmp)
+		parent = tmp;
+	port = of_get_child_by_name(parent, "port");
+	of_node_put(tmp);
+	if (!port) {
+		dev_err(dev, "no port node\n");
+		return -ENXIO;
+	}
+	lcd->crtc.port = port;
+
+#if 0
+	lcd->gate = devm_clk_get(dev, "gate");		/* optional */
+//	if (IS_ERR(lcd->gate)) {
+//		dev_err(dev, "gate clock err %d\n", (int) PTR_ERR(lcd->gate));
+//		ret = PTR_ERR(lcd->gate);
+//		goto err;
+//	}
+#endif
+
+	lcd->clk = devm_clk_get(dev, "clock");
+	if (IS_ERR(lcd->clk)) {
+		dev_err(dev, "video clock err %d\n", (int) PTR_ERR(lcd->clk));
+		ret = PTR_ERR(lcd->clk);
+		goto err;
+	}
+
+#if 0
+	lcd->rstc = devm_reset_control_get_optional(dev, NULL);
+//	if (IS_ERR(lcd->rstc)) {
+//		dev_err(dev, "reset controller err %d\n",
+//				(int) PTR_ERR(lcd->rstc));
+//		ret = PTR_ERR(lcd->rstc);
+//		goto err;
+//	}
+#endif
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(dev, "unable to get irq lcd %d\n", id);
+		ret = -EINVAL;
+		goto err;
+	}
+
+#if 0
+	if (!IS_ERR(lcd->rstc)) {
+		ret = reset_control_deassert(lcd->rstc);
+		if (ret) {
+			dev_err(dev, "reset deassert err %d\n", ret);
+			goto err;
+		}
+	}
+
+	if (!IS_ERR(lcd->gate)) {
+		ret = clk_prepare_enable(lcd->gate);
+		if (ret)
+			goto err2;
+	}
+#endif
+
+	ret = clk_prepare_enable(lcd->clk);
+	if (ret)
+		goto err2;
+
+	de2_tcon_init(lcd);
+
+	ret = devm_request_irq(dev, irq, de2_lcd_irq, 0,
+				lcd->name, lcd);
+	if (ret < 0) {
+		dev_err(dev, "unable to request irq %d\n", irq);
+		goto err2;
+	}
+
+	return component_add(dev, &de2_lcd_ops);
+
+err2:
+#if 0
+	if (!IS_ERR_OR_NULL(lcd->rstc))
+		reset_control_assert(lcd->rstc);
+	clk_disable_unprepare(lcd->gate);
+#endif
+	clk_disable_unprepare(lcd->clk);
+err:
+	of_node_put(lcd->crtc.port);
+	return ret;
+}
+
+static int de2_lcd_remove(struct platform_device *pdev)
+{
+	struct lcd *lcd = platform_get_drvdata(pdev);
+
+	component_del(&pdev->dev, &de2_lcd_ops);
+
+#if 0
+	if (!IS_ERR_OR_NULL(lcd->rstc))
+		reset_control_assert(lcd->rstc);
+	clk_disable_unprepare(lcd->gate);
+#endif
+	clk_disable_unprepare(lcd->clk);
+	of_node_put(lcd->crtc.port);
+
+	return 0;
+}
+
+static const struct of_device_id de2_lcd_ids[] = {
+	{ .compatible = "allwinner,sun8i-a83t-lcd", },
+	{ }
+};
+
+struct platform_driver de2_lcd_platform_driver = {
+	.probe = de2_lcd_probe,
+	.remove = de2_lcd_remove,
+	.driver = {
+		.name = "sunxi-de2-lcd",
+		.of_match_table = of_match_ptr(de2_lcd_ids),
+	},
+};
diff --git a/drivers/gpu/drm/sunxi/de2_crtc.h b/drivers/gpu/drm/sunxi/de2_crtc.h
new file mode 100644
index 0000000..e9809ee
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_crtc.h
@@ -0,0 +1,68 @@
+#ifndef __DE2_CRTC_H__
+#define __DE2_CRTC_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <drm/drm_plane_helper.h>
+
+struct priv;
+
+enum de2_plane2 {
+	DE2_PRIMARY_PLANE,
+	DE2_CURSOR_PLANE,
+	DE2_VI_PLANE,
+// (only one overlay plane with my XV modesetting)
+//	DE2_UI_PLANE,
+	DE2_N_PLANES,
+};
+struct lcd {
+	void __iomem *mmio;
+
+	struct device *dev;
+	struct drm_crtc crtc;
+
+	struct priv *priv;	/* DRM/DE private data */
+
+	short num;		/* LCD number in hardware */
+	short crtc_idx;		/* CRTC index in drm */
+
+	struct clk *clk;
+#if 0
+	struct clk *gate;
+	struct reset_control *rstc;
+#endif
+
+	char name[16];
+
+	struct drm_pending_vblank_event *event;
+
+	struct drm_plane planes[DE2_N_PLANES];
+};
+
+#define crtc_to_lcd(x) container_of(x, struct lcd, crtc)
+
+/* in de2_de.c */
+void de2_de_enable(struct priv *priv, int lcd_num);
+void de2_de_disable(struct priv *priv, int lcd_num);
+void de2_de_hw_init(struct priv *priv, int lcd_num);
+void de2_de_dumb_panel_init(struct priv *priv, int lcd_num,
+			struct drm_display_mode *mode);
+void de2_de_plane_disable(struct priv *priv,
+			int lcd_num, int plane_ix);
+void de2_de_plane_update(struct priv *priv,
+			int lcd_num, int plane_ix,
+			struct drm_plane_state *state,
+			struct drm_plane_state *old_state);
+
+/* in de2_plane.c */
+int de2_plane_init(struct drm_device *drm, struct lcd *lcd);
+
+#endif /* __DE2_CRTC_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_de.c b/drivers/gpu/drm/sunxi/de2_de.c
new file mode 100644
index 0000000..e21886a
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_de.c
@@ -0,0 +1,660 @@
+/*
+ * ALLWINNER DRM driver - Display Engine 2
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Copyright (c) 2016 Allwinnertech Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <asm/io.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+static DEFINE_SPINLOCK(de_lock);
+
+//#define DE_CLK_RATE_A83T 504000000	/* pll-de */
+//#define DE_CLK_RATE_H3 432000000	/* de */
+
+/* I/O map */
+
+#define DE_MOD_REG 0x0000	/* 1 bit per LCD */
+#define DE_GATE_REG 0x0004
+#define DE_RESET_REG 0x0008
+#define DE_DIV_REG 0x000c	/* 4 bits per LCD */
+#define DE_SEL_REG 0x0010
+
+#define DE_MUX0_BASE 0x00100000
+#define DE_MUX1_BASE 0x00200000
+
+/* MUX registers (addr / MUX base) */
+#define DE_MUX_GLB_REGS 0x00000		/* global control */
+#define DE_MUX_BLD_REGS 0x01000		/* alpha blending */
+#define DE_MUX_CHAN_REGS 0x02000	/* VI/UI overlay channels */
+#define		DE_MUX_CHAN_SZ 0x1000	/* size of a channel */
+#define DE_MUX_VSU_REGS 0x20000		/* VSU */
+#define DE_MUX_GSU1_REGS 0x30000	/* GSUs */
+#define DE_MUX_GSU2_REGS 0x40000
+#define DE_MUX_GSU3_REGS 0x50000
+#define DE_MUX_FCE_REGS 0xa0000		/* FCE */
+#define DE_MUX_BWS_REGS 0xa2000		/* BWS */
+#define DE_MUX_LTI_REGS 0xa4000		/* LTI */
+#define DE_MUX_PEAK_REGS 0xa6000	/* PEAK */
+#define DE_MUX_ASE_REGS 0xa8000		/* ASE */
+#define DE_MUX_FCC_REGS 0xaa000		/* FCC */
+#define DE_MUX_DCSC_REGS 0xb0000	/* DCSC/SMBL */
+
+/* global control */
+struct de_glb {
+	u32 ctl;
+#define		DE_MUX_GLB_CTL_rt_en BIT(0)
+#define		DE_MUX_GLB_CTL_finish_irq_en BIT(4)
+#define		DE_MUX_GLB_CTL_rtwb_port BIT(12)
+	u32 status;
+	u32 dbuff;
+	u32 size;
+};
+
+/* alpha blending */
+struct de_bld {
+	u32 fcolor_ctl;			/* 00 */
+	struct {
+		u32 fcolor;
+		u32 insize;
+		u32 offset;
+		u32 dum;
+	} attr[4];
+	u32 dum0[15];			/* (end of clear offset) */
+	u32 route;			/* 80 */
+	u32 premultiply;
+	u32 bkcolor;
+	u32 output_size;
+	u32 bld_mode[4];
+	u32 dum1[4];
+	u32 ck_ctl;			/* b0 */
+//fixme: ck_mode << (clk_no * 4) - mode = (dir << 1) + en
+	u32 ck_cfg;
+//fixme: 7 << (clk_no * 8)
+	u32 dum2[2];
+	u32 ck_max[4];			/* c0 */
+//fixme fe0101
+	u32 dum3[4];
+	u32 ck_min[4];			/* e0 */
+//fixme fe0101
+	u32 dum4[3];
+	u32 out_ctl;			/* fc */
+};
+
+/* VI channel */
+struct de_vi {
+	struct {
+		u32 attr;
+#define			VI_CFG_ATTR_en BIT(0)
+#define			VI_CFG_ATTR_fcolor_en BIT(4)
+#define			VI_CFG_ATTR_fmt_SHIFT 8
+#define			VI_CFG_ATTR_fmt_MASK GENMASK(12, 8)
+#define			VI_CFG_ATTR_ui_sel BIT(15)
+#define			VI_CFG_ATTR_top_down BIT(23)
+		u32 size;
+		u32 coord;
+#define VI_N_PLANES 3
+		u32 pitch[VI_N_PLANES];
+		u32 top_laddr[VI_N_PLANES];
+		u32 bot_laddr[VI_N_PLANES];
+	} cfg[4];
+	u32 fcolor[4];			/* c0 */
+	u32 top_haddr[VI_N_PLANES];	/* d0 */
+	u32 bot_haddr[VI_N_PLANES];	/* dc */
+	u32 ovl_size[2];		/* e8 */
+	u32 hori[2];			/* f0 */
+	u32 vert[2];			/* f8 */
+};
+
+/* UI channel */
+struct de_ui {
+	struct {
+		u32 attr;
+#define			UI_CFG_ATTR_en BIT(0)
+#define			UI_CFG_ATTR_alpmod_SHIFT 1
+#define			UI_CFG_ATTR_alpmod_MASK GENMASK(2, 1)
+#define			UI_CFG_ATTR_fcolor_en BIT(4)
+#define			UI_CFG_ATTR_fmt_SHIFT 8
+#define			UI_CFG_ATTR_fmt_MASK GENMASK(12, 8)
+#define			UI_CFG_ATTR_top_down BIT(23)
+#define			UI_CFG_ATTR_alpha_SHIFT 24
+#define			UI_CFG_ATTR_alpha_MASK GENMASK(31, 24)
+		u32 size;
+		u32 coord;
+		u32 pitch;
+		u32 top_laddr;
+		u32 bot_laddr;
+		u32 fcolor;
+		u32 dum;
+	} cfg[4];			/* 00 */
+	u32 top_haddr;			/* 80 */
+	u32 bot_haddr;
+	u32 ovl_size;			/* 88 */
+};
+
+/* coordinates and sizes */
+#define XY(x, y) (((y) << 16) | (x))
+#define WH(w, h) (((h - 1) << 16) | (w - 1))
+
+/* UI video formats */
+#define DE2_FORMAT_ARGB_8888 0
+#define DE2_FORMAT_BGRA_8888 3
+#define DE2_FORMAT_XRGB_8888 4
+#define DE2_FORMAT_RGB_888 8
+#define DE2_FORMAT_BGR_888 9
+
+/* VI video formats */
+#define DE2_FORMAT_YUV422_I_YVYU 1	/* Y-V-Y-U */
+#define DE2_FORMAT_YUV422_I_UYVY 2	/* U-Y-V-Y */
+#define DE2_FORMAT_YUV422_I_YUYV 3	/* Y-U-Y-V */
+#define DE2_FORMAT_YUV422_P 6		/* YYYY UU VV planar */
+#define DE2_FORMAT_YUV420_P 10		/* YYYY U V planar */
+
+#define glb_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_glb, member))
+#define glb_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_glb, member))
+#define bld_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_bld, member))
+#define bld_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_bld, member))
+#define ui_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_ui, member))
+#define ui_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_ui, member))
+#define vi_read(base, member) \
+	readl_relaxed(base + offsetof(struct de_vi, member))
+#define vi_write(base, member, data) \
+	writel_relaxed(data, base + offsetof(struct de_vi, member))
+
+static const struct {
+	char chan;
+	char layer;
+	char pipe;
+} plane2layer[DE2_N_PLANES] = {
+	[DE2_PRIMARY_PLANE] =	{0, 0, 0},
+	[DE2_CURSOR_PLANE] =	{1, 0, 1},
+	[DE2_VI_PLANE] =	{0, 1, 0},
+};
+
+static inline void de_write(struct priv *priv, int reg, u32 data)
+{
+	writel_relaxed(data, priv->mmio + reg);
+}
+
+static inline u32 de_read(struct priv *priv, int reg)
+{
+	return readl_relaxed(priv->mmio + reg);
+}
+
+static void de_lcd_select(struct priv *priv,
+			int lcd_num,
+			void __iomem *mux_o)
+{
+	u32 data;
+
+	/* select the LCD */
+	data = de_read(priv, DE_SEL_REG);
+#if 1 // test -> ok
+//fix: use lcd->idx (?)
+	data &= ~1;
+#else
+	if (lcd_num == 0)
+		data &= ~1;
+	else
+		data |= 1;
+#endif
+	de_write(priv, DE_SEL_REG, data);
+
+	/* double register switch */
+	glb_write(mux_o + DE_MUX_GLB_REGS, dbuff, 1);
+}
+
+void de2_de_plane_update(struct priv *priv,
+			int lcd_num, int plane_ix,
+			struct drm_plane_state *state,
+			struct drm_plane_state *old_state)
+{
+	struct drm_framebuffer *fb = state->fb;
+	struct drm_gem_cma_object *gem;
+	void __iomem *mux_o = priv->mmio;
+	void __iomem *chan_o;
+	u32 size = WH(state->crtc_w, state->crtc_h);
+	u32 coord;
+	u32 screen_size;
+	u32 data, fcolor;
+	u32 ui_sel, alpha_glob;
+	int chan, layer, x, y;
+	unsigned fmt;
+	unsigned long flags;
+
+	chan = plane2layer[plane_ix].chan;
+	layer = plane2layer[plane_ix].layer;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+	chan_o = mux_o;
+	chan_o += DE_MUX_CHAN_REGS + DE_MUX_CHAN_SZ * chan;
+
+	x = state->crtc_x >= 0 ? state->crtc_x : 0;
+	y = state->crtc_y >= 0 ? state->crtc_y : 0;
+	coord = XY(x, y);
+
+	/* handle the cursor move */
+	if (plane_ix == DE2_CURSOR_PLANE
+	 && fb == old_state->fb) {
+		spin_lock_irqsave(&de_lock, flags);
+		de_lcd_select(priv, lcd_num, mux_o);
+		if (chan == 0)
+			vi_write(chan_o, cfg[layer].coord, coord);
+		else
+			ui_write(chan_o, cfg[layer].coord, coord);
+		spin_unlock_irqrestore(&de_lock, flags);
+		return;
+	}
+
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
+#if 1
+//test overlay
+if (plane_ix == DE2_VI_PLANE && vi_read(chan_o, cfg[layer].attr) == 0) {
+//	DRM_DEBUG_DRIVER("%d:%d %dx%d+%d+%d %.4s\n",
+	pr_info("%d:%d %dx%d+%d+%d %.4s\n",
+			lcd_num, plane_ix,
+			state->crtc_w, state->crtc_h,
+			x, y,
+			(char *) &fb->pixel_format);
+//pr_info("plane_update %d init\n", plane_ix);
+//print_hex_dump(KERN_INFO, "buf: ", DUMP_PREFIX_OFFSET,
+// 32, 1, gem->vaddr, 32, false);
+}
+#endif
+
+	ui_sel = alpha_glob = 0;
+	switch (fb->pixel_format) {
+	case DRM_FORMAT_ARGB8888:
+		fmt = DE2_FORMAT_ARGB_8888;
+		ui_sel = VI_CFG_ATTR_ui_sel;
+		break;
+	case DRM_FORMAT_BGRA8888:
+		fmt = DE2_FORMAT_BGRA_8888;
+		ui_sel = VI_CFG_ATTR_ui_sel;
+		break;
+	case DRM_FORMAT_XRGB8888:
+		fmt = DE2_FORMAT_XRGB_8888;
+		ui_sel = VI_CFG_ATTR_ui_sel;
+		alpha_glob = (1 << UI_CFG_ATTR_alpmod_SHIFT) |
+				(0xff << UI_CFG_ATTR_alpha_SHIFT);
+		break;
+	case DRM_FORMAT_RGB888:
+		fmt = DE2_FORMAT_RGB_888;
+		ui_sel = VI_CFG_ATTR_ui_sel;
+		break;
+	case DRM_FORMAT_BGR888:
+		fmt = DE2_FORMAT_BGR_888;
+		ui_sel = VI_CFG_ATTR_ui_sel;
+		break;
+	case DRM_FORMAT_YUYV:
+		fmt = DE2_FORMAT_YUV422_I_YUYV;
+		break;
+	case DRM_FORMAT_YVYU:
+		fmt = DE2_FORMAT_YUV422_I_YVYU;
+		break;
+	case DRM_FORMAT_YUV422:
+		fmt = DE2_FORMAT_YUV422_P;
+		break;
+	case DRM_FORMAT_YUV420:
+		fmt = DE2_FORMAT_YUV420_P;
+		break;
+	case DRM_FORMAT_UYVY:
+		fmt = DE2_FORMAT_YUV422_I_UYVY;
+		break;
+	default:
+		pr_err("format %.4s not yet treated\n",
+			(char *) &fb->pixel_format);
+		return;
+	}
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	screen_size = plane_ix == DE2_PRIMARY_PLANE ?
+			size :
+			glb_read(mux_o + DE_MUX_GLB_REGS, size);
+
+	/* prepare the activation of alpha blending (1 bit per plane) */
+	fcolor = bld_read(mux_o + DE_MUX_BLD_REGS, fcolor_ctl)
+			| (0x100 << plane2layer[plane_ix].pipe);
+//test
+//pr_info("** DE pl: %d ch: %d ly: %d pi: %d fcolor: %04x\n",
+// plane_ix, chan, layer, plane2layer[plane_ix].pipe, fcolor);
+
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	if (chan == 0) {	/* VI channel */
+		int i;
+
+		data = VI_CFG_ATTR_en | (fmt << VI_CFG_ATTR_fmt_SHIFT) |
+					ui_sel;
+		vi_write(chan_o, cfg[layer].attr, data);
+		vi_write(chan_o, cfg[layer].size, size);
+		vi_write(chan_o, cfg[layer].coord, coord);
+		for (i = 0; i < VI_N_PLANES; i++) {
+			vi_write(chan_o, cfg[layer].pitch[i],
+					fb->pitches[i] ? fb->pitches[i] :
+							fb->pitches[0]);
+			vi_write(chan_o, cfg[layer].top_laddr[i],
+				gem->paddr + fb->offsets[i]);
+			vi_write(chan_o, fcolor[layer], 0xff000000);
+		}
+		if (layer == 0)
+			vi_write(chan_o, ovl_size[0], screen_size);
+
+	} else {		/* UI channel */
+		data = UI_CFG_ATTR_en | (fmt << UI_CFG_ATTR_fmt_SHIFT) |
+			alpha_glob;
+		ui_write(chan_o, cfg[layer].attr, data);
+		ui_write(chan_o, cfg[layer].size, size);
+		ui_write(chan_o, cfg[layer].coord, coord);
+		ui_write(chan_o, cfg[layer].pitch, fb->pitches[0]);
+		ui_write(chan_o, cfg[layer].top_laddr,
+				gem->paddr + fb->offsets[0]);
+		if (layer == 0)
+			ui_write(chan_o, ovl_size, screen_size);
+	}
+	bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl, fcolor);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_plane_disable(struct priv *priv,
+			int lcd_num, int plane_ix)
+{
+	void __iomem *mux_o = priv->mmio;
+	void __iomem *chan_o;
+	u32 fcolor;
+	int chan, layer, chan_disable = 0;
+	unsigned long flags;
+
+	chan = plane2layer[plane_ix].chan;
+	layer = plane2layer[plane_ix].layer;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+	chan_o = mux_o;
+	chan_o += DE_MUX_CHAN_REGS + DE_MUX_CHAN_SZ * chan;
+
+	/* (only 2 layers) */
+	if (chan == 0) {
+		if (vi_read(chan_o, cfg[1 - layer].attr) == 0)
+			chan_disable = 1;
+	} else {
+		if (ui_read(chan_o, cfg[1 - layer].attr) == 0)
+			chan_disable = 1;
+	}
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	fcolor = bld_read(mux_o + DE_MUX_BLD_REGS, fcolor_ctl);
+
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	if (chan == 0)
+		vi_write(chan_o, cfg[layer].attr, 0);
+	else
+		ui_write(chan_o, cfg[layer].attr, 0);
+
+	if (chan_disable)
+		bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl,
+			fcolor & ~(0x100 << plane2layer[plane_ix].pipe));
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_dumb_panel_init(struct priv *priv, int lcd_num,
+			struct drm_display_mode *mode)
+{
+	void __iomem *mux_o = priv->mmio;
+	u32 size = WH(mode->hdisplay, mode->vdisplay);
+	unsigned i;
+	unsigned long flags;
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+
+	DRM_DEBUG_DRIVER("%dx%d\n", mode->hdisplay, mode->vdisplay);
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	de_lcd_select(priv, lcd_num, mux_o);
+
+	glb_write(mux_o + DE_MUX_GLB_REGS, size, size);
+
+	/* set alpha blending */
+	for (i = 0; i < 4; i++) {
+// from FriendlyARM
+		bld_write(mux_o + DE_MUX_BLD_REGS, attr[i].fcolor, 0xff000000);
+		bld_write(mux_o + DE_MUX_BLD_REGS, attr[i].insize, size);
+	}
+	bld_write(mux_o + DE_MUX_BLD_REGS, output_size, size);
+	bld_write(mux_o + DE_MUX_BLD_REGS, out_ctl,
+			mode->flags & DRM_MODE_FLAG_INTERLACE ? 2 : 0);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_enable(struct priv *priv, int lcd_num)
+{
+	void __iomem *mux_o = priv->mmio;
+	unsigned chan, i;
+	u32 size = WH(1920, 1080);
+	u32 data;
+	unsigned long flags;
+
+	DRM_DEBUG_DRIVER("lcd %d\n", lcd_num);
+
+#if 0 // moved to probe
+	/* set the A83T clock divider = 500 / 250 */
+	if (priv->soc_type == SOC_A83T) {
+		data = de_read(priv, DE_DIV_REG);
+//fixme: should div for both lcd0 and 1 ...
+		data &= ~(0x0f << lcd_num * 4);
+		data |= 1 << lcd_num * 4;		/* div = 2 */
+		de_write(priv, DE_DIV_REG, data);
+	}
+#endif
+
+	de_write(priv, DE_RESET_REG,
+			de_read(priv, DE_RESET_REG) |
+				(lcd_num == 0 ? 1 : 4));
+	data = 1 << lcd_num;			/* 1 bit / lcd */
+	de_write(priv, DE_GATE_REG,
+			de_read(priv, DE_GATE_REG) | data);
+	de_write(priv, DE_MOD_REG,
+			de_read(priv, DE_MOD_REG) | data);
+
+	mux_o += (lcd_num == 0) ? DE_MUX0_BASE : DE_MUX1_BASE;
+
+	spin_lock_irqsave(&de_lock, flags);
+
+	/* select the LCD */
+	data = de_read(priv, DE_SEL_REG);
+	if (lcd_num == 0)
+		data &= ~1;
+	else
+		data |= 1;
+	de_write(priv, DE_SEL_REG, data);
+
+	/* start init */
+	glb_write(mux_o + DE_MUX_GLB_REGS, ctl,
+		DE_MUX_GLB_CTL_rt_en | DE_MUX_GLB_CTL_rtwb_port);
+	glb_write(mux_o + DE_MUX_GLB_REGS, status, 0);
+	glb_write(mux_o + DE_MUX_GLB_REGS, dbuff, 1);	/* dble reg switch */
+	glb_write(mux_o + DE_MUX_GLB_REGS, size, size);
+
+	/* clear the VI/UI channels */
+	for (chan = 0; chan < 4; chan++) {
+		void __iomem *chan_o = mux_o + DE_MUX_CHAN_REGS +
+				DE_MUX_CHAN_SZ * chan;
+
+		memset_io(chan_o, 0, chan == 0 ?
+				sizeof(struct de_vi) : sizeof(struct de_ui));
+
+		/* only 1 VI and 1 UI in lcd1 */
+		if (chan == 2 && lcd_num == 1)
+			break;
+	}
+
+	/* clear and set alpha blending */
+	memset_io(mux_o + DE_MUX_BLD_REGS, 0, offsetof(struct de_bld, dum0));
+	bld_write(mux_o + DE_MUX_BLD_REGS, fcolor_ctl, 0x00000101);
+						/* fcolor for primary */
+
+	/* prepare route for planes */
+//	bld_write(mux_o + DE_MUX_BLD_REGS, route, 0x0021);
+//	bld_write(mux_o + DE_MUX_BLD_REGS, route, 0x0001);
+//	bld_write(mux_o + DE_MUX_BLD_REGS, route, 0x0201);
+	data = 0;
+	for (i = 0; i < DE2_N_PLANES; i++)
+		data |= plane2layer[i].chan << (plane2layer[i].pipe * 4);
+	bld_write(mux_o + DE_MUX_BLD_REGS, route, data);
+
+	bld_write(mux_o + DE_MUX_BLD_REGS, premultiply, 0);
+	bld_write(mux_o + DE_MUX_BLD_REGS, bkcolor, 0xff000000);
+//16-10-08 done later in dumb_panel_init()
+//	bld_write(mux_o + DE_MUX_BLD_REGS, output_size, size);
+	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[0], 0x03010301);
+								/* SRCOVER */
+	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[1], 0x03010301);
+//	bld_write(mux_o + DE_MUX_BLD_REGS, bld_mode[2], 0x03010301);
+	bld_write(mux_o + DE_MUX_BLD_REGS, out_ctl, 0);
+
+	/* disable the enhancements */
+	writel_relaxed(0, mux_o + DE_MUX_VSU_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU1_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU2_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_GSU3_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_FCE_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_BWS_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_LTI_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_PEAK_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_ASE_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_FCC_REGS);
+	writel_relaxed(0, mux_o + DE_MUX_DCSC_REGS);
+
+	spin_unlock_irqrestore(&de_lock, flags);
+}
+
+void de2_de_disable(struct priv *priv, int lcd_num)
+{
+	u32 data;
+
+	data = ~(1 << lcd_num);
+	de_write(priv, DE_MOD_REG,
+			de_read(priv, DE_MOD_REG) & data);
+	de_write(priv, DE_GATE_REG,
+			de_read(priv, DE_GATE_REG) & data);
+	de_write(priv, DE_RESET_REG,
+			de_read(priv, DE_RESET_REG) & data);
+}
+
+int de2_de_init(struct priv *priv, struct device *dev)
+{
+	struct resource *res;
+	int ret;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	res = platform_get_resource(to_platform_device(dev),
+				IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get memory resource\n");
+		return -EINVAL;
+	}
+
+	priv->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->mmio)) {
+		dev_err(dev, "failed to map registers\n");
+		return PTR_ERR(priv->mmio);
+	}
+
+#if 0
+	priv->gate = devm_clk_get(dev, "gate");	/* optional */
+//	if (IS_ERR(priv->gate)) {
+//		dev_err(dev, "gate clock err %d\n", (int) PTR_ERR(priv->gate));
+//		return PTR_ERR(priv->gate);
+//	}
+#endif
+
+	priv->clk = devm_clk_get(dev, "clock");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "video clock err %d\n", (int) PTR_ERR(priv->clk));
+		return PTR_ERR(priv->clk);
+	}
+
+#if 0
+	priv->rstc = devm_reset_control_get_optional(dev, NULL);
+//	if (IS_ERR(priv->rstc)) {
+//		dev_err(dev, "reset controller err %d\n",
+//				(int) PTR_ERR(priv->rstc));
+//		return PTR_ERR(priv->rstc);
+//	}
+
+	/* in order, do: de-assert, enable bus, enable clock */
+	if (!IS_ERR(priv->rstc)) {
+		ret = reset_control_deassert(priv->rstc);
+		if (ret) {
+			dev_err(dev, "reset deassert err %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (!IS_ERR(priv->gate)) {
+		ret = clk_prepare_enable(priv->gate);
+		if (ret)
+			goto err_gate;
+	}
+#endif
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		goto err_enable;
+// done in DT
+//	if (priv->soc_type == SOC_A83T)
+//		clk_set_rate(priv->clk, DE_CLK_RATE_A83T);
+//	else
+//		clk_set_rate(priv->clk, DE_CLK_RATE_H3);
+
+#if 1 // moved from enable
+	/* set the A83T clock divider = 500 / 250 */
+	if (priv->soc_type == SOC_A83T)
+		de_write(priv, DE_DIV_REG,
+				0x00000011);	/* div = 2 for both LCDs */
+#endif
+
+	return 0;
+
+err_enable:
+#if 0
+	clk_disable_unprepare(priv->gate);
+err_gate:
+	if (!IS_ERR(priv->rstc))
+		reset_control_assert(priv->rstc);
+#endif
+	return ret;
+}
+
+void de2_de_cleanup(struct priv *priv)
+{
+	clk_disable_unprepare(priv->clk);
+#if 0
+	clk_disable_unprepare(priv->gate);
+	if (!IS_ERR(priv->rstc))
+		reset_control_assert(priv->rstc);
+#endif
+}
diff --git a/drivers/gpu/drm/sunxi/de2_drm.h b/drivers/gpu/drm/sunxi/de2_drm.h
new file mode 100644
index 0000000..66ba5cb
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_drm.h
@@ -0,0 +1,52 @@
+#ifndef __DE2_DRM_H__
+#define __DE2_DRM_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <drm/drmP.h>
+#include <drm/drm_fb_cma_helper.h>
+
+struct lcd;
+
+#define N_LCDS 2
+
+/* SoC types */
+#define SOC_A83T 0
+#define SOC_H3 1
+
+struct priv {
+	struct drm_device drm;
+	void __iomem *mmio;
+	struct clk *clk;
+#if 0
+	struct clk *gate;
+	struct reset_control *rstc;
+#endif
+
+	int soc_type;
+
+	struct drm_fbdev_cma *fbdev;
+
+	struct lcd *lcds[N_LCDS];
+};
+
+#define drm_to_priv(x) container_of(x, struct priv, drm)
+
+/* in de2_crtc.c */
+int de2_enable_vblank(struct drm_device *drm, unsigned crtc);
+void de2_disable_vblank(struct drm_device *drm, unsigned crtc);
+extern struct platform_driver de2_lcd_platform_driver;
+
+/* in de2_de.c */
+int de2_de_init(struct priv *priv, struct device *dev);
+void de2_de_cleanup(struct priv *priv);
+
+#endif /* __DE2_DRM_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_drv.c b/drivers/gpu/drm/sunxi/de2_drv.c
new file mode 100644
index 0000000..c860f69
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_drv.c
@@ -0,0 +1,381 @@
+/*
+ * Allwinner DRM driver - DE2 DRM driver
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+//#include <linux/pm.h>
+//#include <linux/pm_runtime.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/component.h>
+#include <drm/drm_of.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_gem_cma_helper.h>
+
+#include "de2_drm.h"
+
+#define DRIVER_NAME	"sunxi-de2"
+#define DRIVER_DESC	"Allwinner DRM DE2"
+#define DRIVER_DATE	"20161001"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static struct of_device_id de2_drm_of_match[] = {
+	{ .compatible = "allwinner,sun8i-a83t-display-engine",
+				.data = (void *) SOC_A83T },
+	{ .compatible = "allwinner,sun8i-h3-display-engine",
+				.data = (void *) SOC_H3 },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, de2_drm_of_match);
+
+static void de2_fb_output_poll_changed(struct drm_device *drm)
+{
+	struct priv *priv = drm_to_priv(drm);
+
+	if (priv->fbdev)
+		drm_fbdev_cma_hotplug_event(priv->fbdev);
+}
+
+static const struct drm_mode_config_funcs de2_mode_config_funcs = {
+	.fb_create = drm_fb_cma_create,
+	.output_poll_changed = de2_fb_output_poll_changed,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+/*
+ * DRM operations:
+ */
+static void de2_lastclose(struct drm_device *drm)
+{
+	struct priv *priv = drm_to_priv(drm);
+
+	if (priv->fbdev)
+		drm_fbdev_cma_restore_mode(priv->fbdev);
+}
+
+static const struct file_operations de2_fops = {
+	.owner		= THIS_MODULE,
+	.open		= drm_open,
+	.release	= drm_release,
+	.unlocked_ioctl	= drm_ioctl,
+	.poll		= drm_poll,
+	.read		= drm_read,
+	.llseek		= no_llseek,
+	.mmap		= drm_gem_cma_mmap,
+};
+
+static struct drm_driver de2_drm_driver = {
+	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_PRIME |
+					DRIVER_ATOMIC,
+	.lastclose		= de2_lastclose,
+	.get_vblank_counter	= drm_vblank_no_hw_counter,
+	.enable_vblank		= de2_enable_vblank,
+	.disable_vblank		= de2_disable_vblank,
+	.gem_free_object	= drm_gem_cma_free_object,
+	.gem_vm_ops		= &drm_gem_cma_vm_ops,
+	.prime_handle_to_fd	= drm_gem_prime_handle_to_fd,
+	.prime_fd_to_handle	= drm_gem_prime_fd_to_handle,
+	.gem_prime_import	= drm_gem_prime_import,
+	.gem_prime_export	= drm_gem_prime_export,
+	.gem_prime_get_sg_table	= drm_gem_cma_prime_get_sg_table,
+	.gem_prime_import_sg_table = drm_gem_cma_prime_import_sg_table,
+	.gem_prime_vmap		= drm_gem_cma_prime_vmap,
+	.gem_prime_vunmap	= drm_gem_cma_prime_vunmap,
+	.gem_prime_mmap		= drm_gem_cma_prime_mmap,
+	.dumb_create		= drm_gem_cma_dumb_create,
+	.dumb_map_offset	= drm_gem_cma_dumb_map_offset,
+	.dumb_destroy		= drm_gem_dumb_destroy,
+	.fops			= &de2_fops,
+	.name			= DRIVER_NAME,
+	.desc			= DRIVER_DESC,
+	.date			= DRIVER_DATE,
+	.major			= DRIVER_MAJOR,
+	.minor			= DRIVER_MINOR,
+};
+
+#if 0 //def CONFIG_PM_SLEEP
+/*
+ * Power management
+ */
+static int de2_pm_suspend(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_disable(drm);
+	return 0;
+}
+
+static int de2_pm_resume(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+
+	drm_kms_helper_poll_enable(drm);
+	return 0;
+}
+#endif
+
+//static const struct dev_pm_ops de2_pm_ops = {
+//	SET_SYSTEM_SLEEP_PM_OPS(de2_pm_suspend, de2_pm_resume)
+//};
+
+/*
+ * Platform driver
+ */
+
+static int de2_drm_bind(struct device *dev)
+{
+	struct drm_device *drm;
+	struct priv *priv;
+	int ret;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(dev, "out of memory\n");
+		return -ENOMEM;
+	}
+
+	drm = &priv->drm;
+	dev_set_drvdata(dev, drm);
+
+	ret = drm_dev_init(drm, &de2_drm_driver, dev);
+	if (ret != 0) {
+		dev_err(dev, "out of memory\n");
+		goto out1;
+	}
+
+	drm_mode_config_init(drm);
+	drm->mode_config.min_width = 32;	/* needed for cursor */
+	drm->mode_config.min_height = 32;
+	drm->mode_config.max_width = 1920;
+	drm->mode_config.max_height = 1080;
+	drm->mode_config.funcs = &de2_mode_config_funcs;
+
+	drm->irq_enabled = true;
+
+	/* initialize the display engine */
+	priv->soc_type = (int) of_match_device(de2_drm_of_match, dev)->data;
+	ret = de2_de_init(priv, dev);
+	if (ret)
+		goto out2;
+
+	/* start the subdevices */
+	ret = component_bind_all(dev, drm);
+	if (ret < 0)
+		goto out2;
+
+//	ret = drm_dev_register(drm, 0);
+//	if (ret < 0)
+//		goto out3;
+
+//	DRM_DEBUG_DRIVER("%d crtcs %d connectors\n",
+//			 drm->mode_config.num_crtc,
+//			 drm->mode_config.num_connector);
+
+	ret = drm_vblank_init(drm, drm->mode_config.num_crtc);
+	if (ret < 0)
+		dev_warn(dev, "failed to initialize vblank\n");
+
+	drm_mode_config_reset(drm);
+
+	priv->fbdev = drm_fbdev_cma_init(drm,
+					32,	/* bpp */
+					drm->mode_config.num_crtc,
+					drm->mode_config.num_connector);
+	if (IS_ERR(priv->fbdev)) {
+		ret = PTR_ERR(priv->fbdev);
+		priv->fbdev = NULL;
+		goto out3;
+	}
+
+	drm_kms_helper_poll_init(drm);
+
+	ret = drm_dev_register(drm, 0);
+	if (ret < 0)
+		goto out4;
+
+	return 0;
+
+out4:
+	drm_fbdev_cma_fini(priv->fbdev);
+out3:
+	component_unbind_all(dev, drm);
+out2:
+//--???
+//	drm_dev_unref(drm);
+out1:
+	kfree(priv);
+	return ret;
+}
+
+static void de2_drm_unbind(struct device *dev)
+{
+	struct drm_device *drm = dev_get_drvdata(dev);
+	struct priv *priv = drm_to_priv(drm);
+
+	drm_dev_unregister(drm);
+
+	drm_fbdev_cma_fini(priv->fbdev);
+	drm_kms_helper_poll_fini(drm);
+	drm_vblank_cleanup(drm);
+	drm_mode_config_cleanup(drm);
+
+	component_unbind_all(dev, drm);
+
+	de2_de_cleanup(priv);
+
+//--???
+//	drm_dev_unref(drm);
+	kfree(priv);
+}
+
+static const struct component_master_ops de2_drm_comp_ops = {
+	.bind = de2_drm_bind,
+	.unbind = de2_drm_unbind,
+};
+
+static int compare_of(struct device *dev, void *data)
+{
+	return dev->of_node == data;
+}
+
+static int de2_drm_add_components(struct device *dev,
+				  int (*compare_of)(struct device *, void *),
+				  const struct component_master_ops *m_ops)
+{
+	struct device_node *ep, *port, *remote;
+	struct component_match *match = NULL;
+	int i;
+
+	if (!dev->of_node)
+		return -EINVAL;
+
+	/* bind the CRTCs */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		component_match_add(dev, &match, compare_of, port->parent);
+		of_node_put(port);
+	}
+
+	if (i == 0) {
+		dev_err(dev, "missing 'ports' property\n");
+		return -ENODEV;
+	}
+	if (!match) {
+		dev_err(dev, "no available port\n");
+		return -ENODEV;
+	}
+
+	/* bind the encoders/connectors */
+	for (i = 0; ; i++) {
+		port = of_parse_phandle(dev->of_node, "ports", i);
+		if (!port)
+			break;
+
+		if (!of_device_is_available(port->parent)) {
+			of_node_put(port);
+			continue;
+		}
+
+		for_each_child_of_node(port, ep) {
+			remote = of_graph_get_remote_port_parent(ep);
+			if (!remote || !of_device_is_available(remote)) {
+				of_node_put(remote);
+				continue;
+			}
+			if (!of_device_is_available(remote->parent)) {
+				dev_warn(dev,
+					"parent device of %s is not available\n",
+					remote->full_name);
+				of_node_put(remote);
+				continue;
+			}
+
+			component_match_add(dev, &match, compare_of, remote);
+			of_node_put(remote);
+		}
+		of_node_put(port);
+	}
+
+	return component_master_add_with_match(dev, m_ops, match);
+}
+
+static int de2_drm_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = de2_drm_add_components(&pdev->dev,
+				     compare_of,
+				     &de2_drm_comp_ops);
+	if (ret == -EINVAL)
+		ret = -ENXIO;
+	return ret;
+}
+
+static int de2_drm_remove(struct platform_device *pdev)
+{
+	component_master_del(&pdev->dev, &de2_drm_comp_ops);
+
+	return 0;
+}
+
+static struct platform_driver de2_drm_platform_driver = {
+	.probe      = de2_drm_probe,
+	.remove     = de2_drm_remove,
+	.driver     = {
+		.name = DRIVER_NAME,
+//		.pm = &de2_pm_ops,
+		.of_match_table = de2_drm_of_match,
+	},
+};
+
+static int __init de2_drm_init(void)
+{
+	int ret;
+
+/* uncomment to activate the drm traces at startup time */
+/*	drm_debug = DRM_UT_CORE | DRM_UT_DRIVER | DRM_UT_KMS |
+			DRM_UT_PRIME | DRM_UT_ATOMIC; */
+
+	DRM_DEBUG_DRIVER("\n");
+
+	ret = platform_driver_register(&de2_lcd_platform_driver);
+	if (ret < 0)
+		return ret;
+
+	ret = platform_driver_register(&de2_drm_platform_driver);
+	if (ret < 0)
+		platform_driver_unregister(&de2_lcd_platform_driver);
+
+	return ret;
+}
+
+static void __exit de2_drm_fini(void)
+{
+	platform_driver_unregister(&de2_lcd_platform_driver);
+	platform_driver_unregister(&de2_drm_platform_driver);
+}
+
+module_init(de2_drm_init);
+module_exit(de2_drm_fini);
+
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_DESCRIPTION("Allwinner DE2 DRM Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/sunxi/de2_hdmi_io.c b/drivers/gpu/drm/sunxi/de2_hdmi_io.c
new file mode 100644
index 0000000..1def23b
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_hdmi_io.c
@@ -0,0 +1,1054 @@
+/*
+ * Allwinner A83T and H3 HDMI lowlevel functions
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Copyright (c) 2016 Allwinnertech Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+/*
+ * The HDMI controller in the A83T and H3 seems to be a
+ * Synopsys DesignWare HDMI controller.
+ * The PHYs are unknown.
+ * Documentation:
+ *	https://linux-sunxi.org/DWC_HDMI_Controller
+ *	https://www.synopsys.com/dw/doc.php/ds/c/dwc_hdmi_tx_csds.pdf
+ * PHY (H3):
+ *	10000: ?
+ *		01
+ *	10001:
+ *		03 or 00
+ *	10002:
+ *		100+5 = 0x69
+ *	10003:
+ *		00
+ *	10007: (a83t only)
+ *		init: a0, stanby: 20
+ *	10010: HDMI_LOCK
+ *	10020: HDMI_H3_PHY_CTRL
+ *		00000001: enable ?
+ *		00000002: ??
+ *		00000004: ??
+ *		00000008: ??
+ *		00000070: ??
+ *		00000080: ??
+ *		0000f000: video enable
+ *		00010000: ??
+ *		00040000: ??
+ *		00080000: ??
+ *		init: 01ff0f7f
+ *	10024:
+ *		init: 80639000
+ *	10028:
+ *		init: 0f81c405
+ *	1002c:
+ *		init: 39dc5040, | 02000000, | (parts of 10038)
+ *	10030: HDMI_H3_PHY_CLK (clock divider parent PLL3 (video)
+ *		init: 80084343
+ *	10034:
+ *		init:00000001
+ *	10038: HDMI_H3_PHY_STATUS
+ *		00000080: reset ok ?
+ *		0001f800: ? -> (>> 11) | 1002c
+ *		00080000: HPD status
+ *		c0000000: ?? -> | 1002c
+ */
+
+#include <linux/hdmi.h>
+
+#include "de2_hdmi.h"
+#include "de2_hdmi_io.h"
+
+/* DW registers (obfuscated addresses) */
+
+/* Interrupt Registers */
+#define R_0100_HDMI_IH_FC_STAT0 0x0010
+#define R_0101_HDMI_IH_FC_STAT1 0x0011
+#define R_0102_HDMI_IH_FC_STAT2 0x8010
+#define R_0103_HDMI_IH_AS_STAT0 0x8011
+#define R_0104_HDMI_IH_PHY_STAT0 0x0012
+#define R_0105_HDMI_IH_I2CM_STAT0 0x0013
+#define R_0106_HDMI_IH_CEC_STAT0 0x8012
+#define R_0107_HDMI_IH_VP_STAT0 0x8013
+#define R_0108_HDMI_IH_I2CMPHY_STAT0 0x4010
+#define R_01ff_HDMI_IH_MUTE 0xf01f
+
+/* Video Sample Registers */
+#define R_0200_HDMI_TX_INVID0 0x0800
+#define R_0201_HDMI_TX_INSTUFFING 0x0801
+#define R_0202_HDMI_TX_GYDATA0 0x8800
+#define R_0203_HDMI_TX_GYDATA1 0x8801
+#define R_0204_HDMI_TX_RCRDATA0 0x0802
+#define R_0205_HDMI_TX_RCRDATA1 0x0803
+#define R_0206_HDMI_TX_BCBDATA0 0x8802
+#define R_0207_HDMI_TX_BCBDATA1 0x8803
+
+/* Video Packetizer Registers */
+#define R_0801_HDMI_VP_PR_CD 0x0401
+#define R_0802_HDMI_VP_STUFF 0x8400
+#define R_0803_HDMI_VP_REMAP 0x8401
+#define R_0804_HDMI_VP_CONF 0x0402
+#define R_0807_HDMI_VP_MASK 0x8403
+
+/* Frame Composer Registers */
+#define R_1000_HDMI_FC_INVIDCONF 0x0040
+#define		HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH 0x10
+#define R_1001_HDMI_FC_INHACTV0 0x0041
+#define R_1002_HDMI_FC_INHACTV1 0x8040
+#define R_1003_HDMI_FC_INHBLANK0 0x8041
+#define R_1004_HDMI_FC_INHBLANK1 0x0042
+#define R_1005_HDMI_FC_INVACTV0 0x0043
+#define R_1006_HDMI_FC_INVACTV1 0x8042
+#define R_1007_HDMI_FC_INVBLANK 0x8043
+#define R_1008_HDMI_FC_HSYNCINDELAY0 0x4040
+#define R_1009_HDMI_FC_HSYNCINDELAY1 0x4041
+#define R_100a_HDMI_FC_HSYNCINWIDTH1 0xc040
+#define R_100b_HDMI_FC_HSYNCINWIDTH1 0xc041
+#define R_100c_HDMI_FC_VSYNCINDELAY 0x4042
+#define R_100d_HDMI_FC_VSYNCINWIDTH 0x4043
+#define R_1011_HDMI_FC_CTRLDUR 0x0045
+#define R_1012_HDMI_FC_EXCTRLDUR 0x8044
+#define R_1013_HDMI_FC_EXCTRLSPAC 0x8045
+#define R_1014_HDMI_FC_CH0PREAM 0x0046
+#define R_1015_HDMI_FC_CH1PREAM 0x0047
+#define R_1016_HDMI_FC_CH2PREAM 0x8046
+#define R_1018_HDMI_FC_GCP 0x4044
+#define R_1019_HDMI_FC_AVICONF0 0x4045
+#define		HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN 0x20
+#define R_101a_HDMI_FC_AVICONF1 0xc044
+#define R_101b_HDMI_FC_AVICONF2 0xc045
+#define R_101c_HDMI_FC_AVIVID 0x4046
+#define R_1025_HDMI_FC_AUDICONF0 0x2043
+#define R_1026_HDMI_FC_AUDICONF1 0xa042
+#define R_1027_HDMI_FC_AUDICONF2 0xa043
+#define R_1028_HDMI_FC_AUDICONF3 0x6040
+#define R_1029_HDMI_FC_VSDIEEEID0 0x6041
+#define R_1030_HDMI_FC_VSDIEEEID1 0x2044
+#define R_1031_HDMI_FC_VSDIEEEID2 0x2045
+#define R_1032_HDMI_FC_VSDPAYLOAD0 0xa044
+#define R_1033_HDMI_FC_VSDPAYLOAD1 0xa045
+#define R_1034_HDMI_FC_VSDPAYLOAD2 0x2046
+#define R_1063_HDMI_FC_AUDSCONF 0xa049
+#define R_1065_HDMI_FC_AUDSV 0x204b
+#define R_1066_HDMI_FC_AUDSU 0xa04a
+#define R_1067_HDMI_FC_AUDSCHNLS0 0xa04b
+#define		HDMI_FC_AUDSCHNLS0_CGMSA 0x30
+#define R_1068_HDMI_FC_AUDSCHNLS1 0x6048
+#define R_1069_HDMI_FC_AUDSCHNLS2 0x6049
+#define R_106a_HDMI_FC_AUDSCHNLS3 0xe048
+#define		HDMI_FC_AUDSCHNLS3_OIEC_CH0(v) (v)
+#define		HDMI_FC_AUDSCHNLS3_OIEC_CH1(v) (v << 4)
+#define R_106b_HDMI_FC_AUDSCHNLS4 0xe049
+#define		HDMI_FC_AUDSCHNLS4_OIEC_CH2(v) (v)
+#define		HDMI_FC_AUDSCHNLS4_OIEC_CH3(v) (v << 4)
+#define R_106c_HDMI_FC_AUDSCHNLS5 0x604a
+#define		HDMI_FC_AUDSCHNLS5_OIEC_CH0(v) (v)
+#define		HDMI_FC_AUDSCHNLS5_OIEC_CH1(v) (v << 4)
+#define R_106d_HDMI_FC_AUDSCHNLS6 0x604b
+#define		HDMI_FC_AUDSCHNLS6_OIEC_CH2(v) (v)
+#define		HDMI_FC_AUDSCHNLS6_OIEC_CH3(v) (v << 4)
+#define R_106e_HDMI_FC_AUDSCHNLS7 0xe04a
+#define R_106f_HDMI_FC_AUDSCHNLS8 0xe04b
+#define		HDMI_FC_AUDSCHNLS8_WORDLENGTH(v) (v)
+#define R_10b3_HDMI_FC_DATAUTO0 0xb045
+#define R_10b4_HDMI_FC_DATAUTO1 0x3046
+#define R_10b5_HDMI_FC_DATAUTO2 0x3047
+#define R_10d2_HDMI_FC_MASK0 0x904c
+#define R_10d6_HDMI_FC_MASK1 0x904e
+#define R_10da_HDMI_FC_MASK2 0xd04c
+#define R_10e0_HDMI_FC_PRCONF 0x3048
+#define R_1103_HDMI_FC_GMD_CONF 0x8051
+#define R_1104_HDMI_FC_GMD_HB 0x0052
+#define R_1200_HDMI_FC_DBGFORCE 0x0840
+#define		HDMI_FC_DBGFORCE_FORCEAUDIO BIT(4)
+#define		HDMI_FC_DBGFORCE_FORCEVIDEO BIT(0)
+#define R_1219_HDMI_FC_DBGTMDS0 0x4845
+
+/* HDMI Source PHY Registers */
+#define R_3000_HDMI_PHY_CONF0 0x0240
+#define		HDMI_PHY_CONF0_PDZ BIT(7)
+#define		HDMI_PHY_CONF0_ENTMDS BIT(6)
+#define		HDMI_PHY_CONF0_SPARECTRL BIT(5)
+#define		HDMI_PHY_CONF0_GEN2_PDDQ BIT(4)
+#define		HDMI_PHY_CONF0_GEN2_TXPWRON BIT(3)
+#define		HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE BIT(2)
+#define		HDMI_PHY_CONF0_SELDATAENPOL BIT(1)
+#define		HDMI_PHY_CONF0_SELDIPIF BIT(0)
+#define R_3001_HDMI_PHY_TST0 0x0241
+#define		HDMI_PHY_TST0_TSTCLR BIT(5)
+#define R_3005_HDMI_PHY_INT0 0x0243
+#define R_3006_HDMI_PHY_MASK0 0x8242
+
+/* HDMI Master PHY Registers */
+#define R_3020_HDMI_PHY_I2CM_SLAVE_ADDR 0x2240
+#define		HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 0x69
+#define R_3021_HDMI_PHY_I2CM_ADDRESS_ADDR 0x2241
+#define R_3022_HDMI_PHY_I2CM_DATAO_1_ADDR 0xa240
+#define R_3023_HDMI_PHY_I2CM_DATAO_0_ADDR 0xa241
+#define R_3026_HDMI_PHY_I2CM_OPERATION_ADDR 0xa242
+#define		HDMI_PHY_I2CM_OPERATION_ADDR_WRITE 0x10
+#define R_3027_HDMI_PHY_I2CM_INT_ADDR 0xa243
+#define R_3028_HDMI_PHY_I2CM_CTLINT_ADDR 0x6240
+
+/* Audio Sampler Registers */
+#define R_3100_HDMI_AUD_CONF0 0x0250
+#define R_3101_HDMI_AUD_CONF1 0x0251
+#define R_3102_HDMI_AUD_INT 0x8250
+#define R_3103_HDMI_AUD_CONF2 0x8251
+#define R_3200_HDMI_AUD_N1 0x0a40
+#define R_3201_HDMI_AUD_N2 0x0a41
+#define R_3202_HDMI_AUD_N3 0x8a40
+#define R_3205_HDMI_AUD_CTS3 0x0a43
+#define R_3206_HDMI_AUD_INPUTCLKFS 0x8a42
+#define R_3302_HDMI_AUD_SPDIFINT 0x8a50
+
+/* Generic Parallel Audio Interface Registers */
+#define R_3506_HDMI_GP_POL 0x8272
+
+/* Main Controller Registers */
+#define R_4001_HDMI_MC_CLKDIS 0x0081
+#define		HDMI_MC_CLKDIS_HDCPCLK_DISABLE BIT(6)
+#define		HDMI_MC_CLKDIS_AUDCLK_DISABLE BIT(3)
+#define		HDMI_MC_CLKDIS_TMDSCLK_DISABLE BIT(1)
+#define R_4002_HDMI_MC_SWRSTZ 0x8080
+#define R_4004_HDMI_MC_FLOWCTRL 0x0082
+#define R_4005_HDMI_MC_PHYRSTZ 0x0083
+#define		HDMI_MC_PHYRSTZ_DEASSERT BIT(0)
+
+/* HDCP Encryption Engine Registers */
+#define R_5000_HDMI_A_HDCPCFG0 0x00c0
+#define R_5001_HDMI_A_HDCPCFG1 0x00c1
+#define		HDMI_A_HDCPCFG1_PH2UPSHFTENC BIT(2)
+#define		HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE BIT(1)
+#define		HDMI_A_HDCPCFG1_SWRESET BIT(0)
+#define R_5008_HDMI_A_APIINTMSK 0x40c0
+#define R_5009_HDMI_A_VIDPOLCFG 0x40c1
+#define		HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH BIT(4)
+
+/* CEC Engine Registers */
+#define R_7d02_HDMI_CEC_MASK 0x86f0
+
+/* I2C Master Registers (E-DDC) */
+#define R_7e00_HDMI_I2CM_SLAVE 0x0ee0
+#define R_7e01_HDMI_I2CM_ADDRESS 0x0ee1
+#define R_7e03_HDMI_I2CM_DATAI 0x8ee1
+#define R_7e04_HDMI_I2CM_OPERATION 0x0ee2
+#define		HDMI_I2CM_OPERATION_DDC_READ 0x02
+#define R_7e05_HDMI_I2CM_INT 0x0ee3
+#define R_7e06_HDMI_I2CM_CTLINT 0x8ee2
+#define R_7e07_HDMI_I2CM_DIV 0x8ee3
+#define R_7e08_HDMI_I2CM_SEGADDR 0x4ee0
+#define R_7e09_HDMI_I2CM_SOFTRSTZ 0x4ee1
+#define R_7e0a_HDMI_I2CM_SEGPTR 0xcee0
+#define R_7e0b_HDMI_I2CM_SS_SCL_HCNT_1_ADDR 0xcee1
+#define R_7e0c_HDMI_I2CM_SS_SCL_HCNT_0_ADDR 0x4ee2
+#define R_7e0d_HDMI_I2CM_SS_SCL_LCNT_1_ADDR 0x4ee3
+#define R_7e0e_HDMI_I2CM_SS_SCL_LCNT_0_ADDR 0xcee2
+#define R_7e0f_HDMI_I2CM_FS_SCL_HCNT_1_ADDR 0xcee3
+#define R_7e10_HDMI_I2CM_FS_SCL_HCNT_0_ADDR 0x0ee4
+#define R_7e11_HDMI_I2CM_FS_SCL_LCNT_1_ADDR 0x0ee5
+
+/*
+ * [0] = vic (CEA Video ID)
+ * [1] used in hdmi_phy_set / hdmi_io_audio
+ * [2..16] used in hdmi_io_video_mode
+ */
+static const struct para_tab {
+	u32 para[17];
+} ptbl[] = {
+	{{  6,  1, 1,    1,  5,  3, 0, 1, 4, 0, 0, 160,  20,  38, 124, 240, 22}},
+	{{ 21, 11, 1,    1,  5,  3, 1, 1, 2, 0, 0, 160,  32,  24, 126,  32, 24}},
+	{{  2, 11, 0,    0,  2,  6, 1, 0, 9, 0, 0, 208, 138,  16,  62, 224, 45}},
+	{{ 17, 11, 0,    0,  2,  5, 2, 0, 5, 0, 0, 208, 144,  12,  64,  64, 49}},
+	{{ 19,  4, 0, 0x60,  5,  5, 2, 2, 5, 1, 0,   0, 188, 184,  40, 208, 30}},
+	{{  4,  4, 0, 0x60,  5,  5, 2, 1, 5, 0, 0,   0, 114, 110,  40, 208, 30}},
+	{{ 20,  4, 0, 0x61,  7,  5, 4, 2, 2, 2, 0, 128, 208,  16,  44,  56, 22}},
+	{{  5,  4, 0, 0x60,  7,  5, 4, 1, 2, 0, 0, 128,  24,  88,  44,  56, 22}},
+	{{ 31,  2, 0, 0x60,  7,  5, 4, 2, 4, 2, 0, 128, 208,  16,  44,  56, 45}},
+	{{ 16,  2, 0, 0x60,  7,  5, 4, 1, 4, 0, 0, 128,  24,  88,  44,  56, 45}},
+	{{ 32,  4, 0, 0x60,  7,  5, 4, 3, 4, 2, 0, 128,  62, 126,  44,  56, 45}},
+	{{ 33,  4, 0,    0,  7,  5, 4, 2, 4, 2, 0, 128, 208,  16,  44,  56, 45}},
+	{{ 34,  4, 0,    0,  7,  5, 4, 1, 4, 0, 0, 128,  24,  88,  44,  56, 45}},
+#if 0
+	{{160,  2, 0, 0x60,  7,  5, 8, 3, 4, 1, 0, 128,  62, 126,  44, 157, 45}},
+	{{147,  2, 0, 0x60,  5,  5, 5, 2, 5, 1, 0,   0, 188, 184,  40, 190, 30}},
+	{{132,  2, 0, 0x60,  5,  5, 5, 1, 5, 0, 0,   0, 114, 110,  40, 160, 30}},
+	{{257,  1, 0, 0x60, 15, 10, 8, 2, 8, 0, 0,   0,  48, 176,  88, 112, 90}},
+	{{258,  1, 0, 0x60, 15, 10, 8, 5, 8, 4, 0,   0, 160,  32,  88, 112, 90}},
+#endif
+};
+
+#if IS_ENABLED(CONFIG_SND_SOC_SUNXI_HDMI)
+#if 0 /* 'ca' always 0 */
+static const unsigned char ca_table[] = {
+	0x11, 0x13, 0x31, 0x33, 0x15, 0x17, 0x35, 0x37,
+	0x55, 0x57, 0x75, 0x77, 0x5d, 0x5f, 0x7d, 0x7f, 
+	0xdd, 0xdf, 0xfd, 0xff, 0x99, 0x9b, 0xb9, 0xbb,
+	0x9d, 0x9f, 0xbd, 0xbf, 0xdd, 0xdf, 0xfd, 0xff,
+};
+#endif
+
+/* HDMI_FC_AUDSCHNLS7 values */
+static const struct pcm_sf {
+	u32 	sf;
+	unsigned char	cs_sf;
+} sf[] = {
+	{44100,	0x00},
+	{48000, 0x02},
+	{96000, 0x0a},
+	{192000,0x0e},
+	{22050,	0x04},
+	{24000,	0x06},
+	{32000, 0x03},
+	{88200,	0x08},
+	{768000,0x09},
+	{176400,0x0c},
+};
+
+static const struct {
+	int rate;
+	unsigned short n1, n2;
+} n_table[] = {
+	{32000,	3072,	4096},
+	{44100,	4704,	6272},
+	{88200,	4704*2,	6272*2},
+	{176400,4704*4,	6272*4},
+	{48000,	5120,	6144},
+	{96000,	5120*2,	6144*2},
+	{192000,5120*4,	6144*4},
+};
+#endif
+
+static inline void hdmi_writeb(struct de2_hdmi_priv *priv, u32 addr, u8 data)
+{
+	writeb_relaxed(data, priv->mmio + addr);
+}
+
+static inline void hdmi_writel(struct de2_hdmi_priv *priv, u32 addr, u32 data)
+{
+	writel_relaxed(data, priv->mmio + addr);
+}
+
+static inline u8 hdmi_readb(struct de2_hdmi_priv *priv, u32 addr)
+{
+	return readb_relaxed(priv->mmio + addr);
+}
+
+static inline u32 hdmi_readl(struct de2_hdmi_priv *priv, u32 addr)
+{
+	return readl_relaxed(priv->mmio + addr);
+}
+
+static void hdmi_lock(struct de2_hdmi_priv *priv)
+{
+	hdmi_writeb(priv, 0x10010, 0x45);
+	hdmi_writeb(priv, 0x10011, 0x45);
+	hdmi_writeb(priv, 0x10012, 0x52);
+	hdmi_writeb(priv, 0x10013, 0x54);
+}
+static void hdmi_unlock(struct de2_hdmi_priv *priv)
+{
+	hdmi_writeb(priv, 0x10010, 0x52);
+	hdmi_writeb(priv, 0x10011, 0x54);
+	hdmi_writeb(priv, 0x10012, 0x41);
+	hdmi_writeb(priv, 0x10013, 0x57);
+}
+
+static void hdmi_inner_init(struct de2_hdmi_priv *priv)
+{
+	u8 clkdis = priv->soc_type == SOC_H3 ?
+				~HDMI_MC_CLKDIS_TMDSCLK_DISABLE : 0xff;
+
+	hdmi_lock(priv);
+
+	/* software reset */
+	hdmi_writeb(priv, R_4002_HDMI_MC_SWRSTZ,  0x00);
+	udelay(2);
+
+	/* mask all interrupts */
+	hdmi_writeb(priv, R_01ff_HDMI_IH_MUTE, 0x00);
+	hdmi_writeb(priv, R_0807_HDMI_VP_MASK, 0xff);
+	hdmi_writeb(priv, R_10d2_HDMI_FC_MASK0, 0xff);
+	hdmi_writeb(priv, R_10d6_HDMI_FC_MASK1, 0xff);
+	hdmi_writeb(priv, R_10da_HDMI_FC_MASK2, 0xff);
+	hdmi_writeb(priv, R_3102_HDMI_AUD_INT, 0xff);
+	hdmi_writeb(priv, R_3302_HDMI_AUD_SPDIFINT, 0xff);
+	hdmi_writeb(priv, R_3506_HDMI_GP_POL, 0xff);
+	hdmi_writeb(priv, R_5008_HDMI_A_APIINTMSK, 0xff);
+	hdmi_writeb(priv, R_7d02_HDMI_CEC_MASK, 0xff);
+	hdmi_writeb(priv, R_7e05_HDMI_I2CM_INT, 0xff);
+	hdmi_writeb(priv, R_7e06_HDMI_I2CM_CTLINT, 0xff);
+
+	hdmi_writeb(priv, R_1063_HDMI_FC_AUDSCONF, 0xf0);
+	hdmi_writeb(priv, R_10b3_HDMI_FC_DATAUTO0, 0x1e);
+	hdmi_writeb(priv, R_5001_HDMI_A_HDCPCFG1, 0x00);
+	hdmi_writeb(priv, R_5001_HDMI_A_HDCPCFG1,
+				HDMI_A_HDCPCFG1_ENCRYPTIONDISABLE |
+				HDMI_A_HDCPCFG1_SWRESET);
+	hdmi_writeb(priv, R_5000_HDMI_A_HDCPCFG0, 0x00);
+	hdmi_writeb(priv, R_5009_HDMI_A_VIDPOLCFG,
+				HDMI_A_VIDPOLCFG_DATAENPOL_ACTIVE_HIGH);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS, clkdis);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS, 0x00);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS, clkdis);
+	hdmi_writeb(priv, R_0100_HDMI_IH_FC_STAT0, 0xff);
+	hdmi_writeb(priv, R_0101_HDMI_IH_FC_STAT1, 0xff);
+	hdmi_writeb(priv, R_0102_HDMI_IH_FC_STAT2, 0xff);
+	hdmi_writeb(priv, R_0103_HDMI_IH_AS_STAT0, 0xff);
+	hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, 0xff);
+	hdmi_writeb(priv, R_0106_HDMI_IH_CEC_STAT0, 0xff);
+	hdmi_writeb(priv, R_0107_HDMI_IH_VP_STAT0, 0xff);
+}
+
+static void hdmi_phy_init_a83t(struct de2_hdmi_priv *priv)
+{
+	hdmi_inner_init(priv);
+
+	hdmi_writeb(priv, 0x10000, 0x01);
+	hdmi_writeb(priv, 0x10001, 0x00);
+	hdmi_writeb(priv, 0x10002, HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
+	hdmi_writeb(priv, 0x10003, 0x00);
+	hdmi_writeb(priv, 0x10007, 0xa0);
+	hdmi_writeb(priv, R_4005_HDMI_MC_PHYRSTZ,
+					HDMI_MC_PHYRSTZ_DEASSERT);
+	udelay(1);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_PDDQ |
+					HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_PDDQ |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+	hdmi_writeb(priv, R_3006_HDMI_PHY_MASK0, 0xf0);
+	hdmi_writeb(priv, R_3027_HDMI_PHY_I2CM_INT_ADDR, 0xff);
+	hdmi_writeb(priv, R_3028_HDMI_PHY_I2CM_CTLINT_ADDR, 0xff);
+	hdmi_writeb(priv, R_0104_HDMI_IH_PHY_STAT0, 0xff);
+	hdmi_writeb(priv, R_0108_HDMI_IH_I2CMPHY_STAT0, 0xff);
+	hdmi_writeb(priv, R_4005_HDMI_MC_PHYRSTZ, 0x00);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_PDDQ |
+					HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+	hdmi_writeb(priv, R_3001_HDMI_PHY_TST0, HDMI_PHY_TST0_TSTCLR);
+	hdmi_writeb(priv, R_3020_HDMI_PHY_I2CM_SLAVE_ADDR,
+					HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2);
+	hdmi_writeb(priv, R_3001_HDMI_PHY_TST0, 0x00);
+}
+
+static void hdmi_phy_init_h3(struct de2_hdmi_priv *priv)
+{
+	int to_cnt;
+	u32 tmp;
+
+	hdmi_writel(priv, 0x10020, 0);
+	hdmi_writel(priv, 0x10020, 1 << 0);
+	udelay(5);
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 16));
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 1));
+	udelay(10);
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 2));
+	udelay(5);
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 3));
+	usleep_range(40, 50);
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 19));
+	usleep_range(100, 120);
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 18));
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (7 << 4));
+
+	to_cnt = 10;
+	while (1) {
+		if (hdmi_readl(priv, 0x10038) & 0x80)
+			break;
+		usleep_range(200, 250);
+		if (--to_cnt == 0) {
+			pr_warn("hdmi phy init timeout\n");
+			break;
+		}
+	}
+
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (0xf << 8));
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 7));
+
+	hdmi_writel(priv, 0x1002c, 0x39dc5040);
+	hdmi_writel(priv, 0x10030, 0x80084343);
+	msleep(10);
+	hdmi_writel(priv, 0x10034, 0x00000001);
+	hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | 0x02000000);
+	msleep(100);
+	tmp = hdmi_readl(priv, 0x10038);
+	hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | 0xc0000000);
+	hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+						((tmp >> 11) & 0x3f));
+	hdmi_writel(priv, 0x10020, 0x01ff0f7f);
+	hdmi_writel(priv, 0x10024, 0x80639000);
+	hdmi_writel(priv, 0x10028, 0x0f81c405);
+
+	hdmi_inner_init(priv);
+}
+
+void hdmi_io_init(struct de2_hdmi_priv *priv)
+{
+	if (priv->soc_type == SOC_H3)
+		hdmi_phy_init_h3(priv);
+	else
+		hdmi_phy_init_a83t(priv);
+#if 0
+//test
+// -> 13:2a:a0:c1 bf 02 fe 00 (A83T and H3)
+pr_info("*jfm* hdmi type %02x:%02x:%02x:%02x %02x %02x %02x %02x\n",
+hdmi_readb(priv, 0x0000),	// 0000 HDMI_DESIGN_ID
+hdmi_readb(priv, 0x0001),	// 0001 HDMI_REVISION_ID
+hdmi_readb(priv, 0x8000),	// 0002 HDMI_PRODUCT_ID0 (a0 for HDMI TX)
+hdmi_readb(priv, 0x8001),	// 0003 HDMI_PRODUCT_ID1 (01 / c1 if HDCP enscypt)
+hdmi_readb(priv, 0x0002),	// 0004 HDMI_CONFIG0_ID
+//					pix rep, hbr, spdif, i2s, 1.4, col, cec, hdcp
+hdmi_readb(priv, 0x0003),	// 0005 HDMI_CONFIG1_ID
+//					x, x, x, sfr, i2c, ocp, apb, ahb
+hdmi_readb(priv, 0x8002),	// 0006 HDMI_CONFIG2_ID
+//					00: legacy, f2: 3D, e2: 3D+HEC
+hdmi_readb(priv, 0x8003));	// 0007 HDMI_CONFIG3_ID
+//					x, x, x, x, x, x, x, audio
+#endif
+}
+
+static int get_vid(u32 id)
+{
+	u32 i;
+
+	for (i = 0; i < ARRAY_SIZE(ptbl); i++) {
+		if (id == ptbl[i].para[0])
+			return i;
+	}
+
+	return -1;
+}
+
+static void hdmi_i2cm_write(struct de2_hdmi_priv *priv,
+			    int addr, u8 valh, u8 vall)
+{
+	hdmi_writeb(priv, R_3021_HDMI_PHY_I2CM_ADDRESS_ADDR, addr);
+	hdmi_writeb(priv, R_3022_HDMI_PHY_I2CM_DATAO_1_ADDR, valh);
+	hdmi_writeb(priv, R_3023_HDMI_PHY_I2CM_DATAO_0_ADDR, vall);
+	hdmi_writeb(priv, R_3026_HDMI_PHY_I2CM_OPERATION_ADDR,
+					HDMI_PHY_I2CM_OPERATION_ADDR_WRITE);
+	usleep_range(2000, 2500);
+}
+
+static int hdmi_phy_set_a83t(struct de2_hdmi_priv *priv, int i)
+{
+	switch (ptbl[i].para[1]) {
+	case 1:
+		hdmi_i2cm_write(priv, 0x06, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x15, 0x00, 0x0f);
+		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x19, 0x00, 0x02);
+		hdmi_i2cm_write(priv, 0x0e, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x09, 0x80, 0x2b);
+		break;
+	case 2:				/* 1080P @ 60 & 50 */
+		hdmi_i2cm_write(priv, 0x06, 0x04, 0xa0);
+		hdmi_i2cm_write(priv, 0x15, 0x00, 0x0a);
+		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x19, 0x00, 0x02);
+		hdmi_i2cm_write(priv, 0x0e, 0x00, 0x21);
+		hdmi_i2cm_write(priv, 0x09, 0x80, 0x29);
+		break;
+	case 4:				/* 720P @ 50 & 60, 1080I, 1080P */
+		hdmi_i2cm_write(priv, 0x06, 0x05, 0x40);
+		hdmi_i2cm_write(priv, 0x15, 0x00, 0x05);
+		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x19, 0x00, 0x07);
+		hdmi_i2cm_write(priv, 0x0e, 0x02, 0xb5);
+		hdmi_i2cm_write(priv, 0x09, 0x80, 0x09);
+		break;
+	case 11:			/* 480P/576P */
+		hdmi_i2cm_write(priv, 0x06, 0x01,
+					ptbl[i].para[2] ? 0xe3 : 0xe0);
+		hdmi_i2cm_write(priv, 0x15, 0x00, 0x00);
+		hdmi_i2cm_write(priv, 0x10, 0x08, 0xda);
+		hdmi_i2cm_write(priv, 0x19, 0x00, 0x07);
+		hdmi_i2cm_write(priv, 0x0e, 0x03, 0x18);
+		hdmi_i2cm_write(priv, 0x09, 0x80, 0x09);
+		break;
+	default:
+		return -1;
+	}
+	hdmi_i2cm_write(priv, 0x1e, 0x00, 0x00);
+	hdmi_i2cm_write(priv, 0x13, 0x00, 0x00);
+	hdmi_i2cm_write(priv, 0x17, 0x00, 0x00);
+	hdmi_writeb(priv, R_3000_HDMI_PHY_CONF0,
+					HDMI_PHY_CONF0_GEN2_TXPWRON |
+					HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE |
+					HDMI_PHY_CONF0_SELDATAENPOL);
+
+	return 0;
+}
+
+static int hdmi_phy_set_h3(struct de2_hdmi_priv *priv, int i)
+{
+	u32 tmp;
+
+	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) & ~0xf000);
+	switch (ptbl[i].para[1]) {
+	case 1:
+		hdmi_writel(priv, 0x1002c, 0x31dc5fc0);	/* or 0x30dc5fc0 ? */
+		hdmi_writel(priv, 0x10030, 0x800863c0);
+		msleep(10);
+		hdmi_writel(priv, 0x10034, 0x00000001);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0x02000000);
+		msleep(200);
+		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0xc0000000);
+		if (tmp < 0x3d)
+			tmp += 2;
+		else
+			tmp = 0x3f;
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
+		msleep(100);
+		hdmi_writel(priv, 0x10020, 0x01ffff7f);
+		hdmi_writel(priv, 0x10024, 0x8063b000);
+		hdmi_writel(priv, 0x10028, 0x0f8246b5);
+		break;
+	case 2:				/* 1080P @ 60 & 50 */
+		hdmi_writel(priv, 0x1002c, 0x39dc5040);
+		hdmi_writel(priv, 0x10030, 0x80084381);
+		msleep(10);
+		hdmi_writel(priv, 0x10034, 0x00000001);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0x02000000);
+		msleep(100);
+		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0xc0000000);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
+		hdmi_writel(priv, 0x10020, 0x01ffff7f);
+		hdmi_writel(priv, 0x10024, 0x8063a800);
+		hdmi_writel(priv, 0x10028, 0x0f81c485);
+		break;
+	case 4:				/* 720P @ 50 & 60, 1080I, 1080P */
+		hdmi_writel(priv, 0x1002c, 0x39dc5040);
+		hdmi_writel(priv, 0x10030, 0x80084343);
+		msleep(10);
+		hdmi_writel(priv, 0x10034, 0x00000001);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0x02000000);
+		msleep(100);
+		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0xc0000000);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
+		hdmi_writel(priv, 0x10020, 0x01ffff7f);
+		hdmi_writel(priv, 0x10024, 0x8063b000);
+		hdmi_writel(priv, 0x10028, 0x0f81c405);
+		break;
+	case 11:				/* 480P/576P */
+		hdmi_writel(priv, 0x1002c, 0x39dc5040);
+		hdmi_writel(priv, 0x10030, 0x8008430a);
+		msleep(10);
+		hdmi_writel(priv, 0x10034, 0x00000001);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0x02000000);
+		msleep(100);
+		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
+							0xc0000000);
+		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
+		hdmi_writel(priv, 0x10020, 0x01ffff7f);
+		hdmi_writel(priv, 0x10024, 0x8063b000);
+		hdmi_writel(priv, 0x10028, 0x0f81c405);
+		break;
+	default:
+		return -1;
+	}
+
+	return 0;
+}
+
+void hdmi_io_video_on(struct de2_hdmi_priv *priv)
+{
+	if (priv->soc_type == SOC_H3)
+		hdmi_writel(priv, 0x10020,
+				hdmi_readl(priv, 0x10020) | (0x0f << 12));
+#if 0
+	else
+		hdmi_writeb(priv, R_1200_HDMI_FC_DBGFORCE, 0);
+#endif
+}
+
+void hdmi_io_video_off(struct de2_hdmi_priv *priv)
+{
+	if (priv->soc_type == SOC_H3)
+		hdmi_writel(priv, 0x10020,
+				hdmi_readl(priv, 0x10020) & ~(0x0f << 12));
+#if 0
+	else
+		hdmi_writeb(priv, R_1200_HDMI_FC_DBGFORCE,
+					HDMI_FC_DBGFORCE_FORCEVIDEO);
+#endif
+}
+
+#if IS_ENABLED(CONFIG_SND_SOC_SUNXI_HDMI)
+/* start audio */
+int hdmi_io_audio(struct de2_hdmi_priv *priv,
+		int sample_rate, int sample_bit)
+{
+	int id = get_vid(priv->cea_mode);	/* ptbl index */
+	unsigned int i, n;
+
+//test
+pr_info("hdmi audio cea %d id %d rate %d bit %d\n",
+ priv->cea_mode, id, sample_rate, sample_bit);
+	if (id < 0)
+		return id;
+
+	/* (2 channels) */
+//	hdmi_writeb(priv, R_1063_HDMI_FC_AUDSCONF, audio->ch_num > 2 ? 0xf1 : 0xf0);
+	hdmi_writeb(priv, R_1063_HDMI_FC_AUDSCONF, 0xf0);
+
+#if 1 // audio->ca always 0
+	hdmi_writeb(priv, R_1065_HDMI_FC_AUDSV, ~0x11);
+#else
+	i = audio->ca;
+	if (i < ARRAY_SIZE(ca_table))
+		hdmi_writeb(priv, R_1065_HDMI_FC_AUDSV, ~ca_table[i]);
+#endif
+
+	hdmi_writeb(priv, R_1066_HDMI_FC_AUDSU, 0x00);
+	hdmi_writeb(priv, R_1067_HDMI_FC_AUDSCHNLS0,
+					HDMI_FC_AUDSCHNLS0_CGMSA);
+	hdmi_writeb(priv, R_1068_HDMI_FC_AUDSCHNLS1, 0x00);
+	hdmi_writeb(priv, R_1069_HDMI_FC_AUDSCHNLS2, 0x01);
+	hdmi_writeb(priv, R_106a_HDMI_FC_AUDSCHNLS3,
+					HDMI_FC_AUDSCHNLS3_OIEC_CH0(2) |
+					HDMI_FC_AUDSCHNLS3_OIEC_CH1(4));
+	hdmi_writeb(priv, R_106b_HDMI_FC_AUDSCHNLS4,
+					HDMI_FC_AUDSCHNLS4_OIEC_CH2(6) |
+					HDMI_FC_AUDSCHNLS4_OIEC_CH3(8));
+	hdmi_writeb(priv, R_106c_HDMI_FC_AUDSCHNLS5,
+					HDMI_FC_AUDSCHNLS5_OIEC_CH0(1) |
+					HDMI_FC_AUDSCHNLS5_OIEC_CH1(3));
+	hdmi_writeb(priv, R_106d_HDMI_FC_AUDSCHNLS6,
+					HDMI_FC_AUDSCHNLS6_OIEC_CH2(5) |
+					HDMI_FC_AUDSCHNLS6_OIEC_CH3(7));
+	hdmi_writeb(priv, R_106e_HDMI_FC_AUDSCHNLS7, 0x01);
+	for (i = 0; i < ARRAY_SIZE(sf); i++) {
+		if (sample_rate == sf[i].sf) {
+			hdmi_writeb(priv, R_106e_HDMI_FC_AUDSCHNLS7,
+							sf[i].cs_sf);
+			break;
+		}
+	}
+	hdmi_writeb(priv, R_106f_HDMI_FC_AUDSCHNLS8,
+		(sample_bit == 16) ? HDMI_FC_AUDSCHNLS8_WORDLENGTH(2) :
+		(sample_bit == 24 ? HDMI_FC_AUDSCHNLS8_WORDLENGTH(11) :
+				    HDMI_FC_AUDSCHNLS8_WORDLENGTH(0)));
+
+	hdmi_writeb(priv, R_3101_HDMI_AUD_CONF1, sample_bit);
+
+	n = 6272;
+	for (i = 0; i < ARRAY_SIZE(n_table); i++) {
+		if (sample_rate == n_table[i].rate) {
+			if (ptbl[id].para[1] == 1)
+				n = n_table[i].n1;
+			else
+				n = n_table[i].n2;
+			break;
+		}
+	}
+
+	hdmi_writeb(priv, R_3200_HDMI_AUD_N1, n);
+	hdmi_writeb(priv, R_3201_HDMI_AUD_N2, n >> 8);
+	hdmi_writeb(priv, R_3202_HDMI_AUD_N3, n >> 16);
+	hdmi_writeb(priv, R_3205_HDMI_AUD_CTS3, 0x00);
+	hdmi_writeb(priv, R_3206_HDMI_AUD_INPUTCLKFS, 0x04);
+// always 2 channels
+//	hdmi_writeb(priv, R_1063_HDMI_FC_AUDSCONF, audio->ch_num > 2 ? 0x01 : 0x00);
+//	hdmi_writeb(priv, R_1025_HDMI_FC_AUDICONF0, audio->ch_num * 16);
+	hdmi_writeb(priv, R_1063_HDMI_FC_AUDSCONF, 0x00);	/* layout0 */
+	hdmi_writeb(priv, R_1025_HDMI_FC_AUDICONF0, 2 * 16);	/* 2 channels */
+	hdmi_writeb(priv, R_1026_HDMI_FC_AUDICONF1, 0x00);
+// audio->ca always 0 for 2 channels
+//	hdmi_writeb(priv, R_1027_HDMI_FC_AUDICONF2, audio->ca);
+	hdmi_writeb(priv, R_1027_HDMI_FC_AUDICONF2, 0x00);
+	hdmi_writeb(priv, R_1028_HDMI_FC_AUDICONF3, 0x00);
+
+#if 1
+	hdmi_writeb(priv, R_3103_HDMI_AUD_CONF2, 0x00);		/* PCM only */
+#else
+	if (audio->type == PCM) {
+		hdmi_writeb(priv, R_3103_HDMI_AUD_CONF2, 0x00);
+	} else if (audio->type == DTS_HD || audio->type == DDP) {
+		hdmi_writeb(priv, R_3103_HDMI_AUD_CONF2, 0x03);
+		hdmi_writeb(priv, R_3101_HDMI_AUD_CONF1, 0x15);
+		hdmi_writeb(priv, R_1027_HDMI_FC_AUDICONF2, 0);
+	} else {
+		hdmi_writeb(priv, R_3103_HDMI_AUD_CONF2, 0x02);
+		hdmi_writeb(priv, R_3101_HDMI_AUD_CONF1, 0x15);
+		hdmi_writeb(priv, R_1027_HDMI_FC_AUDICONF2, 0);
+	}
+#endif
+
+	hdmi_writeb(priv, R_3100_HDMI_AUD_CONF0, 0x00);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS,
+					HDMI_MC_CLKDIS_AUDCLK_DISABLE);
+	hdmi_writeb(priv, R_4002_HDMI_MC_SWRSTZ, 0xf7);
+	usleep_range(100, 120);
+	hdmi_writeb(priv, R_3100_HDMI_AUD_CONF0, 0xaf);
+	usleep_range(100, 120);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS, 0x00);	/* enable all clocks */
+
+	return 0;
+}
+#endif
+
+
+/* initialize */
+int hdmi_io_video_mode(struct de2_hdmi_priv *priv)
+{
+	int i = get_vid(priv->cea_mode);	/* ptbl index */
+	u8 avi_d2;			/* AVI InfoFrame Data Byte 2 */
+
+	if (i < 0)
+		return i;
+
+	/* colorimetry and aspect ratio */
+	switch (priv->cea_mode) {
+	case 2:				/* 480P */
+	case 6:				/* 1440x480I */
+	case 17:			/* 576P */
+	case 21:			/* 1440x576I */
+		avi_d2 = (HDMI_COLORIMETRY_ITU_601 << 6) |
+			(HDMI_PICTURE_ASPECT_4_3 << 4) | 0x08;
+		break;
+	default:
+		avi_d2 = (HDMI_COLORIMETRY_ITU_709 << 6) |
+			(HDMI_PICTURE_ASPECT_16_9 << 4) | 0x08;
+		break;
+	}
+	if (priv->soc_type == SOC_H3) {
+		if (hdmi_phy_set_h3(priv, i) != 0)
+			return -1;
+		hdmi_inner_init(priv);
+	} else {
+		hdmi_io_init(priv);
+	}
+
+	hdmi_writeb(priv, R_1200_HDMI_FC_DBGFORCE,
+					HDMI_FC_DBGFORCE_FORCEVIDEO);
+	hdmi_writeb(priv, R_1219_HDMI_FC_DBGTMDS0, 0x00);
+	hdmi_writeb(priv, R_1000_HDMI_FC_INVIDCONF, ptbl[i].para[3] |
+				HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH);
+	hdmi_writeb(priv, 0x10001, ptbl[i].para[3] < 0x60 ? 0x03 : 0x00);
+	hdmi_writeb(priv, R_1002_HDMI_FC_INHACTV1, ptbl[i].para[4]);
+	hdmi_writeb(priv, R_100d_HDMI_FC_VSYNCINWIDTH, ptbl[i].para[5]);
+	hdmi_writeb(priv, R_1006_HDMI_FC_INVACTV1, ptbl[i].para[6]);
+	hdmi_writeb(priv, R_1004_HDMI_FC_INHBLANK1, ptbl[i].para[7]);
+	hdmi_writeb(priv, R_100c_HDMI_FC_VSYNCINDELAY, ptbl[i].para[8]);
+	hdmi_writeb(priv, R_1009_HDMI_FC_HSYNCINDELAY1, ptbl[i].para[9]);
+	hdmi_writeb(priv, R_100b_HDMI_FC_HSYNCINWIDTH1, ptbl[i].para[10]);
+	hdmi_writeb(priv, R_1001_HDMI_FC_INHACTV0, ptbl[i].para[11]);
+	hdmi_writeb(priv, R_1003_HDMI_FC_INHBLANK0, ptbl[i].para[12]);
+	hdmi_writeb(priv, R_1008_HDMI_FC_HSYNCINDELAY0, ptbl[i].para[13]);
+	hdmi_writeb(priv, R_100a_HDMI_FC_HSYNCINWIDTH1, ptbl[i].para[14]);
+	hdmi_writeb(priv, R_1005_HDMI_FC_INVACTV0, ptbl[i].para[15]);
+	hdmi_writeb(priv, R_1007_HDMI_FC_INVBLANK, ptbl[i].para[16]);
+	hdmi_writeb(priv, R_1011_HDMI_FC_CTRLDUR, 12);
+	hdmi_writeb(priv, R_1012_HDMI_FC_EXCTRLDUR, 32);
+	hdmi_writeb(priv, R_1013_HDMI_FC_EXCTRLSPAC, 1);
+	hdmi_writeb(priv, R_1014_HDMI_FC_CH0PREAM, 0x0b);
+	hdmi_writeb(priv, R_1015_HDMI_FC_CH1PREAM, 0x16);
+	hdmi_writeb(priv, R_1016_HDMI_FC_CH2PREAM, 0x21);
+	hdmi_writeb(priv, R_10e0_HDMI_FC_PRCONF, ptbl[i].para[2] ? 0x21 : 0x10);
+	hdmi_writeb(priv, R_0801_HDMI_VP_PR_CD, ptbl[i].para[2] ? 0x41 : 0x40);
+	hdmi_writeb(priv, R_0802_HDMI_VP_STUFF, 0x07);
+	hdmi_writeb(priv, R_0803_HDMI_VP_REMAP, 0x00);
+	hdmi_writeb(priv, R_0804_HDMI_VP_CONF, 0x47);
+	hdmi_writeb(priv, R_0200_HDMI_TX_INVID0, 0x01);
+	hdmi_writeb(priv, R_0201_HDMI_TX_INSTUFFING, 0x07);
+	hdmi_writeb(priv, R_0202_HDMI_TX_GYDATA0, 0x00);
+	hdmi_writeb(priv, R_0203_HDMI_TX_GYDATA1, 0x00);
+	hdmi_writeb(priv, R_0204_HDMI_TX_RCRDATA0, 0x00);
+	hdmi_writeb(priv, R_0205_HDMI_TX_RCRDATA1, 0x00);
+	hdmi_writeb(priv, R_0206_HDMI_TX_BCBDATA0, 0x00);
+	hdmi_writeb(priv, R_0207_HDMI_TX_BCBDATA1, 0x00);
+
+	if (priv->codec.eld) {			/* if audio/HDMI */
+		hdmi_writeb(priv, R_10b3_HDMI_FC_DATAUTO0, 0x08);
+		hdmi_writeb(priv, R_1031_HDMI_FC_VSDIEEEID2, 0x00);
+		hdmi_writeb(priv, R_1030_HDMI_FC_VSDIEEEID1,
+						HDMI_IEEE_OUI >> 8);
+		hdmi_writeb(priv, R_1029_HDMI_FC_VSDIEEEID0,
+						HDMI_IEEE_OUI & 0xff);
+		hdmi_writeb(priv, R_1032_HDMI_FC_VSDPAYLOAD0,
+//					(ptbl[i].para[0] & 0x100) ? 0x20 :
+//					(ptbl[i].para[0] & 0x80) ? 0x40 :
+								0x00);
+		hdmi_writeb(priv, R_1033_HDMI_FC_VSDPAYLOAD1,
+//					(ptbl[i].para[0] & 0x100) ?
+//						(ptbl[i].para[0] & 0x7f) :
+						0x00);
+		hdmi_writeb(priv, R_1034_HDMI_FC_VSDPAYLOAD2, 0x00);
+		hdmi_writeb(priv, R_10b4_HDMI_FC_DATAUTO1, 0x01);
+		hdmi_writeb(priv, R_10b5_HDMI_FC_DATAUTO2, 0x11);
+		hdmi_writeb(priv, R_1018_HDMI_FC_GCP, 0x00);
+		hdmi_writeb(priv, R_1104_HDMI_FC_GMD_HB, 0x00);
+		hdmi_writeb(priv, R_1103_HDMI_FC_GMD_CONF, 0x11);
+
+		hdmi_lock(priv);
+		hdmi_writeb(priv, R_1000_HDMI_FC_INVIDCONF,
+			hdmi_readb(priv, R_1000_HDMI_FC_INVIDCONF) | 0x08);
+		hdmi_unlock(priv);
+
+		/* AVI */
+		hdmi_writeb(priv, R_1019_HDMI_FC_AVICONF0,
+					HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN);
+		hdmi_writeb(priv, R_101a_HDMI_FC_AVICONF1, avi_d2);
+
+//fixme this does not look like data byte 3
+//		if (priv->soc_type == SOC_H3)
+			hdmi_writeb(priv, R_101b_HDMI_FC_AVICONF2, 0x08);
+//		else
+//			hdmi_writeb(priv, R_101b_HDMI_FC_AVICONF2, 0x00);
+		hdmi_writeb(priv, R_101c_HDMI_FC_AVIVID, priv->cea_mode);
+	}
+
+	hdmi_writeb(priv, R_4004_HDMI_MC_FLOWCTRL, 0x00);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS, 0x00);	/* enable all clocks */
+
+	if (priv->soc_type != SOC_H3) {
+		if (hdmi_phy_set_a83t(priv, i) != 0)
+			return -1;
+	}
+
+	hdmi_writeb(priv, R_1200_HDMI_FC_DBGFORCE, 0x00);
+
+	return 0;
+}
+
+/* get a block of EDID */
+int hdmi_io_ddc_read(struct de2_hdmi_priv *priv,
+			char pointer, char off,
+			int nbyte, char *pbuf)
+{
+	unsigned to_cnt;
+	u8 reg;
+	int ret = 0;
+
+//--fixme: from new bsp binary bpim3
+//	if (priv->soc_type == SOC_H3) {
+		hdmi_lock(priv);
+		hdmi_writeb(priv, R_7e09_HDMI_I2CM_SOFTRSTZ, 0x00);
+		to_cnt = 50;
+		while (!(hdmi_readb(priv, R_7e09_HDMI_I2CM_SOFTRSTZ) & 0x01)) {
+			udelay(10);
+			if (--to_cnt == 0) {	/* wait for 500us for timeout */
+				pr_warn("hdmi ddc reset timeout\n");
+				break;
+			}
+		}
+
+//fixme: strange values / IMx.6 doc
+// (0x08 - fast - for 7e07 and 0x05 for 7e05 would be more logical)
+		hdmi_writeb(priv, R_7e07_HDMI_I2CM_DIV, 0x05);
+		hdmi_writeb(priv, R_7e05_HDMI_I2CM_INT, 0x08);
+		hdmi_writeb(priv, R_7e0c_HDMI_I2CM_SS_SCL_HCNT_0_ADDR, 0xd8);
+		hdmi_writeb(priv, R_7e0e_HDMI_I2CM_SS_SCL_LCNT_0_ADDR, 0xfe);
+//fixme: registers not initialized (jfm 16-08-30) - no change
+//		hdmi_writeb(priv, R_7e0b_HDMI_I2CM_SS_SCL_HCNT_1_ADDR, 0x00);
+//		hdmi_writeb(priv, R_7e0d_HDMI_I2CM_SS_SCL_LCNT_1_ADDR, 0x00);
+//		hdmi_writeb(priv, R_7e0f_HDMI_I2CM_FS_SCL_HCNT_1_ADDR, 0x00);
+//		hdmi_writeb(priv, R_7e10_HDMI_I2CM_FS_SCL_HCNT_0_ADDR, 0x00);
+//		hdmi_writeb(priv, R_7e11_HDMI_I2CM_FS_SCL_LCNT_1_ADDR, 0x00);
+//	} else {
+//		hdmi_writeb(priv, R_7e07_HDMI_I2CM_DIV, 0x05);
+//		hdmi_writeb(priv, R_7e05_HDMI_I2CM_INT, 0x08);
+//	}
+
+	while (nbyte > 0) {
+		hdmi_writeb(priv, R_7e00_HDMI_I2CM_SLAVE, 0xa0 >> 1);
+		hdmi_writeb(priv, R_7e01_HDMI_I2CM_ADDRESS, off);
+		hdmi_writeb(priv, R_7e08_HDMI_I2CM_SEGADDR, 0x60 >> 1);
+		hdmi_writeb(priv, R_7e0a_HDMI_I2CM_SEGPTR, pointer);
+		hdmi_writeb(priv, R_7e04_HDMI_I2CM_OPERATION,
+					HDMI_I2CM_OPERATION_DDC_READ);
+//--fixme: new bsp (binary bpim3)
+//		if (priv->soc_type != SOC_H3)
+//			hdmi_lock(priv);
+
+		to_cnt = 200;				/* timeout 100ms */
+		while (1) {
+			reg = hdmi_readb(priv, R_0105_HDMI_IH_I2CM_STAT0);
+// from IMX6DQRM.pdf 33.5.14, the bits are cleared on read/write...
+//			hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, reg & 0x03);
+//			hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, 0x03);
+			hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, reg);
+			if (reg & 0x02) {
+				*pbuf++ = hdmi_readb(priv, R_7e03_HDMI_I2CM_DATAI);
+//				hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, 0x02);
+				break;
+			}
+			if (reg & 0x01) {
+//				hdmi_writeb(priv, R_0105_HDMI_IH_I2CM_STAT0, 0x01);
+				pr_warn("hdmi ddc read error\n");
+				ret = -1;
+				break;
+			}
+			if (--to_cnt == 0) {
+				if (!ret) {
+					pr_warn("hdmi ddc read timeout\n");
+					ret = -1;
+				}
+				break;
+			}
+			usleep_range(800, 1000);
+		}
+		if (ret)
+			break;
+		nbyte--;
+		off++;
+	}
+	hdmi_unlock(priv);
+
+	return ret;
+}
+
+int hdmi_io_get_hpd(struct de2_hdmi_priv *priv)
+{
+	int ret;
+
+	hdmi_lock(priv);
+
+	if (priv->soc_type == SOC_H3)
+		ret = hdmi_readl(priv, 0x10038) & 0x80000;
+	else
+		ret = hdmi_readb(priv, R_3005_HDMI_PHY_INT0) & 0x02;
+
+	hdmi_unlock(priv);
+
+	return ret != 0;
+}
+
+void hdmi_io_reset(struct de2_hdmi_priv *priv)
+{
+	hdmi_writeb(priv, R_5001_HDMI_A_HDCPCFG1,
+					HDMI_A_HDCPCFG1_PH2UPSHFTENC);
+	hdmi_writeb(priv, R_4001_HDMI_MC_CLKDIS,
+					HDMI_MC_CLKDIS_HDCPCLK_DISABLE);
+}
+
+int hdmi_io_mode_valid(int cea_mode)
+{
+	return get_vid(cea_mode);
+}
diff --git a/drivers/gpu/drm/sunxi/de2_hdmi_io.h b/drivers/gpu/drm/sunxi/de2_hdmi_io.h
new file mode 100644
index 0000000..2577f0b
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_hdmi_io.h
@@ -0,0 +1,25 @@
+#ifndef __DE2_HDMI_IO_H__
+#define __DE2_HDMI_IO_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */                             
+
+void hdmi_io_video_on(struct de2_hdmi_priv *priv);
+void hdmi_io_video_off(struct de2_hdmi_priv *priv);
+int hdmi_io_audio(struct de2_hdmi_priv *priv,
+		int sample_rate, int sample_bit);
+int hdmi_io_video_mode(struct de2_hdmi_priv *priv);
+int hdmi_io_ddc_read(struct de2_hdmi_priv *priv,
+			char pointer, char offset,
+			int nbyte, char *pbuf);
+int hdmi_io_get_hpd(struct de2_hdmi_priv *priv);
+void hdmi_io_init(struct de2_hdmi_priv *priv);
+void hdmi_io_reset(struct de2_hdmi_priv *priv);
+int hdmi_io_mode_valid(int cea_mode);
+
+#endif /* __DE2_HDMI_IO_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_hdmi.c b/drivers/gpu/drm/sunxi/de2_hdmi.c
new file mode 100644
index 0000000..9caa939
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_hdmi.c
@@ -0,0 +1,402 @@
+/*
+ * Allwinner DRM driver - HDMI
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/component.h>
+#include <linux/clk.h>
+#include <linux/hdmi.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+
+#include <drm/drmP.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_of.h>
+
+#include "de2_hdmi.h"
+#include "de2_hdmi_io.h"
+
+static const struct of_device_id de2_hdmi_dt_ids[] = {
+	{ .compatible = "allwinner,sun8i-a83t-hdmi",
+					.data = (void *) SOC_A83T },
+	{ .compatible = "allwinner,sun8i-h3-hdmi",
+					.data = (void *) SOC_H3 },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, de2_hdmi_dt_ids);
+
+#define conn_to_priv(x) \
+	container_of(x, struct de2_hdmi_priv, connector)
+
+#define enc_to_priv(x) \
+	container_of(x, struct de2_hdmi_priv, encoder)
+
+#define codec_to_priv(x) \
+	container_of(x, struct de2_hdmi_priv, codec)
+
+#if IS_ENABLED(CONFIG_SND_SOC_SUNXI_HDMI)
+/* --- audio functions --- */
+static int de2_hdmi_set_audio_input(struct device *dev,
+				    int enable,
+				    unsigned sample_rate,
+				    unsigned sample_bit)
+{
+	struct de2_hdmi_priv *priv = codec_to_priv(dev_get_drvdata(dev));
+	int ret;
+
+	if (!enable)
+		return 0;
+
+	mutex_lock(&priv->mutex);
+	ret = hdmi_io_audio(priv, sample_rate, sample_bit);
+	mutex_unlock(&priv->mutex);
+
+	return ret;
+}
+#endif
+
+/* --- encoder functions --- */
+
+static void de2_hdmi_encoder_mode_set(struct drm_encoder *encoder,
+				      struct drm_display_mode *mode,
+				      struct drm_display_mode *adjusted_mode)
+{
+	struct de2_hdmi_priv *priv = enc_to_priv(encoder);
+
+	priv->cea_mode = drm_match_cea_mode(mode);
+
+	DRM_DEBUG_DRIVER("cea_mode %d\n", priv->cea_mode);
+
+	clk_set_rate(priv->clk, mode->clock * 1000);
+
+	mutex_lock(&priv->mutex);
+	hdmi_io_video_mode(priv);
+	mutex_unlock(&priv->mutex);
+}
+
+static void de2_hdmi_encoder_enable(struct drm_encoder *encoder)
+{ 
+	struct de2_hdmi_priv *priv = enc_to_priv(encoder);
+
+	mutex_lock(&priv->mutex);
+	hdmi_io_video_on(priv);
+	mutex_unlock(&priv->mutex);
+}
+
+static void de2_hdmi_encoder_disable(struct drm_encoder *encoder)
+{ 
+	struct de2_hdmi_priv *priv = enc_to_priv(encoder);
+
+	mutex_lock(&priv->mutex);
+	hdmi_io_video_off(priv);
+	mutex_unlock(&priv->mutex);
+}
+
+static const struct drm_encoder_helper_funcs de2_hdmi_encoder_helper_funcs = {
+	.mode_set = de2_hdmi_encoder_mode_set,
+	.enable = de2_hdmi_encoder_enable,
+	.disable = de2_hdmi_encoder_disable,
+};
+
+static const struct drm_encoder_funcs de2_hdmi_encoder_funcs = {
+	.destroy = drm_encoder_cleanup,
+};
+
+/* --- connector functions --- */
+static int de2_hdmi_connector_mode_valid(struct drm_connector *connector,
+					struct drm_display_mode *mode)
+{
+	struct de2_hdmi_priv *priv = conn_to_priv(connector);
+	int cea_mode = drm_match_cea_mode(mode);
+
+	if (hdmi_io_mode_valid(cea_mode) < 0)
+		return MODE_NOMODE;
+
+	if (connector->eld[0])
+		priv->codec.eld = connector->eld;	/* audio parameters */
+
+	return MODE_OK;
+}
+
+static enum drm_connector_status de2_hdmi_connector_detect(
+				struct drm_connector *connector, bool force)
+{
+	struct de2_hdmi_priv *priv = conn_to_priv(connector);
+	int ret;
+
+	mutex_lock(&priv->mutex);
+	ret = hdmi_io_get_hpd(priv);
+	mutex_unlock(&priv->mutex);
+
+	return ret ? connector_status_connected :
+			connector_status_disconnected;
+}
+
+static int read_edid_block(void *data, u8 *buf,
+			   unsigned int blk, size_t length)
+{
+	struct de2_hdmi_priv *priv = data;
+	int ret;
+
+	mutex_lock(&priv->mutex);
+	ret = hdmi_io_ddc_read(priv,
+				blk / 2, (blk & 1) ? 128 : 0,
+				length, buf);
+	mutex_unlock(&priv->mutex);
+
+	return ret;
+}
+
+static int de2_hdmi_connector_get_modes(struct drm_connector *connector)
+{
+	struct de2_hdmi_priv *priv = conn_to_priv(connector);
+	struct edid *edid;
+	int n;
+
+	DRM_DEBUG_DRIVER("\n");
+
+	priv->codec.eld = NULL;
+
+	edid = drm_do_get_edid(connector, read_edid_block, priv);
+
+	if (!edid) {
+		dev_warn(priv->dev, "failed to read EDID\n");
+		if (!connector->cmdline_mode.specified)
+			return 0;
+
+		return drm_add_modes_noedid(connector,
+					connector->cmdline_mode.xres,
+					connector->cmdline_mode.yres);
+	}
+
+	drm_mode_connector_update_edid_property(connector, edid);
+	n = drm_add_edid_modes(connector, edid);
+
+	drm_edid_to_eld(connector, edid);
+
+	kfree(edid);
+
+	DRM_DEBUG_DRIVER("%s EDID ok %d modes\n",
+		connector->eld[0] ? "HDMI" : "DVI", n);
+
+	return n;
+}
+
+static const
+struct drm_connector_helper_funcs de2_hdmi_connector_helper_funcs = {
+	.get_modes = de2_hdmi_connector_get_modes,
+	.mode_valid = de2_hdmi_connector_mode_valid,
+};
+
+static const struct drm_connector_funcs de2_hdmi_connector_funcs = {
+	.dpms = drm_atomic_helper_connector_dpms,
+	.reset = drm_atomic_helper_connector_reset,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.detect = de2_hdmi_connector_detect,
+	.destroy = drm_connector_cleanup,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static void de2_hdmi_cleanup(struct de2_hdmi_priv *priv)
+{
+	clk_disable_unprepare(priv->clk_ddc);
+	clk_disable_unprepare(priv->clk);
+	clk_disable_unprepare(priv->gate);
+	if (!IS_ERR_OR_NULL(priv->rstc1))
+		reset_control_assert(priv->rstc1);
+	if (!IS_ERR_OR_NULL(priv->rstc0))
+		reset_control_assert(priv->rstc0);
+}
+
+static int de2_hdmi_bind(struct device *dev, struct device *master, void *data)
+{
+	struct drm_device *drm = data;
+	struct de2_hdmi_priv *priv = codec_to_priv(dev_get_drvdata(dev));
+	struct drm_encoder *encoder = &priv->encoder;
+	struct drm_connector *connector = &priv->connector;
+	int ret;
+
+	encoder->possible_crtcs =
+			drm_of_find_possible_crtcs(drm, dev->of_node);
+
+	/* if no CRTC, delay */
+	if (encoder->possible_crtcs == 0)
+		return -EPROBE_DEFER;
+
+	/* HDMI init */
+	ret = reset_control_deassert(priv->rstc0);
+	if (ret)
+		goto err;
+	ret = reset_control_deassert(priv->rstc1);
+	if (ret)
+		goto err;
+	if (!IS_ERR(priv->gate)) {
+		ret = clk_prepare_enable(priv->gate);
+		if (ret)
+			goto err;
+	}
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		goto err;
+	ret = clk_prepare_enable(priv->clk_ddc);
+	if (ret)
+		goto err;
+
+	mutex_lock(&priv->mutex);
+	hdmi_io_init(priv);
+	hdmi_io_reset(priv);		/* hpd reset */
+	mutex_unlock(&priv->mutex);
+
+	/* encoder init */
+	ret = drm_encoder_init(drm, encoder, &de2_hdmi_encoder_funcs,
+			       DRM_MODE_ENCODER_TMDS, NULL);
+	if (ret)
+		goto err;
+
+	drm_encoder_helper_add(encoder, &de2_hdmi_encoder_helper_funcs);
+
+	/* connector init */
+	ret = drm_connector_init(drm, connector,
+				 &de2_hdmi_connector_funcs,
+				 DRM_MODE_CONNECTOR_HDMIA);
+	if (ret)
+		goto err_connector;
+
+	connector->interlace_allowed = 1;
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+				 DRM_CONNECTOR_POLL_DISCONNECT;
+	drm_connector_helper_add(connector,
+				 &de2_hdmi_connector_helper_funcs);
+
+	drm_mode_connector_attach_encoder(connector, encoder);
+
+	return 0;
+
+err_connector:
+	drm_encoder_cleanup(encoder);
+err:
+	dev_err(dev, "err %d\n", ret);
+	return ret;
+}
+
+static void de2_hdmi_unbind(struct device *dev, struct device *master,
+			   void *data)
+{
+	struct de2_hdmi_priv *priv = codec_to_priv(dev_get_drvdata(dev));
+
+	if (priv->connector.dev)
+		drm_connector_cleanup(&priv->connector);
+	drm_encoder_cleanup(&priv->encoder);
+	de2_hdmi_cleanup(priv);
+}
+
+static const struct component_ops de2_hdmi_ops = {
+	.bind = de2_hdmi_bind,
+	.unbind = de2_hdmi_unbind,
+};
+
+static int de2_hdmi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct de2_hdmi_priv *priv;
+	struct resource *res;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, &priv->codec);
+	priv->dev = dev;
+
+	mutex_init(&priv->mutex);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "failed to get memory resource\n");
+		return -ENXIO;
+	}
+	priv->mmio = devm_ioremap_resource(dev, res);
+	if (IS_ERR(priv->mmio)) {
+		dev_err(dev, "failed to map registers\n");
+		return PTR_ERR(priv->mmio);
+	}
+
+	priv->gate = devm_clk_get(dev, "gate");	/* optional */
+//	if (IS_ERR(priv->gate)) {
+//		dev_err(dev, "gate clock err %d\n",
+//					(int) PTR_ERR(priv->gate));
+//		return PTR_ERR(priv->gate);
+//	}
+
+	priv->clk = devm_clk_get(dev, "clock");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "hdmi clock err %d\n",
+					(int) PTR_ERR(priv->clk));
+		return PTR_ERR(priv->clk);
+	}
+
+	priv->clk_ddc = devm_clk_get(dev, "ddc-clock");
+	if (IS_ERR(priv->clk_ddc)) {
+		dev_err(dev, "hdmi-ddc clock err %d\n",
+					(int) PTR_ERR(priv->clk_ddc));
+		return PTR_ERR(priv->clk_ddc);
+	}
+
+	priv->rstc0 = devm_reset_control_get(dev, "hdmi0");
+	if (IS_ERR(priv->rstc0)) {
+		dev_err(dev, "reset controller err %d\n",
+				(int) PTR_ERR(priv->rstc0));
+		return PTR_ERR(priv->rstc0);
+	}
+
+	priv->rstc1 = devm_reset_control_get(dev, "hdmi1");
+	if (IS_ERR(priv->rstc1)) {
+		dev_err(dev, "reset controller err %d\n",
+				(int) PTR_ERR(priv->rstc1));
+		return PTR_ERR(priv->rstc1);
+	}
+
+	priv->soc_type = (int) of_match_device(de2_hdmi_dt_ids,
+						&pdev->dev)->data;
+
+	if (IS_ENABLED(CONFIG_SND_SOC_SUNXI_HDMI)) {
+		priv->codec.set_audio_input = de2_hdmi_set_audio_input;
+		sunxi_hdmi_codec_register(dev);
+	}
+
+	return component_add(dev, &de2_hdmi_ops);
+}
+
+static int de2_hdmi_remove(struct platform_device *pdev)
+{
+	if (IS_ENABLED(CONFIG_SND_SOC_SUNXI_HDMI))
+		sunxi_hdmi_codec_unregister(&pdev->dev);
+	component_del(&pdev->dev, &de2_hdmi_ops);
+
+	return 0;
+}
+
+static struct platform_driver de2_hdmi_driver = {
+	.probe = de2_hdmi_probe,
+	.remove = de2_hdmi_remove,
+	.driver = {
+		.name = "sunxi-de2-hdmi",
+		.of_match_table = of_match_ptr(de2_hdmi_dt_ids),
+	},
+};
+
+module_platform_driver(de2_hdmi_driver);
+
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_DESCRIPTION("Allwinner DE2 HDMI encoder/connector");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/sunxi/de2_hdmi.h b/drivers/gpu/drm/sunxi/de2_hdmi.h
new file mode 100644
index 0000000..915d609
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_hdmi.h
@@ -0,0 +1,40 @@
+#ifndef __DE2_HDMI_H__
+#define __DE2_HDMI_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <drm/drmP.h>
+#include <sound/sunxi_hdmi.h>
+
+/* SoC types */
+#define SOC_A83T 0
+#define SOC_H3 1
+
+struct de2_hdmi_priv {
+	struct device *dev;
+	void __iomem *mmio;
+
+	struct drm_encoder encoder;
+	struct drm_connector connector;
+
+	struct clk *clk;
+	struct clk *clk_ddc;
+	struct clk *gate;
+	struct reset_control *rstc0;
+	struct reset_control *rstc1;
+
+	struct mutex mutex;
+	u8 soc_type;
+	u8 cea_mode;
+	struct sunxi_hdmi_codec codec;
+};
+
+#endif /* __DE2_HDMI_H__ */
diff --git a/drivers/gpu/drm/sunxi/de2_plane.c b/drivers/gpu/drm/sunxi/de2_plane.c
new file mode 100644
index 0000000..026afea
--- /dev/null
+++ b/drivers/gpu/drm/sunxi/de2_plane.c
@@ -0,0 +1,134 @@
+/*
+ * Allwinner DRM driver - DE2 planes
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_crtc_helper.h>
+
+#include "de2_drm.h"
+#include "de2_crtc.h"
+
+/* plane formats */
+static const uint32_t ui_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+};
+
+static const uint32_t vi_formats[] = {
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU,
+	DRM_FORMAT_YUV422,
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_UYVY,
+	DRM_FORMAT_BGRA8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_BGR888,
+};
+
+static void de2_plane_disable(struct drm_plane *plane,
+				struct drm_plane_state *old_state)
+{
+	struct drm_crtc *crtc = old_state->crtc;
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	int plane_num = plane - lcd->planes;
+
+	de2_de_plane_disable(lcd->priv, lcd->num, plane_num);
+}
+
+static void de2_plane_update(struct drm_plane *plane,
+				struct drm_plane_state *old_state)
+{
+	struct drm_plane_state *state = plane->state;
+	struct drm_crtc *crtc = state->crtc;
+	struct lcd *lcd = crtc_to_lcd(crtc);
+	struct drm_framebuffer *fb = state->fb;
+	int plane_num = plane - lcd->planes;
+
+	if (!crtc || !fb) {
+		DRM_DEBUG_DRIVER("no crtc/fb\n");
+		return;
+	}
+
+	de2_de_plane_update(lcd->priv, lcd->num, plane_num,
+			    state, old_state);
+}
+
+static const struct drm_plane_helper_funcs plane_helper_funcs = {
+	.atomic_disable = de2_plane_disable,
+	.atomic_update = de2_plane_update,
+};
+
+static const struct drm_plane_funcs plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = drm_plane_cleanup,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static int de2_one_plane_init(struct drm_device *drm,
+				struct drm_plane *plane,
+				int type, int possible_crtcs,
+				const uint32_t *formats,
+				int nformats)
+{
+	int ret;
+
+	ret = drm_universal_plane_init(drm, plane, possible_crtcs,
+				&plane_funcs,
+				formats, nformats, type, NULL);
+	if (ret >= 0)
+		drm_plane_helper_add(plane, &plane_helper_funcs);
+
+	return ret;
+}
+
+int de2_plane_init(struct drm_device *drm, struct lcd *lcd)
+{
+	int ret, possible_crtcs = 1 << lcd->crtc_idx;
+
+	ret = de2_one_plane_init(drm, &lcd->planes[DE2_PRIMARY_PLANE],
+				DRM_PLANE_TYPE_PRIMARY, possible_crtcs,
+				ui_formats, ARRAY_SIZE(ui_formats));
+#if 1 // test cursor
+		// ko with channel 1 (UI) layer 1 no transparence
+		// ko with channel 0 (VI) layer 0	- id -
+	if (ret >= 0)
+		ret = de2_one_plane_init(drm, &lcd->planes[DE2_CURSOR_PLANE],
+				DRM_PLANE_TYPE_CURSOR, possible_crtcs,
+				ui_formats, ARRAY_SIZE(ui_formats));
+// (only one overlay plane with my XV modesetting)
+//	if (ret >= 0)
+//		ret = de2_one_plane_init(drm, &lcd->planes[DE2_UI_PLANE],
+//				DRM_PLANE_TYPE_OVERLAY, possible_crtcs,
+//				ui_formats, ARRAY_SIZE(ui_formats));
+#else
+	// cursor in channel 2 (first LCD only)
+	if (ret >= 0 && lcd->num == 0)
+		ret = de2_one_plane_init(drm, &lcd->planes[DE2_CURSOR_PLANE],
+				DRM_PLANE_TYPE_CURSOR, possible_crtcs,
+				ui_formats, ARRAY_SIZE(ui_formats));
+#endif
+	if (ret >= 0)
+		ret = de2_one_plane_init(drm, &lcd->planes[DE2_VI_PLANE],
+				DRM_PLANE_TYPE_OVERLAY, possible_crtcs,
+				vi_formats, ARRAY_SIZE(vi_formats));
+	if (ret < 0)
+		dev_err(lcd->dev, "Couldn't initialize the planes err %d\n",
+				ret);
+
+	return ret;
+}
diff --git a/drivers/net/ethernet/allwinner/sun8i-emac.c b/drivers/net/ethernet/allwinner/sun8i-emac.c
new file mode 100644
index 0000000..1a08b42
--- /dev/null
+++ b/drivers/net/ethernet/allwinner/sun8i-emac.c
@@ -0,0 +1,2255 @@
+/*
+ * sun8i-emac driver
+ *
+ * Copyright (C) 2015-2016 Corentin LABBE <clabbe.montjoie@xxxxxxxxx>
+ *
+ * This is the driver for Allwinner Ethernet MAC found in H3/A83T/A64 SoC
+ *
+ * TODO:
+ * - MAC filtering
+ * - Jumbo frame
+ * - features rx-all (NETIF_F_RXALL_BIT)
+ * - PM runtime
+ */
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/etherdevice.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/of_device.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/scatterlist.h>
+#include <linux/skbuff.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+
+#define EMAC_BASIC_CTL0	0x00
+#define EMAC_BASIC_CTL1	0x04
+#define EMAC_INT_STA	0x08
+#define EMAC_INT_EN	0x0C
+#define EMAC_TX_CTL0	0x10
+#define EMAC_TX_CTL1	0x14
+#define EMAC_TX_FLOW_CTL	0x1C
+#define EMAC_RX_CTL0	0x24
+#define EMAC_RX_CTL1	0x28
+#define EMAC_RX_FRM_FLT	0x38
+#define EMAC_MDIO_CMD	0x48
+#define EMAC_MDIO_DATA	0x4C
+#define EMAC_TX_DMA_STA	0xB0
+#define EMAC_TX_CUR_DESC	0xB4
+#define EMAC_TX_CUR_BUF	0xB8
+#define EMAC_RX_DMA_STA	0xC0
+
+#define MDIO_CMD_MII_BUSY	BIT(0)
+#define MDIO_CMD_MII_WRITE	BIT(1)
+#define MDIO_CMD_MII_PHY_REG_ADDR_MASK	GENMASK(8, 4)
+#define MDIO_CMD_MII_PHY_REG_ADDR_SHIFT	4
+#define MDIO_CMD_MII_PHY_ADDR_MASK	GENMASK(16, 12)
+#define MDIO_CMD_MII_PHY_ADDR_SHIFT	12
+
+#define EMAC_MACADDR_HI	0x50
+#define EMAC_MACADDR_LO	0x54
+
+#define EMAC_RX_DESC_LIST 0x34
+#define EMAC_TX_DESC_LIST 0x20
+
+#define EMAC_RX_DO_CRC BIT(27)
+#define EMAC_RX_STRIP_FCS BIT(28)
+
+#define LE32_BIT(x) (cpu_to_le32(BIT(x)))
+
+#define EMAC_COULD_BE_USED_BY_DMA LE32_BIT(31)
+
+/* Used in RX_CTL1*/
+#define EMAC_RX_DMA_EN	BIT(30)
+#define EMAC_RX_DMA_START	BIT(31)
+/* Used in TX_CTL1*/
+#define EMAC_TX_DMA_EN	BIT(30)
+#define EMAC_TX_DMA_START	BIT(31)
+
+/* Used in RX_CTL0 */
+#define EMAC_RX_RECEIVER_EN		BIT(31)
+/* Used in TX_CTL0 */
+#define EMAC_TX_TRANSMITTER_EN	BIT(31)
+
+/* Basic CTL0 */
+#define EMAC_BCTL0_FD BIT(0)
+#define EMAC_BCTL0_SPEED_10		2
+#define EMAC_BCTL0_SPEED_100		3
+#define EMAC_BCTL0_SPEED_MASK	GENMASK(3, 2)
+#define EMAC_BCTL0_SPEED_SHIFT	2
+
+#define EMAC_FLOW_RX 1
+#define EMAC_FLOW_TX 2
+
+#define EMAC_TX_INT		BIT(0)
+#define EMAC_TX_DMA_STOP_INT	BIT(1)
+#define EMAC_TX_BUF_UA_INT	BIT(2)
+#define EMAC_TX_TIMEOUT_INT	BIT(3)
+#define EMAC_TX_UNDERFLOW_INT	BIT(4)
+#define EMAC_TX_EARLY_INT	BIT(5)
+#define EMAC_RX_INT		BIT(8)
+#define EMAC_RX_BUF_UA_INT	BIT(9)
+#define EMAC_RX_DMA_STOP_INT	BIT(10)
+#define EMAC_RX_TIMEOUT_INT	BIT(11)
+#define EMAC_RX_OVERFLOW_INT	BIT(12)
+#define EMAC_RX_EARLY_INT	BIT(13)
+#define EMAC_RGMII_STA_INT	BIT(16)
+
+/* Bits used in frame RX status */
+#define EMAC_DSC_RX_FIRST		BIT(9)
+#define EMAC_DSC_RX_LAST		BIT(8)
+
+/* Bits used in frame TX ctl */
+#define EMAC_MAGIC_TX_BIT		LE32_BIT(24)
+#define EMAC_TX_DO_CRC		(LE32_BIT(27) | LE32_BIT(28))
+#define EMAC_DSC_TX_FIRST		LE32_BIT(29)
+#define EMAC_DSC_TX_LAST		LE32_BIT(30)
+#define EMAC_WANT_INT			LE32_BIT(31)
+
+/* struct emac_variant - Describe an emac variant of sun8i-emac
+ * @default_syscon_value: Default value of the syscon EMAC register
+ * The default_syscon_value is also used for powering down the PHY
+ * @internal_phy:	which PHY type is internal
+ * @support_mii:	Does the SoC support MII
+ * @support_rmii:	Does the SoC support RMII
+ * @support_rgmii:	Does the SoC support RGMII
+ */
+struct emac_variant {
+	u32 default_syscon_value;
+	int internal_phy;
+	bool support_mii;
+	bool support_rmii;
+	bool support_rgmii;
+};
+
+static const struct emac_variant emac_variant_h3 = {
+	.default_syscon_value = 0x58000,
+	.internal_phy = PHY_INTERFACE_MODE_MII,
+	.support_mii = true,
+	.support_rmii = true,
+	.support_rgmii = true
+};
+
+static const struct emac_variant emac_variant_a83t = {
+	.default_syscon_value = 0,
+	.internal_phy = 0,
+	.support_mii = true,
+	.support_rgmii = true
+};
+
+static const struct emac_variant emac_variant_a64 = {
+	.default_syscon_value = 0,
+	.internal_phy = 0,
+	.support_mii = true,
+	.support_rmii = true,
+	.support_rgmii = true
+};
+
+static const char const estats_str[][ETH_GSTRING_LEN] = {
+	/* errors */
+	"rx_payload_error",
+	"rx_CRC_error",
+	"rx_phy_error",
+	"rx_length_error",
+	"rx_col_error",
+	"rx_header_error",
+	"rx_overflow_error",
+	"rx_saf_error",
+	"rx_daf_error",
+	"rx_buf_error",
+	"rx_invalid_error",
+	"tx_timeout",
+	/* misc infos */
+	"tx_stop_queue",
+	"rx_dma_ua",
+	"rx_dma_stop",
+	"tx_dma_ua",
+	"tx_dma_stop",
+	"rx_hw_csum",
+	"tx_hw_csum",
+	/* interrupts */
+	"rx_int",
+	"tx_int",
+	"tx_early_int",
+	"tx_underflow_int",
+	"tx_timeout_int",
+	"rx_early_int",
+	"rx_overflow_int",
+	"rx_timeout_int",
+	"rgmii_state_int",
+	/* debug */
+	"tx_used_desc",
+	"napi_schedule",
+	"napi_underflow",
+};
+
+struct sun8i_emac_stats {
+	u64 rx_payload_error;
+	u64 rx_crc_error;
+	u64 rx_phy_error;
+	u64 rx_length_error;
+	u64 rx_col_error;
+	u64 rx_header_error;
+	u64 rx_overflow_error;
+	u64 rx_saf_fail;
+	u64 rx_daf_fail;
+	u64 rx_buf_error;
+	u64 rx_invalid_error;
+	u64 tx_timeout;
+
+	u64 tx_stop_queue;
+	u64 rx_dma_ua;
+	u64 rx_dma_stop;
+	u64 tx_dma_ua;
+	u64 tx_dma_stop;
+	u64 rx_hw_csum;
+	u64 tx_hw_csum;
+
+	u64 rx_int;
+	u64 tx_int;
+	u64 tx_early_int;
+	u64 tx_underflow_int;
+	u64 tx_timeout_int;
+	u64 rx_early_int;
+	u64 rx_overflow_int;
+	u64 rx_timeout_int;
+	u64 rgmii_state_int;
+
+	u64 tx_used_desc;
+	u64 napi_schedule;
+	u64 napi_underflow;
+};
+
+/* The datasheet said that each descriptor can transfers up to 4096bytes
+ * But latter, a register documentation reduce that value to 2048
+ * Anyway using 2048 cause strange behaviours and even BSP driver use 2047
+ */
+#define DESC_BUF_MAX 2044
+
+/* MAGIC value for knowing if a descriptor is available or not */
+#define DCLEAN cpu_to_le32(BIT(16) | BIT(14) | BIT(12) | BIT(10) | BIT(9))
+
+/* struct dma_desc - Structure of DMA descriptor used by the hardware
+ * @status:	Status of the frame written by HW, so RO for the
+ *		driver (except for BIT(31) which is R/W)
+ * @ctl:	Information on the frame written by the driver (INT, len,...)
+ * @buf_addr:	physical address of the frame data
+ * @next:	physical address of next dma_desc
+ */
+struct dma_desc {
+	__le32 status;
+	__le32 ctl;
+	__le32 buf_addr;
+	__le32 next;
+};
+
+/* Describe how data from skb are DMA mapped (used in txinfo map member) */
+#define MAP_SINGLE 1
+#define MAP_PAGE 2
+
+/* Structure for storing information about data in TX ring buffer */
+struct txinfo {
+	struct sk_buff *skb;
+	int map;
+};
+
+struct sun8i_emac_priv {
+	void __iomem *base;
+	struct regmap *regmap;
+	int irq;
+	struct device *dev;
+	struct net_device *ndev;
+	struct mii_bus *mdio;
+	struct napi_struct napi;
+	spinlock_t tx_lock;/* control the access of transmit descriptors */
+	int duplex;
+	int speed;
+	int link;
+	int phy_interface;
+	const struct emac_variant *variant;
+	struct device_node *phy_node;
+	struct clk *ahb_clk;
+	struct clk *ephy_clk;
+	bool use_internal_phy;
+
+	struct reset_control *rst_mac;
+	struct reset_control *rst_ephy;
+
+	struct dma_desc *dd_rx;
+	dma_addr_t dd_rx_phy;
+	struct dma_desc *dd_tx;
+	dma_addr_t dd_tx_phy;
+	struct sk_buff **rx_skb;
+	struct txinfo *txl;
+
+	int nbdesc_tx;
+	int nbdesc_rx;
+	int tx_slot;
+	int tx_dirty;
+	int rx_dirty;
+	struct sun8i_emac_stats estats;
+	u32 msg_enable;
+	int flow_ctrl;
+	int pause;
+};
+
+static irqreturn_t sun8i_emac_dma_interrupt(int irq, void *dev_id);
+
+static void rb_inc(int *p, const int max)
+{
+	(*p)++;
+	(*p) %= max;
+}
+
+/* Locking strategy:
+ * RX queue does not need any lock since only sun8i_emac_poll() access it.
+ * (All other RX modifiers (ringparam/ndo_stop) disable NAPI and so
+ * sun8i_emac_poll())
+ * TX queue is handled by sun8i_emac_xmit(), sun8i_emac_complete_xmit() and
+ * sun8i_emac_tx_timeout()
+ * (All other RX modifiers (ringparam/ndo_stop) disable NAPI and stop queue)
+ *
+ * sun8i_emac_xmit() could fire only once (netif_tx_lock)
+ * sun8i_emac_complete_xmit() could fire only once (called from NAPI)
+ * sun8i_emac_tx_timeout() could fire only once (netif_tx_lock) and could not
+ * race with sun8i_emac_xmit (due to netif_tx_lock) and with
+ * sun8i_emac_complete_xmit which disable NAPI.
+ *
+ * So only sun8i_emac_xmit and sun8i_emac_complete_xmit could fire at the same
+ * time.
+ * But they never could modify the same descriptors:
+ * - sun8i_emac_complete_xmit() will modify only descriptors with empty status
+ * - sun8i_emac_xmit() will modify only descriptors set to DCLEAN
+ * Proper memory barriers ensure that descriptor set to DCLEAN could not be
+ * modified latter by sun8i_emac_complete_xmit().
+ */
+
+/* Return the number of contiguous free descriptors
+ * starting from tx_slot
+ */
+static int rb_tx_numfreedesc(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (priv->tx_slot < priv->tx_dirty)
+		return priv->tx_dirty - priv->tx_slot;
+
+	return (priv->nbdesc_tx - priv->tx_slot) + priv->tx_dirty;
+}
+
+/* sun8i_emac_rx_skb - Allocate a skb in a DMA descriptor
+ *
+ * @ndev:	The net_device for this interface
+ * @i:		index of slot to fill
+ *
+ * Refill a DMA descriptor with a fresh skb and map it for DMA.
+*/
+static int sun8i_emac_rx_skb(struct net_device *ndev, int i)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	struct sk_buff *skb;
+
+	ddesc = priv->dd_rx + i;
+
+	ddesc->ctl = 0;
+
+	skb = netdev_alloc_skb_ip_align(ndev, DESC_BUF_MAX);
+	if (!skb)
+		return -ENOMEM;
+
+	/* should not happen */
+	if (unlikely(priv->rx_skb[i]))
+		dev_warn(priv->dev, "BUG: Leaking a skbuff\n");
+
+	priv->rx_skb[i] = skb;
+
+	ddesc->buf_addr = dma_map_single(priv->dev, skb->data,
+					 DESC_BUF_MAX, DMA_FROM_DEVICE);
+	if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+		dev_err(priv->dev, "ERROR: Cannot map RX buffer for DMA\n");
+		dev_kfree_skb(skb);
+		return -EFAULT;
+	}
+	/* We cannot direcly use cpu_to_le32() after dma_map_single
+	 * since dma_mapping_error use it
+	 */
+	ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+	ddesc->ctl |= cpu_to_le32(DESC_BUF_MAX);
+	/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	wmb();
+	ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+
+	return 0;
+}
+
+static void sun8i_emac_stop_tx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	netif_stop_queue(ndev);
+
+	v = readl(priv->base + EMAC_TX_CTL0);
+	/* Disable transmitter after current reception */
+	v &= ~EMAC_TX_TRANSMITTER_EN;
+	writel(v, priv->base + EMAC_TX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	/* Stop TX DMA */
+	v &= ~EMAC_TX_DMA_EN;
+	writel(v, priv->base + EMAC_TX_CTL1);
+
+	/* We must be sure that all is stopped before leaving this function */
+	wmb();
+}
+
+static void sun8i_emac_stop_rx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* Disable receiver after current reception */
+	v &= ~EMAC_RX_RECEIVER_EN;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	/* Stop RX DMA */
+	v &= ~EMAC_RX_DMA_EN;
+	writel(v, priv->base + EMAC_RX_CTL1);
+
+	/* We must be sure that all is stopped before leaving this function */
+	wmb();
+}
+
+static void sun8i_emac_start_rx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* Enable receiver */
+	v |= EMAC_RX_RECEIVER_EN;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	v |= EMAC_RX_DMA_START;
+	v |= EMAC_RX_DMA_EN;
+	writel(v, priv->base + EMAC_RX_CTL1);
+}
+
+static void sun8i_emac_start_tx(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_TX_CTL0);
+	v |= EMAC_TX_TRANSMITTER_EN;
+	writel(v, priv->base + EMAC_TX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	v |= EMAC_TX_DMA_START;
+	v |= EMAC_TX_DMA_EN;
+	writel(v, priv->base + EMAC_TX_CTL1);
+}
+
+/* sun8i_emac_set_macaddr - Set MAC address for slot index
+ *
+ * @addr: the MAC address to set
+ * @index: The index of slot where to set address.
+ *
+ * The slot 0 is the main MAC address
+ */
+static void sun8i_emac_set_macaddr(struct sun8i_emac_priv *priv,
+				   const u8 *addr, int index)
+{
+	u32 v;
+
+	dev_info(priv->dev, "device MAC address slot %d %pM", index, addr);
+
+	v = (addr[5] << 8) | addr[4];
+	writel(v, priv->base + EMAC_MACADDR_HI + index * 8);
+
+	v = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
+	writel(v, priv->base + EMAC_MACADDR_LO + index * 8);
+}
+
+static void sun8i_emac_set_link_mode(struct sun8i_emac_priv *priv)
+{
+	u32 v;
+
+	v = readl(priv->base + EMAC_BASIC_CTL0);
+
+	if (priv->duplex)
+		v |= EMAC_BCTL0_FD;
+	else
+		v &= ~EMAC_BCTL0_FD;
+
+	v &= ~EMAC_BCTL0_SPEED_MASK;
+
+	switch (priv->speed) {
+	case 1000:
+		break;
+	case 100:
+		v |= EMAC_BCTL0_SPEED_100 << EMAC_BCTL0_SPEED_SHIFT;
+		break;
+	case 10:
+		v |= EMAC_BCTL0_SPEED_10 << EMAC_BCTL0_SPEED_SHIFT;
+		break;
+	default:
+		dev_err(priv->dev, "Unsupported speed %d\n", priv->speed);
+		return;
+	}
+
+	writel(v, priv->base + EMAC_BASIC_CTL0);
+}
+
+static void sun8i_emac_flow_ctrl(struct sun8i_emac_priv *priv, int duplex,
+				 int fc)
+{
+	u32 flow = 0;
+
+	flow = readl(priv->base + EMAC_RX_CTL0);
+	if (fc & EMAC_FLOW_RX)
+		flow |= BIT(16);
+	else
+		flow &= ~BIT(16);
+	writel(flow, priv->base + EMAC_RX_CTL0);
+
+	flow = readl(priv->base + EMAC_TX_FLOW_CTL);
+	if (fc & EMAC_FLOW_TX)
+		flow |= BIT(0);
+	else
+		flow &= ~BIT(0);
+	writel(flow, priv->base + EMAC_TX_FLOW_CTL);
+}
+
+/* Grab a frame into a skb from descriptor number i */
+static int sun8i_emac_rx_from_ddesc(struct net_device *ndev, int i)
+{
+	struct sk_buff *skb;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc = priv->dd_rx + i;
+	int frame_len;
+	int rxcsum_done = 0;
+	u32 dstatus = le32_to_cpu(ddesc->status);
+
+	if (ndev->features & NETIF_F_RXCSUM)
+		rxcsum_done = 1;
+
+	/* bit0/bit7 work only on IPv4/IPv6 TCP traffic,
+	 * (not on ARP for example) so we do not raise rx_errors/discard frame
+	 */
+	/* the checksum or length of received frame's payload is wrong*/
+	if (dstatus & BIT(0)) {
+		priv->estats.rx_payload_error++;
+		rxcsum_done = 0;
+	}
+
+	/* RX_CRC_ERR */
+	if (dstatus & BIT(1)) {
+		priv->ndev->stats.rx_errors++;
+		priv->ndev->stats.rx_crc_errors++;
+		priv->estats.rx_crc_error++;
+		goto discard_frame;
+	}
+
+	/* RX_PHY_ERR */
+	if ((dstatus & BIT(3))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_phy_error++;
+		goto discard_frame;
+	}
+
+	/* RX_LENGTH_ERR */
+	if ((dstatus & BIT(4))) {
+		priv->ndev->stats.rx_errors++;
+		priv->ndev->stats.rx_length_errors++;
+		priv->estats.rx_length_error++;
+		goto discard_frame;
+	}
+
+	/* RX_COL_ERR */
+	if ((dstatus & BIT(6))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_col_error++;
+		goto discard_frame;
+	}
+
+	/* RX_HEADER_ERR */
+	if ((dstatus & BIT(7))) {
+		priv->estats.rx_header_error++;
+		rxcsum_done = 0;
+	}
+
+	/* RX_OVERFLOW_ERR */
+	if ((dstatus & BIT(11))) {
+		priv->ndev->stats.rx_over_errors++;
+		priv->estats.rx_overflow_error++;
+		goto discard_frame;
+	}
+
+	/* RX_NO_ENOUGTH_BUF_ERR */
+	if ((dstatus & BIT(14))) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_buf_error++;
+		goto discard_frame;
+	}
+
+	/* BIT(9) is for the first frame, not having it is bad since we do not
+	 * handle Jumbo frame
+	 */
+	if ((dstatus & EMAC_DSC_RX_FIRST) == 0) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_invalid_error++;
+		goto discard_frame;
+	}
+
+	/* this frame is not the last */
+	if ((dstatus & EMAC_DSC_RX_LAST) == 0) {
+		priv->ndev->stats.rx_errors++;
+		priv->estats.rx_invalid_error++;
+		goto discard_frame;
+	}
+
+	frame_len = (dstatus >> 16) & 0x3FFF;
+	if (!(ndev->features & NETIF_F_RXFCS))
+		frame_len -= ETH_FCS_LEN;
+
+	skb = priv->rx_skb[i];
+
+	netif_dbg(priv, rx_status, priv->ndev,
+		  "%s from %02d %pad len=%d status=%x st=%x\n",
+		  __func__, i, &ddesc, frame_len, dstatus,
+		  cpu_to_le32(ddesc->ctl));
+
+	skb_put(skb, frame_len);
+
+	dma_unmap_single(priv->dev, le32_to_cpu(ddesc->buf_addr), DESC_BUF_MAX,
+			 DMA_FROM_DEVICE);
+	skb->protocol = eth_type_trans(skb, priv->ndev);
+	if (rxcsum_done) {
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		priv->estats.rx_hw_csum++;
+	} else {
+		skb->ip_summed = CHECKSUM_PARTIAL;
+	}
+
+	priv->ndev->stats.rx_packets++;
+	priv->ndev->stats.rx_bytes += frame_len;
+	priv->rx_skb[i] = NULL;
+
+	sun8i_emac_rx_skb(ndev, i);
+	napi_gro_receive(&priv->napi, skb);
+
+	return 0;
+	/* If the frame need to be dropped, we simply reuse the buffer */
+discard_frame:
+	ddesc->ctl = cpu_to_le32(DESC_BUF_MAX);
+	/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	wmb();
+	ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+	return 0;
+}
+
+/* Iterate over dma_desc for finding completed xmit.
+ *
+ * The problem is: how to know that a descriptor is sent and not just in
+ * preparation.
+ * Need to have status=0 and st set but this is the state of first frame just
+ * before setting the own-by-DMA bit.
+ * The solution is to used the artificial value DCLEAN.
+ */
+static int sun8i_emac_complete_xmit(struct net_device *ndev, int budget)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	int frame_len;
+	int work = 0;
+	unsigned int bytes_compl = 0, pkts_compl = 0;
+	u32 dstatus;
+
+	do {
+		ddesc = priv->dd_tx + priv->tx_dirty;
+
+		if (ddesc->status & EMAC_COULD_BE_USED_BY_DMA)
+			goto xmit_end;
+
+		if (ddesc->status == DCLEAN)
+			goto xmit_end;
+
+		dstatus = cpu_to_le32(ddesc->status);
+
+		if (ddesc->status == 0 && !ddesc->ctl) {
+			dev_err(priv->dev, "BUG: reached the void %d %d\n",
+				priv->tx_dirty, priv->tx_slot);
+			goto xmit_end;
+		}
+
+		/* TX_UNDERFLOW_ERR */
+		if (dstatus & BIT(1))
+			priv->ndev->stats.tx_errors++;
+		/* TX_DEFER_ERR */
+		if (dstatus & BIT(2))
+			priv->ndev->stats.tx_errors++;
+		/* BIT 6:3 numbers of collisions */
+		if (dstatus & 0x78)
+			priv->ndev->stats.collisions +=
+				(dstatus & 0x78) >> 3;
+		/* TX_COL_ERR_1 */
+		if (dstatus & BIT(8))
+			priv->ndev->stats.tx_errors++;
+		/* TX_COL_ERR_0 */
+		if (dstatus & BIT(9))
+			priv->ndev->stats.tx_errors++;
+		/* TX_CRS_ERR */
+		if (dstatus & BIT(10))
+			priv->ndev->stats.tx_carrier_errors++;
+		/* TX_PAYLOAD_ERR */
+		if (dstatus & BIT(12))
+			priv->ndev->stats.tx_errors++;
+		/* TX_LENGTH_ERR */
+		if (dstatus & BIT(14))
+			priv->ndev->stats.tx_errors++;
+		/* TX_HEADER_ERR */
+		if (dstatus & BIT(16))
+			priv->ndev->stats.tx_errors++;
+
+		frame_len = le32_to_cpu(ddesc->ctl) & 0x3FFF;
+		bytes_compl += frame_len;
+
+		if (priv->txl[priv->tx_dirty].map == MAP_SINGLE)
+			dma_unmap_single(priv->dev,
+					 le32_to_cpu(ddesc->buf_addr),
+					 frame_len, DMA_TO_DEVICE);
+		else
+			dma_unmap_page(priv->dev,
+				       le32_to_cpu(ddesc->buf_addr),
+				       frame_len, DMA_TO_DEVICE);
+		/* we can free skb only on last frame */
+		if (priv->txl[priv->tx_dirty].skb &&
+		    (ddesc->ctl & EMAC_DSC_TX_LAST)) {
+			dev_kfree_skb_irq(priv->txl[priv->tx_dirty].skb);
+			pkts_compl++;
+		}
+
+		priv->txl[priv->tx_dirty].skb = NULL;
+		priv->txl[priv->tx_dirty].map = 0;
+		ddesc->ctl = 0;
+		/* setting status to DCLEAN is the last value to be set */
+		wmb();
+		ddesc->status = DCLEAN;
+		work++;
+
+		rb_inc(&priv->tx_dirty, priv->nbdesc_tx);
+		ddesc = priv->dd_tx + priv->tx_dirty;
+	} while (ddesc->ctl &&
+		 !(ddesc->status & EMAC_COULD_BE_USED_BY_DMA) &&
+		 work < budget);
+
+xmit_end:
+	netdev_completed_queue(ndev, pkts_compl, bytes_compl);
+
+	/* if we don't have handled all packets */
+	if (work < budget)
+		work = 0;
+
+	if (netif_queue_stopped(ndev) &&
+	    rb_tx_numfreedesc(ndev) > MAX_SKB_FRAGS + 1)
+		netif_wake_queue(ndev);
+	return work;
+}
+
+static int sun8i_emac_poll(struct napi_struct *napi, int budget)
+{
+	struct sun8i_emac_priv *priv =
+		container_of(napi, struct sun8i_emac_priv, napi);
+	struct net_device *ndev = priv->ndev;
+	int worked;
+	struct dma_desc *ddesc;
+
+	priv->estats.napi_schedule++;
+	worked = sun8i_emac_complete_xmit(ndev, budget);
+
+	ddesc = priv->dd_rx + priv->rx_dirty;
+	while (!(ddesc->status & EMAC_COULD_BE_USED_BY_DMA) &&
+	       worked < budget) {
+		sun8i_emac_rx_from_ddesc(ndev, priv->rx_dirty);
+		worked++;
+		rb_inc(&priv->rx_dirty, priv->nbdesc_rx);
+		ddesc = priv->dd_rx + priv->rx_dirty;
+	};
+	if (worked < budget) {
+		priv->estats.napi_underflow++;
+		napi_complete(&priv->napi);
+		writel(EMAC_RX_INT | EMAC_TX_INT, priv->base + EMAC_INT_EN);
+	}
+	return worked;
+}
+
+static int sun8i_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
+{
+	struct net_device *ndev = bus->priv;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+	u32 reg;
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	reg &= ~MDIO_CMD_MII_WRITE;
+	reg &= ~MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+	reg |= (phy_reg << MDIO_CMD_MII_PHY_REG_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+
+	reg &= ~MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= (phy_addr << MDIO_CMD_MII_PHY_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= MDIO_CMD_MII_BUSY;
+
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	return readl(priv->base + EMAC_MDIO_DATA);
+}
+
+static int sun8i_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg,
+			    u16 data)
+{
+	struct net_device *ndev = bus->priv;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 reg;
+	int err;
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	reg &= ~MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+	reg |= (phy_reg << MDIO_CMD_MII_PHY_REG_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_REG_ADDR_MASK;
+
+	reg &= ~MDIO_CMD_MII_PHY_ADDR_MASK;
+	reg |= (phy_addr << MDIO_CMD_MII_PHY_ADDR_SHIFT) &
+		MDIO_CMD_MII_PHY_ADDR_MASK;
+
+	reg |= MDIO_CMD_MII_WRITE;
+	reg |= MDIO_CMD_MII_BUSY;
+
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+	writel(data, priv->base + EMAC_MDIO_DATA);
+
+	err = readl_poll_timeout(priv->base + EMAC_MDIO_CMD, reg,
+				 !(reg & MDIO_CMD_MII_BUSY), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "%s timeout %x\n", __func__, reg);
+		return err;
+	}
+
+	return 0;
+}
+
+static int sun8i_emac_mdio_register(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct mii_bus *bus;
+	int ret;
+
+	bus = mdiobus_alloc();
+	if (!bus) {
+		netdev_err(ndev, "Failed to allocate a new mdio bus\n");
+		return -ENOMEM;
+	}
+
+	bus->name = dev_name(priv->dev);
+	bus->read = &sun8i_mdio_read;
+	bus->write = &sun8i_mdio_write;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-%x", bus->name, priv->dev->id);
+
+	bus->parent = priv->dev;
+	bus->priv = ndev;
+
+	ret = of_mdiobus_register(bus, priv->dev->of_node);
+	if (ret) {
+		netdev_err(ndev, "Could not register a MDIO bus: %d\n", ret);
+		mdiobus_free(bus);
+		return ret;
+	}
+
+	priv->mdio = bus;
+
+	return 0;
+}
+
+static void sun8i_emac_mdio_unregister(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	mdiobus_unregister(priv->mdio);
+	mdiobus_free(priv->mdio);
+}
+
+/* Run within phydev->lock */
+static void sun8i_emac_adjust_link(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = ndev->phydev;
+	int new_state = 0;
+
+	netif_dbg(priv, link, priv->ndev,
+		  "%s link=%x duplex=%x speed=%x\n", __func__,
+		  phydev->link, phydev->duplex, phydev->speed);
+	if (!phydev)
+		return;
+
+	if (phydev->link) {
+		if (phydev->duplex != priv->duplex) {
+			new_state = 1;
+			priv->duplex = phydev->duplex;
+		}
+		if (phydev->pause)
+			sun8i_emac_flow_ctrl(priv, phydev->duplex,
+					     priv->flow_ctrl);
+
+		if (phydev->speed != priv->speed) {
+			new_state = 1;
+			priv->speed = phydev->speed;
+		}
+
+		if (priv->link == 0) {
+			new_state = 1;
+			priv->link = phydev->link;
+		}
+
+		netif_dbg(priv, link, priv->ndev,
+			  "%s new=%d link=%d pause=%d\n",
+			  __func__, new_state, priv->link, phydev->pause);
+		if (new_state)
+			sun8i_emac_set_link_mode(priv);
+	} else if (priv->link != phydev->link) {
+		new_state = 1;
+		priv->link = 0;
+		priv->speed = 0;
+		priv->duplex = -1;
+	}
+
+	if (new_state)
+		phy_print_status(phydev);
+}
+
+/* H3 specific bits for EPHY */
+#define H3_EPHY_ADDR_SHIFT	20
+#define H3_EPHY_LED_POL		BIT(17) /* 1: active low, 0: active high */
+#define H3_EPHY_SHUTDOWN	BIT(16) /* 1: shutdown, 0: power up */
+#define H3_EPHY_SELECT		BIT(15) /* 1: internal PHY, 0: external PHY */
+
+/* H3/A64 specific bits */
+#define SYSCON_RMII_EN		BIT(13) /* 1: enable RMII (overrides EPIT) */
+
+/* Generic system control EMAC_CLK bits */
+#define SYSCON_ETXDC_MASK		GENMASK(2, 0)
+#define SYSCON_ETXDC_SHIFT		10
+#define SYSCON_ERXDC_MASK		GENMASK(4, 0)
+#define SYSCON_ERXDC_SHIFT		5
+/* EMAC PHY Interface Type */
+#define SYSCON_EPIT			BIT(2) /* 1: RGMII, 0: MII */
+#define SYSCON_ETCS_MASK		GENMASK(1, 0)
+#define SYSCON_ETCS_MII		0x0
+#define SYSCON_ETCS_EXT_GMII	0x1
+#define SYSCON_ETCS_INT_GMII	0x2
+#define SYSCON_EMAC_REG		0x30
+
+static int sun8i_emac_set_syscon(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct device_node *node = priv->dev->of_node;
+	int ret;
+	u32 reg, val;
+
+	reg = priv->variant->default_syscon_value;
+
+	if (priv->variant->internal_phy) {
+		if (!priv->use_internal_phy) {
+			/* switch to external PHY interface */
+			reg &= ~H3_EPHY_SELECT;
+		} else {
+			reg |= H3_EPHY_SELECT;
+			reg &= ~H3_EPHY_SHUTDOWN;
+
+			if (of_property_read_bool(priv->phy_node,
+						  "allwinner,leds-active-low"))
+				reg |= H3_EPHY_LED_POL;
+
+			ret = of_mdio_parse_addr(priv->dev, priv->phy_node);
+			if (ret < 0) {
+				netdev_err(ndev, "Could not parse MDIO addr\n");
+				return ret;
+			}
+			/* of_mdio_parse_addr returns a valid (0 ~ 31) PHY
+			 * address. No need to mask it again.
+			 */
+			reg |= ret << H3_EPHY_ADDR_SHIFT;
+		}
+	}
+
+	if (!of_property_read_u32(node, "allwinner,tx-delay", &val)) {
+		if (val <= SYSCON_ETXDC_MASK) {
+			reg &= ~(SYSCON_ETXDC_MASK << SYSCON_ETXDC_SHIFT);
+			reg |= (val << SYSCON_ETXDC_SHIFT);
+		} else {
+			netdev_warn(ndev, "Invalid TX clock delay: %d\n", val);
+		}
+	}
+
+	if (!of_property_read_u32(node, "allwinner,rx-delay", &val)) {
+		if (val <= SYSCON_ERXDC_MASK) {
+			reg &= ~(SYSCON_ERXDC_MASK << SYSCON_ERXDC_SHIFT);
+			reg |= (val << SYSCON_ERXDC_SHIFT);
+		} else {
+			netdev_warn(ndev, "Invalid RX clock delay: %d\n", val);
+		}
+	}
+
+	/* Clear interface mode bits */
+	reg &= ~(SYSCON_ETCS_MASK | SYSCON_EPIT);
+	if (priv->variant->support_rmii)
+		reg &= ~SYSCON_RMII_EN;
+
+	switch (priv->phy_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		/* default */
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		reg |= SYSCON_EPIT | SYSCON_ETCS_INT_GMII;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		reg |= SYSCON_RMII_EN | SYSCON_ETCS_EXT_GMII;
+		break;
+	default:
+		netdev_err(ndev, "Unsupported interface mode: %s",
+			   phy_modes(priv->phy_interface));
+		return -EINVAL;
+	}
+
+	regmap_write(priv->regmap, SYSCON_EMAC_REG, reg);
+
+	return 0;
+}
+
+static void sun8i_emac_unset_syscon(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 reg = priv->variant->default_syscon_value;
+
+	regmap_write(priv->regmap, SYSCON_EMAC_REG, reg);
+}
+
+/* Set Management Data Clock, must be call after device reset */
+static void sun8i_emac_set_mdc(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	unsigned long rate;
+	u32 reg;
+
+	rate = clk_get_rate(priv->ahb_clk);
+	if (rate > 160000000)
+		reg = 0x3 << 20; /* AHB / 128 */
+	else if (rate > 80000000)
+		reg = 0x2 << 20; /* AHB / 64 */
+	else if (rate > 40000000)
+		reg = 0x1 << 20; /* AHB / 32 */
+	else
+		reg = 0x0 << 20; /* AHB / 16 */
+	netif_dbg(priv, link, ndev, "MDC auto : %x\n", reg);
+	writel(reg, priv->base + EMAC_MDIO_CMD);
+}
+
+/* "power" the device, by enabling clk/reset/regulators */
+static int sun8i_emac_power(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int ret;
+
+	ret = clk_prepare_enable(priv->ahb_clk);
+	if (ret) {
+		netdev_err(ndev, "Could not enable AHB clock\n");
+		return ret;
+	}
+
+	if (priv->rst_mac) {
+		ret = reset_control_deassert(priv->rst_mac);
+		if (ret) {
+			netdev_err(ndev, "Could not deassert reset\n");
+			goto err_reset;
+		}
+	}
+
+	if (priv->ephy_clk) {
+		ret = clk_prepare_enable(priv->ephy_clk);
+		if (ret) {
+			netdev_err(ndev, "Could not enable EPHY clock\n");
+			goto err_ephy_clk;
+		}
+	}
+
+	if (priv->rst_ephy) {
+		ret = reset_control_deassert(priv->rst_ephy);
+		if (ret) {
+			netdev_err(ndev, "Could not deassert EPHY reset\n");
+			goto err_ephy_reset;
+		}
+	}
+
+	return 0;
+
+err_ephy_reset:
+	if (priv->ephy_clk)
+		clk_disable_unprepare(priv->ephy_clk);
+err_ephy_clk:
+	if (priv->rst_mac)
+		reset_control_assert(priv->rst_mac);
+err_reset:
+	clk_disable_unprepare(priv->ahb_clk);
+	return ret;
+}
+
+/* "Unpower" the device, disabling clocks and regulators, asserting reset */
+static void sun8i_emac_unpower(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (priv->rst_ephy)
+		reset_control_assert(priv->rst_ephy);
+
+	if (priv->ephy_clk)
+		clk_disable_unprepare(priv->ephy_clk);
+
+	if (priv->rst_mac)
+		reset_control_assert(priv->rst_mac);
+
+	clk_disable_unprepare(priv->ahb_clk);
+}
+
+static int sun8i_emac_init(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct device_node *node = priv->dev->of_node;
+	const u8 *addr;
+
+	/* Try to get MAC address from DT, or assign a random one */
+	addr = of_get_mac_address(node);
+	if (addr)
+		ether_addr_copy(ndev->dev_addr, addr);
+	else
+		eth_hw_addr_random(ndev);
+
+	return sun8i_emac_power(ndev);
+}
+
+static void sun8i_emac_uninit(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	mdiobus_unregister(priv->mdio);
+
+	sun8i_emac_unpower(ndev);
+}
+
+static int sun8i_emac_mdio_probe(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+
+	phydev = of_phy_connect(ndev, priv->phy_node, &sun8i_emac_adjust_link,
+				0, priv->phy_interface);
+
+	if (!phydev) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return -ENODEV;
+	}
+
+	phy_attached_info(phydev);
+
+	/* mask with MAC supported features */
+	phydev->supported &= PHY_GBIT_FEATURES;
+	phydev->advertising = phydev->supported;
+
+	priv->link = 0;
+	priv->speed = 0;
+	priv->duplex = -1;
+
+	return 0;
+}
+
+/* Allocate both RX and TX ring buffer and init them
+ * This function also write the startbase of thoses ring in the device.
+ * All structures that help managing thoses rings are also handled
+ * by this functions (rx_skb/txl)
+ */
+static int sun8i_emac_alloc_rings(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	int err, i;
+
+	priv->rx_skb = kcalloc(priv->nbdesc_rx, sizeof(struct sk_buff *),
+			      GFP_KERNEL);
+	if (!priv->rx_skb) {
+		err = -ENOMEM;
+		goto rx_skb_error;
+	}
+	priv->txl = kcalloc(priv->nbdesc_tx, sizeof(struct txinfo), GFP_KERNEL);
+	if (!priv->txl) {
+		err = -ENOMEM;
+		goto tx_error;
+	}
+
+	/* allocate/init RX ring */
+	priv->dd_rx = dma_zalloc_coherent(priv->dev,
+			priv->nbdesc_rx * sizeof(struct dma_desc),
+			&priv->dd_rx_phy, GFP_KERNEL);
+	if (!priv->dd_rx) {
+		dev_err(priv->dev, "ERROR: cannot allocate DMA RX buffer");
+		err = -ENOMEM;
+		goto dma_rx_error;
+	}
+	ddesc = priv->dd_rx;
+	for (i = 0; i < priv->nbdesc_rx; i++) {
+		sun8i_emac_rx_skb(ndev, i);
+		ddesc->next = cpu_to_le32(priv->dd_rx_phy + (i + 1)
+			* sizeof(struct dma_desc));
+		ddesc++;
+	}
+	/* last descriptor point back to first one */
+	ddesc--;
+	ddesc->next = cpu_to_le32(priv->dd_rx_phy);
+
+	/* allocate/init TX ring */
+	priv->dd_tx = dma_zalloc_coherent(priv->dev,
+			priv->nbdesc_tx * sizeof(struct dma_desc),
+			&priv->dd_tx_phy, GFP_KERNEL);
+	if (!priv->dd_tx) {
+		dev_err(priv->dev, "ERROR: cannot allocate DMA TX buffer");
+		err = -ENOMEM;
+		goto dma_tx_error;
+	}
+	ddesc = priv->dd_tx;
+	for (i = 0; i < priv->nbdesc_tx; i++) {
+		ddesc->status = DCLEAN;
+		ddesc->ctl = 0;
+		ddesc->next = cpu_to_le32(priv->dd_tx_phy + (i + 1)
+			* sizeof(struct dma_desc));
+		ddesc++;
+	}
+	/* last descriptor point back to first one */
+	ddesc--;
+	ddesc->next = cpu_to_le32(priv->dd_tx_phy);
+	i--;
+
+	priv->tx_slot = 0;
+	priv->tx_dirty = 0;
+	priv->rx_dirty = 0;
+
+	/* write start of RX ring descriptor */
+	writel(priv->dd_rx_phy, priv->base + EMAC_RX_DESC_LIST);
+	/* write start of TX ring descriptor */
+	writel(priv->dd_tx_phy, priv->base + EMAC_TX_DESC_LIST);
+
+	return 0;
+dma_tx_error:
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+dma_rx_error:
+	kfree(priv->txl);
+tx_error:
+	kfree(priv->rx_skb);
+rx_skb_error:
+	return err;
+}
+
+static int sun8i_emac_open(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+	u32 v;
+
+	err = request_irq(priv->irq, sun8i_emac_dma_interrupt, 0,
+			  dev_name(priv->dev), ndev);
+	if (err) {
+		dev_err(priv->dev, "Cannot request IRQ: %d\n", err);
+		return err;
+	}
+
+	/* Set interface mode (and configure internal PHY on H3) */
+	err = sun8i_emac_set_syscon(ndev);
+	if (err)
+		goto err_irq;
+
+	/* Do SOFT RST */
+	v = readl(priv->base + EMAC_BASIC_CTL1);
+	writel(v | 0x01, priv->base + EMAC_BASIC_CTL1);
+
+	err = readl_poll_timeout(priv->base + EMAC_BASIC_CTL1, v,
+				 !(v & 0x01), 100, 10000);
+	if (err) {
+		dev_err(priv->dev, "EMAC reset timeout\n");
+		err = -EFAULT;
+		goto err_syscon;
+	}
+
+	sun8i_emac_set_mdc(ndev);
+
+	err = sun8i_emac_mdio_register(ndev);
+	if (err)
+		goto err_syscon;
+
+	err = sun8i_emac_mdio_probe(ndev);
+	if (err)
+		goto err_syscon;
+
+	/* DMA */
+	v = (8 << 24);/* burst len */
+	writel(v, priv->base + EMAC_BASIC_CTL1);
+
+	writel(EMAC_RX_INT | EMAC_TX_INT, priv->base + EMAC_INT_EN);
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	/* CHECK_CRC */
+	if (ndev->features & NETIF_F_RXCSUM)
+		v |= EMAC_RX_DO_CRC;
+	else
+		v &= ~EMAC_RX_DO_CRC;
+	/* STRIP_FCS */
+	if (ndev->features & NETIF_F_RXFCS)
+		v &= ~EMAC_RX_STRIP_FCS;
+	else
+		v |= EMAC_RX_STRIP_FCS;
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	v = readl(priv->base + EMAC_TX_CTL1);
+	/* TX_MD Transmission starts after a full frame located in TX DMA FIFO*/
+	v |= BIT(1);
+	/* Undocumented bit (called TX_NEXT_FRM in BSP), the original comment is
+	 * "Operating on second frame increase the performance
+	 * especially when transmit store-and-forward is used."
+	 */
+	v |= BIT(2);
+	writel(v, priv->base + EMAC_TX_CTL1);
+
+	v = readl(priv->base + EMAC_RX_CTL1);
+	/* RX_MD RX DMA reads data from RX DMA FIFO to host memory after a
+	 * complete frame has been written to RX DMA FIFO
+	*/
+	v |= BIT(1);
+	writel(v, priv->base + EMAC_RX_CTL1);
+
+	sun8i_emac_set_macaddr(priv, ndev->dev_addr, 0);
+
+	err = sun8i_emac_alloc_rings(ndev);
+	if (err) {
+		netdev_err(ndev, "Fail to allocate rings\n");
+		goto err_mdio;
+	}
+
+	phy_start(ndev->phydev);
+
+	sun8i_emac_start_rx(ndev);
+	sun8i_emac_start_tx(ndev);
+
+	netif_napi_add(ndev, &priv->napi, sun8i_emac_poll, 64);
+	napi_enable(&priv->napi);
+	netif_start_queue(ndev);
+
+	return 0;
+err_mdio:
+	phy_disconnect(ndev->phydev);
+err_syscon:
+	sun8i_emac_unset_syscon(ndev);
+err_irq:
+	free_irq(priv->irq, ndev);
+	return err;
+}
+
+/* Clean the TX ring of any accepted skb for xmit */
+static void sun8i_emac_tx_clean(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int i;
+	struct dma_desc *ddesc;
+	int frame_len;
+
+	for (i = 0; i < priv->nbdesc_tx; i++) {
+		if (priv->txl[i].skb) {
+			ddesc = priv->dd_tx + i;
+			frame_len = le32_to_cpu(ddesc->ctl) & 0x3FFF;
+			switch (priv->txl[i].map) {
+			case MAP_SINGLE:
+				dma_unmap_single(priv->dev,
+						 le32_to_cpu(ddesc->buf_addr),
+						 frame_len, DMA_TO_DEVICE);
+				break;
+			case MAP_PAGE:
+				dma_unmap_page(priv->dev,
+					       le32_to_cpu(ddesc->buf_addr),
+					       frame_len, DMA_TO_DEVICE);
+				break;
+			default:
+				dev_err(priv->dev, "Trying to free an empty slot\n");
+				continue;
+			}
+			dev_kfree_skb_any(priv->txl[i].skb);
+			priv->txl[i].skb = NULL;
+			ddesc->ctl = 0;
+			ddesc->status = DCLEAN;
+		}
+	}
+	priv->tx_slot = 0;
+	priv->tx_dirty = 0;
+}
+
+/* Clean the RX ring */
+static void sun8i_emac_rx_clean(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int i;
+	struct dma_desc *ddesc;
+
+	/* clean RX ring */
+	for (i = 0; i < priv->nbdesc_rx; i++)
+		if (priv->rx_skb[i]) {
+			ddesc = priv->dd_rx + i;
+			dma_unmap_single(priv->dev,
+					 le32_to_cpu(ddesc->buf_addr),
+					 DESC_BUF_MAX, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(priv->rx_skb[i]);
+			priv->rx_skb[i] = NULL;
+		}
+}
+
+static int sun8i_emac_stop(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	napi_disable(&priv->napi);
+
+	sun8i_emac_stop_tx(ndev);
+	sun8i_emac_stop_rx(ndev);
+
+	phy_stop(ndev->phydev);
+	phy_disconnect(ndev->phydev);
+
+	sun8i_emac_mdio_unregister(ndev);
+
+	sun8i_emac_unset_syscon(ndev);
+
+	free_irq(priv->irq, ndev);
+
+	sun8i_emac_rx_clean(ndev);
+	sun8i_emac_tx_clean(ndev);
+
+	kfree(priv->rx_skb);
+	kfree(priv->txl);
+
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+	dma_free_coherent(priv->dev, priv->nbdesc_tx * sizeof(struct dma_desc),
+			  priv->dd_tx, priv->dd_tx_phy);
+
+	return 0;
+}
+
+static netdev_tx_t sun8i_emac_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct dma_desc *ddesc;
+	struct dma_desc *first;
+	int i = 0, rbd_first;
+	unsigned int len, fraglen, tlen;
+	u32 v;
+	int n;
+	int nf;
+	const skb_frag_t *frag;
+	int do_csum = 0;
+
+	if (skb_put_padto(skb, ETH_ZLEN))
+		return NETDEV_TX_OK;
+	len = skb_headlen(skb);
+
+	n = skb_shinfo(skb)->nr_frags;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		do_csum = 1;
+		priv->estats.tx_hw_csum++;
+	}
+	netif_dbg(priv, tx_queued, ndev, "%s len=%u skblen=%u %x\n", __func__,
+		  len, skb->len,
+		  (skb->ip_summed == CHECKSUM_PARTIAL));
+
+	/* check for contigous space
+	 * We need at least 1(skb->data) + n(numfrags) + 1(one clean slot)
+	 */
+	if (rb_tx_numfreedesc(ndev) < n + 2) {
+		dev_err_ratelimited(priv->dev, "BUG!: TX is full %d %d\n",
+				    priv->tx_dirty, priv->tx_slot);
+		netif_stop_queue(ndev);
+		return NETDEV_TX_BUSY;
+	}
+	i = priv->tx_slot;
+
+	ddesc = priv->dd_tx + i;
+	first = priv->dd_tx + i;
+	rbd_first = i;
+
+	ddesc->buf_addr = dma_map_single(priv->dev, skb->data, len,
+					 DMA_TO_DEVICE);
+	if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+		dev_err(priv->dev, "ERROR: Cannot map buffer for DMA\n");
+		goto xmit_error;
+	}
+	/* We cannot direcly use cpu_to_le32() after dma_map_single
+	 * since dma_mapping_error use it
+	 */
+	ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+	priv->txl[i].map = MAP_SINGLE;
+	priv->txl[i].skb = skb;
+
+	tlen = len;
+	ddesc->ctl = le32_to_cpu(len);
+	/* Undocumented bit that make it works
+	 * Without it, packets never be sent on H3 SoC
+	 */
+	ddesc->ctl |= EMAC_MAGIC_TX_BIT;
+	if (do_csum)
+		ddesc->ctl |= EMAC_TX_DO_CRC;
+
+	/* handle fragmented skb, one descriptor per fragment  */
+	for (nf = 0; nf < n; nf++) {
+		frag = &skb_shinfo(skb)->frags[nf];
+		rb_inc(&i, priv->nbdesc_tx);
+		priv->txl[i].skb = skb;
+		ddesc = priv->dd_tx + i;
+		fraglen = skb_frag_size(frag);
+		ddesc->ctl = le32_to_cpu(fraglen);
+		tlen += fraglen,
+		ddesc->ctl |= EMAC_MAGIC_TX_BIT;
+		if (do_csum)
+			ddesc->ctl |= EMAC_TX_DO_CRC;
+
+		ddesc->buf_addr = skb_frag_dma_map(priv->dev, frag, 0,
+				fraglen, DMA_TO_DEVICE);
+		if (dma_mapping_error(priv->dev, ddesc->buf_addr)) {
+			dev_err(priv->dev, "Cannot map buffer for DMA\n");
+			goto xmit_error;
+		}
+		/* Cannot directly use cpu_to_le32() after skb_frag_dma_map
+		 * since dma_mapping_error use it
+		 */
+		ddesc->buf_addr = cpu_to_le32(ddesc->buf_addr);
+		priv->txl[i].map = MAP_PAGE;
+		ddesc->status = EMAC_COULD_BE_USED_BY_DMA;
+	}
+
+	/* frame end */
+	ddesc->ctl |= EMAC_DSC_TX_LAST;
+	/* We want an interrupt after transmission */
+	ddesc->ctl |= EMAC_WANT_INT;
+
+	rb_inc(&i, priv->nbdesc_tx);
+
+	/* frame begin */
+	first->ctl |= EMAC_DSC_TX_FIRST;
+	wmb();/* EMAC_COULD_BE_USED_BY_DMA must be the last value written */
+	first->status = EMAC_COULD_BE_USED_BY_DMA;
+	priv->tx_slot = i;
+
+	/* Trying to optimize this (recording DMA start/stop) seems
+	 * to lead to errors. So we always start DMA.
+	 */
+	v = readl(priv->base + EMAC_TX_CTL1);
+	v |= EMAC_TX_DMA_START;
+	v |= EMAC_TX_DMA_EN;
+	writel_relaxed(v, priv->base + EMAC_TX_CTL1);
+
+	netdev_sent_queue(ndev, skb->len);
+
+	if (rb_tx_numfreedesc(ndev) < MAX_SKB_FRAGS + 1) {
+		netif_stop_queue(ndev);
+		priv->estats.tx_stop_queue++;
+	}
+	priv->estats.tx_used_desc = rb_tx_numfreedesc(ndev);
+	priv->ndev->stats.tx_packets++;
+	priv->ndev->stats.tx_bytes += tlen;
+
+	return NETDEV_TX_OK;
+
+xmit_error:
+	/* destroy skb and return TX OK Documentation/DMA-API-HOWTO.txt */
+	/* clean descritors from rbd_first to i */
+	ddesc->ctl = 0;
+	/* setting status to DCLEAN is the last value to be set */
+	wmb();
+	ddesc->status = DCLEAN;
+	do {
+		ddesc = priv->dd_tx + rbd_first;
+		ddesc->ctl = 0;
+		/* setting status to DCLEAN is the last value to be set */
+		wmb();
+		ddesc->status = DCLEAN;
+		rb_inc(&rbd_first, priv->nbdesc_tx);
+	} while (rbd_first != i);
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int sun8i_emac_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int max_mtu;
+
+	dev_info(priv->dev, "%s set MTU to %d\n", __func__, new_mtu);
+
+	if (netif_running(ndev)) {
+		dev_err(priv->dev, "%s: must be stopped to change its MTU\n",
+			ndev->name);
+		return -EBUSY;
+	}
+
+	max_mtu = SKB_MAX_HEAD(NET_SKB_PAD + NET_IP_ALIGN);
+
+	if ((new_mtu < 68) || (new_mtu > max_mtu)) {
+		dev_err(priv->dev, "%s: invalid MTU, max MTU is: %d\n",
+			ndev->name, max_mtu);
+		return -EINVAL;
+	}
+
+	ndev->mtu = new_mtu;
+	netdev_update_features(ndev);
+	return 0;
+}
+
+static int sun8i_emac_set_features(struct net_device *ndev,
+				   netdev_features_t features)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v;
+
+	v = readl(priv->base + EMAC_BASIC_CTL0);
+	if (features & NETIF_F_LOOPBACK && netif_running(ndev)) {
+		netif_info(priv, hw, ndev, "Set loopback features");
+		v |= BIT(1);
+	} else {
+		netif_info(priv, hw, ndev, "Unset loopback features");
+		v &= ~BIT(1);
+	}
+	writel(v, priv->base + EMAC_BASIC_CTL0);
+
+	v = readl(priv->base + EMAC_RX_CTL0);
+	if (features & NETIF_F_RXCSUM) {
+		v |= EMAC_RX_DO_CRC;
+		netif_info(priv, hw, ndev, "Doing RX CRC check by hardware");
+	} else {
+		v &= ~EMAC_RX_DO_CRC;
+		netif_info(priv, hw, ndev, "No RX CRC check by hardware");
+	}
+	if (features & NETIF_F_RXFCS) {
+		v &= ~EMAC_RX_STRIP_FCS;
+		netif_info(priv, hw, ndev, "Keep FCS");
+	} else {
+		v |= EMAC_RX_STRIP_FCS;
+		netif_info(priv, hw, ndev, "Strip FCS");
+	}
+	writel(v, priv->base + EMAC_RX_CTL0);
+
+	netif_dbg(priv, drv, ndev, "%s %llx %x\n", __func__, features, v);
+
+	return 0;
+}
+
+static void sun8i_emac_set_rx_mode(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v = 0;
+	int i = 0;
+	struct netdev_hw_addr *ha;
+
+	/* Receive all multicast frames */
+	v |= BIT(16);
+	/* Receive all control frames */
+	v |= BIT(13);
+	if (ndev->flags & IFF_PROMISC)
+		v |= BIT(1);
+	if (netdev_uc_count(ndev) > 7) {
+		v |= BIT(1);
+	} else {
+		netdev_for_each_uc_addr(ha, ndev) {
+			i++;
+			sun8i_emac_set_macaddr(priv, ha->addr, i);
+		}
+	}
+	writel(v, priv->base + EMAC_RX_FRM_FLT);
+}
+
+static void sun8i_emac_tx_timeout(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	netdev_err(ndev, "%s\n", __func__);
+
+	sun8i_emac_stop_tx(ndev);
+
+	sun8i_emac_tx_clean(ndev);
+
+	/* write start of the new TX ring descriptor */
+	writel(priv->dd_tx_phy, priv->base + EMAC_TX_DESC_LIST);
+
+	sun8i_emac_start_tx(ndev);
+
+	netdev_reset_queue(ndev);
+
+	priv->estats.tx_timeout++;
+	ndev->stats.tx_errors++;
+	netif_wake_queue(ndev);
+}
+
+static int sun8i_emac_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	struct phy_device *phydev = ndev->phydev;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_mii_ioctl(phydev, rq, cmd);
+}
+
+static int sun8i_emac_check_if_running(struct net_device *ndev)
+{
+	if (!netif_running(ndev))
+		return -EINVAL;
+	return 0;
+}
+
+static int sun8i_emac_get_sset_count(struct net_device *ndev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(estats_str);
+	}
+	return -EOPNOTSUPP;
+}
+
+static int sun8i_emac_ethtool_get_settings(struct net_device *ndev,
+					   struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	if (!phy) {
+		netdev_err(ndev, "%s: %s: PHY is not registered\n",
+			   __func__, ndev->name);
+		return -ENODEV;
+	}
+
+	if (!netif_running(ndev)) {
+		dev_err(priv->dev, "interface disabled: we cannot track link speed / duplex setting\n");
+		return -EBUSY;
+	}
+
+	return phy_ethtool_gset(phy, cmd);
+}
+
+static int sun8i_emac_ethtool_set_settings(struct net_device *ndev,
+					   struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+
+	return phy_ethtool_sset(phy, cmd);
+}
+
+static void sun8i_emac_ethtool_getdrvinfo(struct net_device *ndev,
+					  struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, "sun8i_emac", sizeof(info->driver));
+	strcpy(info->version, "00");
+	info->fw_version[0] = '\0';
+}
+
+static void sun8i_emac_ethtool_stats(struct net_device *ndev,
+				     struct ethtool_stats *dummy, u64 *data)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	memcpy(data, &priv->estats,
+	       sun8i_emac_get_sset_count(ndev, ETH_SS_STATS) * sizeof(u64));
+}
+
+static void sun8i_emac_ethtool_strings(struct net_device *dev, u32 stringset,
+				       u8 *buffer)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(buffer, &estats_str, sizeof(estats_str));
+		break;
+	}
+}
+
+static u32 sun8i_emac_ethtool_getmsglevel(struct net_device *ndev)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	return priv->msg_enable;
+}
+
+static void sun8i_emac_ethtool_setmsglevel(struct net_device *ndev, u32 level)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	priv->msg_enable = level;
+}
+
+static void sun8i_emac_get_pauseparam(struct net_device *ndev,
+				      struct ethtool_pauseparam *pause)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	pause->rx_pause = 0;
+	pause->tx_pause = 0;
+	pause->autoneg = ndev->phydev->autoneg;
+
+	if (priv->flow_ctrl & EMAC_FLOW_RX)
+		pause->rx_pause = 1;
+	if (priv->flow_ctrl & EMAC_FLOW_TX)
+		pause->tx_pause = 1;
+}
+
+static int sun8i_emac_set_pauseparam(struct net_device *ndev,
+				     struct ethtool_pauseparam *pause)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	struct phy_device *phy = ndev->phydev;
+	int new_pause = 0;
+	int ret = 0;
+
+	if (pause->rx_pause)
+		new_pause |= EMAC_FLOW_RX;
+	if (pause->tx_pause)
+		new_pause |= EMAC_FLOW_TX;
+
+	priv->flow_ctrl = new_pause;
+	phy->autoneg = pause->autoneg;
+
+	if (phy->autoneg) {
+		if (netif_running(ndev))
+			ret = phy_start_aneg(phy);
+	} else {
+		sun8i_emac_flow_ctrl(priv, phy->duplex, priv->flow_ctrl);
+	}
+	return ret;
+}
+
+static void sun8i_emac_ethtool_get_ringparam(struct net_device *ndev,
+					     struct ethtool_ringparam *ring)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+
+	ring->rx_pending = priv->nbdesc_rx;
+	ring->tx_pending = priv->nbdesc_tx;
+}
+
+static int sun8i_emac_ethtool_set_ringparam(struct net_device *ndev,
+					    struct ethtool_ringparam *ring)
+{
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	int err;
+
+	if (ring->rx_max_pending || ring->rx_mini_max_pending ||
+	    ring->rx_jumbo_max_pending || ring->rx_mini_pending ||
+	    ring->rx_jumbo_pending || ring->tx_max_pending)
+		return -EINVAL;
+
+	if (ring->tx_pending < MAX_SKB_FRAGS + 1) {
+		netdev_err(ndev, "The number of TX descriptors is too low");
+		return -EINVAL;
+	}
+
+	sun8i_emac_stop_tx(ndev);
+	sun8i_emac_stop_rx(ndev);
+
+	sun8i_emac_rx_clean(ndev);
+	sun8i_emac_tx_clean(ndev);
+
+	kfree(priv->rx_skb);
+	kfree(priv->txl);
+
+	dma_free_coherent(priv->dev, priv->nbdesc_rx * sizeof(struct dma_desc),
+			  priv->dd_rx, priv->dd_rx_phy);
+	dma_free_coherent(priv->dev, priv->nbdesc_tx * sizeof(struct dma_desc),
+			  priv->dd_tx, priv->dd_tx_phy);
+
+	priv->nbdesc_rx = ring->rx_pending;
+	priv->nbdesc_tx = ring->tx_pending;
+	err = sun8i_emac_alloc_rings(ndev);
+	if (err) {
+		/* Fatal error, we cannot re start */
+		netdev_err(ndev, "Fail to allocate rings\n");
+		return -EFAULT;
+	}
+
+	sun8i_emac_start_rx(ndev);
+	sun8i_emac_start_tx(ndev);
+
+	netif_start_queue(ndev);
+
+	netdev_info(ndev, "Ring Param settings: rx: %d, tx %d\n",
+		    ring->rx_pending, ring->tx_pending);
+	return 0;
+}
+
+static const struct ethtool_ops sun8i_emac_ethtool_ops = {
+	.begin = sun8i_emac_check_if_running,
+	.get_settings = sun8i_emac_ethtool_get_settings,
+	.set_settings = sun8i_emac_ethtool_set_settings,
+	.get_link = ethtool_op_get_link,
+	.get_pauseparam = sun8i_emac_get_pauseparam,
+	.set_pauseparam = sun8i_emac_set_pauseparam,
+	.get_ethtool_stats = sun8i_emac_ethtool_stats,
+	.get_strings = sun8i_emac_ethtool_strings,
+	.get_sset_count = sun8i_emac_get_sset_count,
+	.get_drvinfo = sun8i_emac_ethtool_getdrvinfo,
+	.get_msglevel = sun8i_emac_ethtool_getmsglevel,
+	.set_msglevel = sun8i_emac_ethtool_setmsglevel,
+	.get_ringparam = sun8i_emac_ethtool_get_ringparam,
+	.set_ringparam = sun8i_emac_ethtool_set_ringparam,
+};
+
+static const struct net_device_ops sun8i_emac_netdev_ops = {
+	.ndo_init = sun8i_emac_init,
+	.ndo_uninit = sun8i_emac_uninit,
+	.ndo_open = sun8i_emac_open,
+	.ndo_start_xmit = sun8i_emac_xmit,
+	.ndo_stop = sun8i_emac_stop,
+	.ndo_change_mtu = sun8i_emac_change_mtu,
+	.ndo_set_features = sun8i_emac_set_features,
+	.ndo_set_rx_mode = sun8i_emac_set_rx_mode,
+	.ndo_tx_timeout = sun8i_emac_tx_timeout,
+	.ndo_do_ioctl = sun8i_emac_ioctl,
+	.ndo_set_mac_address = eth_mac_addr,
+};
+
+/* No locking in this function since it is guaranteed to be run once and
+ * do actions only done here:
+ * - Scheduling NAPI
+ * - Stopping interrupts
+ * - Updating stats
+ *
+ * Even when not enabled via EMAC_INT_EN, some interrupt could fire, so we need
+ * to handle all of them.
+ * Interrupts know to fire when not enabled are:
+ * - EMAC_TX_DMA_STOP_INT
+ * - EMAC_TX_BUF_UA_INT
+ * - EMAC_TX_EARLY_INT
+ * - EMAC_RX_BUF_UA_INT
+ * - EMAC_RX_EARLY_INT
+ */
+static irqreturn_t sun8i_emac_dma_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct sun8i_emac_priv *priv = netdev_priv(ndev);
+	u32 v, u;
+
+	v = readl(priv->base + EMAC_INT_STA);
+
+	/* When this bit is asserted, a frame transmission is completed. */
+	if (v & EMAC_TX_INT) {
+		priv->estats.tx_int++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	/* When this bit is asserted, the TX DMA FSM is stopped.
+	 * For the moment only a call to tx_timeout cause this interrupt
+	 * to fire.
+	 */
+	if (v & EMAC_TX_DMA_STOP_INT)
+		priv->estats.tx_dma_stop++;
+
+	/* When this asserted, the TX DMA can not acquire next TX descriptor
+	 * and TX DMA FSM is suspended.
+	*/
+	if (v & EMAC_TX_BUF_UA_INT) {
+		priv->estats.tx_dma_ua++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	if (v & EMAC_TX_TIMEOUT_INT)
+		priv->estats.tx_timeout_int++;
+
+	if (v & EMAC_TX_UNDERFLOW_INT)
+		priv->estats.tx_underflow_int++;
+
+	/* When this bit asserted , the frame is transmitted to FIFO totally. */
+	if (v & EMAC_TX_EARLY_INT)
+		priv->estats.tx_early_int++;
+
+	/* When this bit is asserted, a frame reception is completed  */
+	if (v & EMAC_RX_INT) {
+		priv->estats.rx_int++;
+		writel(0, priv->base + EMAC_INT_EN);
+		napi_schedule(&priv->napi);
+	}
+
+	/* When this asserted, the RX DMA can not acquire next RX descriptor
+	 * and RX DMA FSM is suspended.
+	*/
+	if (v & EMAC_RX_BUF_UA_INT) {
+		u = readl(priv->base + EMAC_RX_CTL1);
+		writel(u | EMAC_RX_DMA_START, priv->base + EMAC_RX_CTL1);
+		priv->estats.rx_dma_ua++;
+	}
+
+	/* Same as TX DMA STOP, but never hit it */
+	if (v & EMAC_RX_DMA_STOP_INT)
+		priv->estats.rx_dma_stop++;
+
+	if (v & EMAC_RX_TIMEOUT_INT)
+		priv->estats.rx_timeout_int++;
+
+	if (v & EMAC_RX_OVERFLOW_INT)
+		priv->estats.rx_overflow_int++;
+
+	if (v & EMAC_RX_EARLY_INT)
+		priv->estats.rx_early_int++;
+
+	if (v & EMAC_RGMII_STA_INT)
+		priv->estats.rgmii_state_int++;
+
+	/* the datasheet state those register as read-only
+	 * but nothing work(freeze) without writing to it
+	 */
+	writel(v, priv->base + EMAC_INT_STA);
+
+	return IRQ_HANDLED;
+}
+
+static int sun8i_emac_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct sun8i_emac_priv *priv;
+	struct net_device *ndev;
+	struct resource *res;
+	int ret;
+
+	ndev = alloc_etherdev(sizeof(*priv));
+	if (!ndev)
+		return -ENOMEM;
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+	priv = netdev_priv(ndev);
+	platform_set_drvdata(pdev, ndev);
+
+	priv->variant = of_device_get_match_data(&pdev->dev);
+	if (!priv->variant) {
+		dev_err(&pdev->dev, "Missing sun8i-emac variant\n");
+		return -EINVAL;
+	}
+
+	priv->phy_node = of_parse_phandle(node, "phy", 0);
+	if (!priv->phy_node) {
+		netdev_err(ndev, "No associated PHY\n");
+		return -ENODEV;
+	}
+
+	priv->regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+						       "syscon");
+	if (IS_ERR(priv->regmap)) {
+		ret = PTR_ERR(priv->regmap);
+		dev_err(&pdev->dev, "unable to map SYSCON:%d\n", ret);
+		return ret;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->base)) {
+		ret = PTR_ERR(priv->base);
+		dev_err(&pdev->dev, "Cannot request MMIO: %d\n", ret);
+		return ret;
+	}
+
+	priv->ahb_clk = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(priv->ahb_clk)) {
+		ret = PTR_ERR(priv->ahb_clk);
+		dev_err(&pdev->dev, "Cannot get AHB clock err=%d\n", ret);
+		goto probe_err;
+	}
+
+	priv->rst_mac = devm_reset_control_get_optional(&pdev->dev, "ahb");
+	if (IS_ERR(priv->rst_mac)) {
+		ret = PTR_ERR(priv->rst_mac);
+		if (ret == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(&pdev->dev, "No MAC reset control found %d\n", ret);
+		priv->rst_mac = NULL;
+	}
+
+	priv->phy_interface = of_get_phy_mode(node);
+	if (priv->phy_interface < 0) {
+		netdev_err(ndev, "PHY interface mode node unspecified\n");
+		return priv->phy_interface;
+	}
+
+	switch (priv->phy_interface) {
+	case PHY_INTERFACE_MODE_MII:
+		if (!priv->variant->support_mii)
+			return -EINVAL;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if (!priv->variant->support_rmii)
+			return -EINVAL;
+		break;
+	case PHY_INTERFACE_MODE_RGMII:
+		if (!priv->variant->support_rgmii)
+			return -EINVAL;
+		break;
+	default:
+		netdev_err(ndev, "Unsupported interface mode: %s",
+			   phy_modes(priv->phy_interface));
+		return -EINVAL;
+	}
+
+	if (priv->phy_interface == priv->variant->internal_phy)
+		priv->use_internal_phy = true;
+
+	if (priv->use_internal_phy) {
+		priv->ephy_clk = devm_clk_get(&pdev->dev, "ephy");
+		if (IS_ERR(priv->ephy_clk)) {
+			ret = PTR_ERR(priv->ephy_clk);
+			dev_err(&pdev->dev, "Cannot get EPHY clock err=%d\n",
+				ret);
+			goto probe_err;
+		}
+
+		priv->rst_ephy = devm_reset_control_get_optional(&pdev->dev,
+								 "ephy");
+		if (IS_ERR(priv->rst_ephy)) {
+			ret = PTR_ERR(priv->rst_ephy);
+			if (ret == -EPROBE_DEFER)
+				goto probe_err;
+			dev_info(&pdev->dev,
+				 "No EPHY reset control found %d\n", ret);
+			priv->rst_ephy = NULL;
+		}
+	}
+
+	priv->irq = platform_get_irq(pdev, 0);
+	if (priv->irq < 0) {
+		ret = priv->irq;
+		dev_err(&pdev->dev, "Cannot claim IRQ: %d\n", ret);
+		goto probe_err;
+	}
+
+	spin_lock_init(&priv->tx_lock);
+
+	ndev->netdev_ops = &sun8i_emac_netdev_ops;
+	ndev->ethtool_ops = &sun8i_emac_ethtool_ops;
+
+	priv->ndev = ndev;
+	priv->dev = &pdev->dev;
+
+	ndev->hw_features = NETIF_F_SG | NETIF_F_HIGHDMA;
+	ndev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_RXCSUM;
+	ndev->features |= ndev->hw_features;
+	ndev->hw_features |= NETIF_F_RXFCS;
+	ndev->hw_features |= NETIF_F_RXALL;
+	ndev->hw_features |= NETIF_F_LOOPBACK;
+	ndev->priv_flags |= IFF_UNICAST_FLT;
+
+	ndev->watchdog_timeo = msecs_to_jiffies(5000);
+	netif_carrier_off(ndev);
+
+	/* Benched on OPIPC with 100M, setting more than 256 does not give any
+	 * perf boost
+	 */
+	priv->nbdesc_rx = 128;
+	priv->nbdesc_tx = 256;
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "ERROR: Register %s failed\n", ndev->name);
+		goto probe_err;
+	}
+
+	return 0;
+
+probe_err:
+	free_netdev(ndev);
+	return ret;
+}
+
+static int sun8i_emac_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+
+	unregister_netdev(ndev);
+	platform_set_drvdata(pdev, NULL);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static const struct of_device_id sun8i_emac_of_match_table[] = {
+	{ .compatible = "allwinner,sun8i-a83t-emac",
+	  .data = &emac_variant_a83t },
+	{ .compatible = "allwinner,sun8i-h3-emac",
+	  .data = &emac_variant_h3 },
+	{ .compatible = "allwinner,sun50i-a64-emac",
+	  .data = &emac_variant_a64 },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun8i_emac_of_match_table);
+
+static struct platform_driver sun8i_emac_driver = {
+	.probe          = sun8i_emac_probe,
+	.remove         = sun8i_emac_remove,
+	.driver         = {
+		.name           = "sun8i-emac",
+		.of_match_table	= sun8i_emac_of_match_table,
+	},
+};
+
+module_platform_driver(sun8i_emac_driver);
+
+MODULE_DESCRIPTION("sun8i Ethernet driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Corentin Labbe <clabbe.montjoie@xxxxxxxxx");
diff --git a/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c b/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c
new file mode 100644
index 0000000..5bd18f1
--- /dev/null
+++ b/drivers/pinctrl/sunxi/pinctrl-sun8i-a83t-r.c
@@ -0,0 +1,118 @@
+/*
+ * Allwinner A83T SoCs special pins pinctrl driver.
+ *
+ * Copyright (C) 2016 Vishnu Patekar
+ * Vishnu Patekar <vishnupatekar0510@gmail.com>
+ *
+ * Based on pinctrl-sun8i-a23.c, which is:
+ * Copyright (C) 2014 Chen-Yu Tsai <wens@csie.org>
+ * Copyright (C) 2014 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/reset.h>
+
+#include "pinctrl-sunxi.h"
+
+static const struct sunxi_desc_pin sun8i_a83t_r_pins[] = {
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_rsb"),		/* SCK */
+		  SUNXI_FUNCTION(0x3, "s_twi"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 0)),	/* PL_EINT0 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_rsb"),		/* SDA */
+		  SUNXI_FUNCTION(0x3, "s_twi"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 1)),	/* PL_EINT1 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_uart"),	/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 2)),	/* PL_EINT2 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_uart"),	/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 3)),	/* PL_EINT3 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 4),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* MS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 4)),	/* PL_EINT4 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 5),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* CK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 5)),	/* PL_EINT5 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 6),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* DO */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 6)),	/* PL_EINT6 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 7),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_jtag"),	/* DI */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 7)),	/* PL_EINT7 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 8),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_twi"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 8)),	/* PL_EINT8 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 9),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_twi"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 9)),	/* PL_EINT9 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 10),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_pwm"),
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 10)),	/* PL_EINT10 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 11),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 11)),	/* PL_EINT11 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(L, 12),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "s_cir"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 11)),	/* PL_EINT12 */
+};
+
+static const struct sunxi_pinctrl_desc sun8i_a83t_r_pinctrl_data = {
+	.pins = sun8i_a83t_r_pins,
+	.npins = ARRAY_SIZE(sun8i_a83t_r_pins),
+	.pin_base = PL_BASE,
+	.irq_banks = 1,
+};
+
+static int sun8i_a83t_r_pinctrl_probe(struct platform_device *pdev)
+{
+	return sunxi_pinctrl_init(pdev, &sun8i_a83t_r_pinctrl_data);
+}
+
+static const struct of_device_id sun8i_a83t_r_pinctrl_match[] = {
+	{ .compatible = "allwinner,sun8i-a83t-r-pinctrl", },
+	{}
+};
+
+static struct platform_driver sun8i_a83t_r_pinctrl_driver = {
+	.probe	= sun8i_a83t_r_pinctrl_probe,
+	.driver	= {
+		.name		= "sun8i-a83t-r-pinctrl",
+		.of_match_table	= sun8i_a83t_r_pinctrl_match,
+	},
+};
+module_platform_driver(sun8i_a83t_r_pinctrl_driver);
diff --git a/drivers/regulator/axp-regulator.h b/drivers/regulator/axp-regulator.h
new file mode 100644
index 0000000..085eaa0
--- /dev/null
+++ b/drivers/regulator/axp-regulator.h
@@ -0,0 +1,133 @@
+#ifndef __AXP_REGULATOR_H__
+#define __AXP_REGULATOR_H__
+/*
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#define AXP20X_IO_ENABLED		0x03
+#define AXP20X_IO_DISABLED		0x07
+
+#define AXP22X_IO_ENABLED		0x03
+#define AXP22X_IO_DISABLED		0x04
+
+#define AXP_DESC_IO(_family, _id, _match, _supply, _min, _max, _step, _vreg,	\
+		    _vmask, _ereg, _emask, _enable_val, _disable_val)		\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),		\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_min) * 1000,				\
+		.uV_step	= (_step) * 1000,				\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.enable_val	= (_enable_val),				\
+		.disable_val	= (_disable_val),				\
+		.ops		= &axp_ops,					\
+	}
+
+#define AXP_DESC(_family, _id, _match, _supply, _min, _max, _step, _vreg,	\
+		 _vmask, _ereg, _emask) 					\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (((_max) - (_min)) / (_step) + 1),		\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_min) * 1000,				\
+		.uV_step	= (_step) * 1000,				\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.ops		= &axp_ops,					\
+	}
+
+#define AXP_DESC_SW(_family, _id, _match, _supply, _ereg, _emask)		\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.owner		= THIS_MODULE,					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.ops		= &axp_ops_sw,					\
+	}
+
+#define AXP_DESC_FIXED(_family, _id, _match, _supply, _volt)			\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= 1,						\
+		.owner		= THIS_MODULE,					\
+		.min_uV		= (_volt) * 1000,				\
+		.ops		= &axp_ops_fixed				\
+	}
+
+#define AXP_DESC_RANGES(_family, _id, _match, _supply, _ranges, _n_voltages,	\
+			_vreg, _vmask, _ereg, _emask)				\
+	[_family##_##_id] = {							\
+		.name		= (_match),					\
+		.supply_name	= (_supply),					\
+		.of_match	= of_match_ptr(_match),				\
+		.regulators_node = of_match_ptr("regulators"),			\
+		.type		= REGULATOR_VOLTAGE,				\
+		.id		= _family##_##_id,				\
+		.n_voltages	= (_n_voltages),				\
+		.owner		= THIS_MODULE,					\
+		.vsel_reg	= (_vreg),					\
+		.vsel_mask	= (_vmask),					\
+		.enable_reg	= (_ereg),					\
+		.enable_mask	= (_emask),					\
+		.linear_ranges	= (_ranges),					\
+		.n_linear_ranges = ARRAY_SIZE(_ranges),				\
+		.ops		= &axp_ops_range,				\
+	}
+
+extern const struct regulator_ops axp_ops;
+extern const struct regulator_ops axp_ops_fixed;
+extern const struct regulator_ops axp_ops_range;
+extern const struct regulator_ops axp_ops_sw;
+
+struct axp_cfg {
+	const struct regulator_desc *regulators;
+	u8 nregulators;
+	s8 dcdc1_ix;
+	s8 dcdc5_ix;
+	s8 dc1sw_ix;
+	s8 dc5ldo_ix;
+	u32 skip_bitmap;
+	bool drivevbus;
+};
+
+int axp_regulator_create(struct device *dev,
+			 const struct axp_cfg *axp_cfg);
+
+struct sunxi_rsb_device;
+int axp_rsb_probe(struct sunxi_rsb_device *rdev,
+		  struct axp20x_dev *axp20x,
+		  const struct axp_cfg *axp_cfg);
+int axp_rsb_remove(struct sunxi_rsb_device *rdev);
+
+#endif /* __AXP_REGULATOR_H__ */
diff --git a/drivers/regulator/axp-regulator.c b/drivers/regulator/axp-regulator.c
new file mode 100644
index 0000000..c3be350
--- /dev/null
+++ b/drivers/regulator/axp-regulator.c
@@ -0,0 +1,349 @@
+/*
+ * AXP regulators driver
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Copyright (C) 2013 Carlo Caione <carlo@caione.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/mfd/axp20x.h>
+#include <linux/sunxi-rsb.h>
+
+#include "axp-regulator.h"
+
+#define AXP20X_WORKMODE_DCDC2_MASK	BIT(2)
+#define AXP20X_WORKMODE_DCDC3_MASK	BIT(1)
+#define AXP22X_WORKMODE_DCDCX_MASK(x)	BIT(x)
+
+#define AXP20X_FREQ_DCDC_MASK	0x0f
+
+#define AXP22X_MISC_N_VBUSEN_FUNC	BIT(4)
+
+const struct regulator_ops axp_ops_fixed = {
+	.list_voltage		= regulator_list_voltage_linear,
+};
+EXPORT_SYMBOL_GPL(axp_ops_fixed);
+
+const struct regulator_ops axp_ops_range = {
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.list_voltage		= regulator_list_voltage_linear_range,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+};
+EXPORT_SYMBOL_GPL(axp_ops_range);
+
+const struct regulator_ops axp_ops = {
+	.set_voltage_sel	= regulator_set_voltage_sel_regmap,
+	.get_voltage_sel	= regulator_get_voltage_sel_regmap,
+	.list_voltage		= regulator_list_voltage_linear,
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+};
+EXPORT_SYMBOL_GPL(axp_ops);
+
+const struct regulator_ops axp_ops_sw = {
+	.enable			= regulator_enable_regmap,
+	.disable		= regulator_disable_regmap,
+	.is_enabled		= regulator_is_enabled_regmap,
+};
+EXPORT_SYMBOL_GPL(axp_ops_sw);
+
+static const struct regulator_desc axp22x_drivevbus_regulator = {
+	.name		= "drivevbus",
+	.supply_name	= "drivevbus",
+	.of_match	= of_match_ptr("drivevbus"),
+	.regulators_node = of_match_ptr("regulators"),
+	.type		= REGULATOR_VOLTAGE,
+	.owner		= THIS_MODULE,
+	.enable_reg	= AXP20X_VBUS_IPSOUT_MGMT,
+	.enable_mask	= BIT(2),
+	.ops		= &axp_ops_sw,
+};
+
+static int axp_set_dcdc_freq(struct device *dev,
+					u32 dcdcfreq)
+{
+	struct axp20x_dev *axp20x = dev_get_drvdata(dev);
+	unsigned int reg = AXP20X_DCDC_FREQ;
+	u32 min, max, def, step;
+
+	switch (axp20x->variant) {
+	case AXP202_ID:
+	case AXP209_ID:
+		min = 750;
+		max = 1875;
+		def = 1500;
+		step = 75;
+		break;
+	case AXP806_ID:
+		/*
+		 * AXP806 DCDC work frequency setting has the same range and
+		 * step as AXP22X, but at a different register.
+		 * Fall through to the check below.
+		 * (See include/linux/mfd/axp20x.h)
+		 */
+		reg = AXP806_DCDC_FREQ_CTRL;
+	case AXP221_ID:
+	case AXP223_ID:
+	case AXP809_ID:
+	case AXP803_ID:
+	case AXP813_ID:
+		min = 1800;
+		max = 4050;
+		def = 3000;
+		step = 150;
+		break;
+	default:
+		dev_err(dev,
+			"Setting DCDC frequency for unsupported AXP variant\n");
+		return -EINVAL;
+	}
+
+	if (dcdcfreq == 0)
+		dcdcfreq = def;
+
+	if (dcdcfreq < min) {
+		dcdcfreq = min;
+		dev_warn(dev, "DCDC frequency too low. Set to %ukHz\n",
+			 min);
+	}
+
+	if (dcdcfreq > max) {
+		dcdcfreq = max;
+		dev_warn(dev, "DCDC frequency too high. Set to %ukHz\n",
+			 max);
+	}
+
+	dcdcfreq = (dcdcfreq - min) / step;
+
+	return regmap_update_bits(axp20x->regmap, reg,
+				  AXP20X_FREQ_DCDC_MASK, dcdcfreq);
+}
+
+static int axp_regulator_parse_dt(struct device *dev)
+{
+	struct device_node *np, *regulators;
+	int ret;
+	u32 dcdcfreq = 0;
+
+	np = of_node_get(dev->of_node);
+	if (!np)
+		return 0;
+
+	regulators = of_get_child_by_name(np, "regulators");
+	if (!regulators) {
+		dev_warn(dev, "regulators node not found\n");
+	} else {
+		of_property_read_u32(regulators, "x-powers,dcdc-freq", &dcdcfreq);
+		ret = axp_set_dcdc_freq(dev, dcdcfreq);
+		if (ret < 0) {
+			dev_err(dev, "Error setting dcdc frequency: %d\n", ret);
+			return ret;
+		}
+
+		of_node_put(regulators);
+	}
+
+	return 0;
+}
+
+static int axp_set_dcdc_workmode(struct regulator_dev *rdev,
+				int id, u32 workmode)
+{
+	struct axp20x_dev *axp20x = rdev_get_drvdata(rdev);
+	unsigned int reg = AXP20X_DCDC_MODE;
+	unsigned int mask;
+
+	switch (axp20x->variant) {
+	case AXP202_ID:
+	case AXP209_ID:
+		if ((id != AXP20X_DCDC2) && (id != AXP20X_DCDC3))
+			return -EINVAL;
+
+		mask = AXP20X_WORKMODE_DCDC2_MASK;
+		if (id == AXP20X_DCDC3)
+			mask = AXP20X_WORKMODE_DCDC3_MASK;
+
+		workmode <<= ffs(mask) - 1;
+		break;
+
+	case AXP806_ID:
+		reg = AXP806_DCDC_MODE_CTRL2;
+		/*
+		 * AXP806 DCDC regulator IDs have the same range as AXP22X.
+		 * Fall through to the check below.
+		 * (See include/linux/mfd/axp20x.h)
+		 */
+	case AXP221_ID:
+	case AXP223_ID:
+	case AXP809_ID:
+		if (id < AXP22X_DCDC1 || id > AXP22X_DCDC5)
+			return -EINVAL;
+
+		mask = AXP22X_WORKMODE_DCDCX_MASK(id - AXP22X_DCDC1);
+		workmode <<= id - AXP22X_DCDC1;
+		break;
+
+	default:
+		/* should not happen */
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	return regmap_update_bits(rdev->regmap, reg, mask, workmode);
+}
+
+/* create the regulators */
+int axp_regulator_create(struct device *dev,
+			 const struct axp_cfg *axp_cfg)
+{
+	struct regulator_dev *rdev;
+	struct axp20x_dev *axp20x = dev_get_drvdata(dev);
+	struct regulator_config config = {
+		.dev = dev,
+		.regmap = axp20x->regmap,
+		.driver_data = axp20x,
+	};
+	int ret, i;
+	u32 workmode;
+	const char *dcdc1_name = NULL;
+	const char *dcdc5_name = NULL;
+
+	/* This only sets the dcdc freq. Ignore any errors */
+	axp_regulator_parse_dt(dev);
+
+	for (i = 0; i < axp_cfg->nregulators; i++) {
+		const struct regulator_desc *desc = &axp_cfg->regulators[i];
+		struct regulator_desc *new_desc;
+
+		if (axp_cfg->skip_bitmap & (1 << i))
+			continue;
+
+		/*
+		 * Regulators DC1SW and DC5LDO are connected internally,
+		 * so we have to handle their supply names separately.
+		 *
+		 * We always register the regulators in proper sequence,
+		 * so the supply names are correctly read. See the last
+		 * part of this loop to see where we save the DT defined
+		 * name.
+		 */
+		if (i == axp_cfg->dc1sw_ix && dcdc1_name) {
+			new_desc = devm_kzalloc(dev, sizeof(*desc),
+						GFP_KERNEL);
+			*new_desc = *desc;
+			new_desc->supply_name = dcdc1_name;
+			desc = new_desc;
+		}
+
+		if (i == axp_cfg->dc5ldo_ix && dcdc5_name) {
+			new_desc = devm_kzalloc(dev, sizeof(*desc),
+						GFP_KERNEL);
+			*new_desc = *desc;
+			new_desc->supply_name = dcdc5_name;
+			desc = new_desc;
+		}
+
+		rdev = devm_regulator_register(dev, desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(dev, "Failed to register %s\n",
+				axp_cfg->regulators[i].name);
+
+			return PTR_ERR(rdev);
+		}
+
+		ret = of_property_read_u32(rdev->dev.of_node,
+					   "x-powers,dcdc-workmode",
+					   &workmode);
+		if (!ret) {
+			if (axp_set_dcdc_workmode(rdev, i, workmode))
+				dev_err(dev, "Failed to set workmode on %s\n",
+					rdev->desc->name);
+		}
+
+		/*
+		 * Save AXP22X DCDC1 / DCDC5 regulator names for later.
+		 */
+		if (i == axp_cfg->dcdc1_ix)
+			of_property_read_string(rdev->dev.of_node,
+						"regulator-name",
+						&dcdc1_name);
+		if (i == axp_cfg->dcdc5_ix)
+			of_property_read_string(rdev->dev.of_node,
+						"regulator-name",
+						&dcdc5_name);
+	}
+
+	if (axp_cfg->drivevbus) {
+		/* Change N_VBUSEN sense pin to DRIVEVBUS output pin */
+		regmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,
+				   AXP22X_MISC_N_VBUSEN_FUNC, 0);
+		rdev = devm_regulator_register(dev,
+					       &axp22x_drivevbus_regulator,
+					       &config);
+		if (IS_ERR(rdev)) {
+			dev_err(dev, "Failed to register drivevbus\n");
+			return PTR_ERR(rdev);
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(axp_regulator_create);
+
+/* probe/remove RSB devices */
+int axp_rsb_probe(struct sunxi_rsb_device *rdev,
+		  struct axp20x_dev *axp20x,
+		  const struct axp_cfg *axp_cfg)
+{
+	int ret;
+
+	axp20x->dev = &rdev->dev;
+	axp20x->irq = rdev->irq;
+	dev_set_drvdata(&rdev->dev, axp20x);
+
+	ret = axp20x_match_device(axp20x);
+	if (ret)
+		return ret;
+
+	axp20x->regmap = devm_regmap_init_sunxi_rsb(rdev,
+						    axp20x->regmap_cfg);
+	if (IS_ERR(axp20x->regmap)) {
+		ret = PTR_ERR(axp20x->regmap);
+		dev_err(&rdev->dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = axp20x_device_probe(axp20x);
+	if (ret < 0)
+		return ret;
+
+	return axp_regulator_create(&rdev->dev, axp_cfg);
+}
+EXPORT_SYMBOL_GPL(axp_rsb_probe);
+
+int axp_rsb_remove(struct sunxi_rsb_device *rdev)
+{
+	struct axp20x_dev *axp20x = sunxi_rsb_device_get_drvdata(rdev);
+
+	return axp20x_device_remove(axp20x);
+}
+EXPORT_SYMBOL_GPL(axp_rsb_remove);
+
+MODULE_AUTHOR("Carlo Caione <carlo@caione.org>");
+MODULE_DESCRIPTION("Regulator Module for AXP PMIC");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/axp803.c b/drivers/regulator/axp803.c
new file mode 100644
index 0000000..bae83dd
--- /dev/null
+++ b/drivers/regulator/axp803.c
@@ -0,0 +1,225 @@
+/*
+ * AXP803 regulator driver
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/axp20x.h>
+#include <linux/regulator/driver.h>
+#include <linux/sunxi-rsb.h>
+
+#include "axp-regulator.h"
+
+enum {
+	AXP803_DLDO1 = 0,
+	AXP803_DLDO2,
+	AXP803_DLDO3,
+	AXP803_DLDO4,
+	AXP803_ELDO1,
+	AXP803_ELDO2,
+	AXP803_ELDO3,
+	AXP803_FLDO1,
+	AXP803_FLDO2,
+	AXP803_DCDC1,
+	AXP803_DCDC2,
+	AXP803_DCDC3,
+	AXP803_DCDC4,
+	AXP803_DCDC5,
+	AXP803_DCDC6,
+	AXP803_ALDO1,
+	AXP803_ALDO2,
+	AXP803_ALDO3,
+	AXP803_LDO_IO0,
+	AXP803_LDO_IO1,
+	AXP803_RTC_LDO,
+	AXP803_DC1SW,
+};
+
+/* AXP803 registers */
+#define AXP803_FLDO1_V_OUT		0x1c
+#define AXP803_FLDO2_V_OUT		0x1d
+#define AXP803_DCDC1_V_OUT		0x20
+#define AXP803_DCDC2_V_OUT		0x21
+#define AXP803_DCDC3_V_OUT		0x22
+#define AXP803_DCDC4_V_OUT		0x23
+#define AXP803_DCDC5_V_OUT		0x24
+#define AXP803_DCDC6_V_OUT		0x25
+
+static const struct regulator_linear_range axp803_dldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(700000, 0, 26, 100000),
+	REGULATOR_LINEAR_RANGE(3400000, 27, 31, 200000),
+};
+
+static const struct regulator_linear_range axp803_dcdc2_4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 71, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 72, 76, 20000),
+};
+
+static const struct regulator_linear_range axp803_dcdc5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0, 33, 10000),
+	REGULATOR_LINEAR_RANGE(1140000, 34, 69, 20000),
+};
+
+static const struct regulator_linear_range axp803_dcdc6_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0, 51, 10000),
+	REGULATOR_LINEAR_RANGE(1120000, 52, 72, 20000),
+};
+
+static const struct regulator_desc axp803_regulators[] = {
+	AXP_DESC(AXP803, DLDO1, "dldo1", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(3)),
+	AXP_DESC_RANGES(AXP803, DLDO2, "dldo2", "dldoin", axp803_dldo2_ranges,
+			31, AXP22X_DLDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2,
+			BIT(4)),
+	AXP_DESC(AXP803, DLDO3, "dldo3", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(5)),
+	AXP_DESC(AXP803, DLDO4, "dldo4", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO4_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(6)),
+	AXP_DESC(AXP803, ELDO1, "eldo1", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(0)),
+	AXP_DESC(AXP803, ELDO2, "eldo2", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
+	AXP_DESC(AXP803, ELDO3, "eldo3", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
+	AXP_DESC(AXP803, FLDO1, "fldo1", "fldoin", 700, 1450, 50,
+		 AXP803_FLDO1_V_OUT, 0x0f, AXP22X_PWR_OUT_CTRL3, BIT(2)),
+	AXP_DESC(AXP803, FLDO2, "fldo2", "fldoin", 700, 1450, 50,
+		 AXP803_FLDO2_V_OUT, 0x0f, AXP22X_PWR_OUT_CTRL3, BIT(3)),
+	AXP_DESC(AXP803, DCDC1, "dcdc1", "vin1", 1600, 3400, 100,
+		 AXP803_DCDC1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(0)),
+	AXP_DESC_RANGES(AXP803, DCDC2, "dcdc2", "vin2", axp803_dcdc2_4_ranges,
+			76, AXP803_DCDC2_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(1)),
+	AXP_DESC_RANGES(AXP803, DCDC3, "dcdc3", "vin3", axp803_dcdc2_4_ranges,
+			76, AXP803_DCDC3_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(2)),
+	AXP_DESC_RANGES(AXP803, DCDC4, "dcdc4", "vin4", axp803_dcdc2_4_ranges,
+			76, AXP803_DCDC4_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(3)),
+	AXP_DESC_RANGES(AXP803, DCDC5, "dcdc5", "vin5", axp803_dcdc5_ranges,
+			69, AXP803_DCDC5_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(4)),
+	AXP_DESC_RANGES(AXP803, DCDC6, "dcdc6", "vin6", axp803_dcdc6_ranges,
+			72, AXP803_DCDC6_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(5)),
+	AXP_DESC(AXP803, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(5)),
+	AXP_DESC(AXP803, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(6)),
+	AXP_DESC(AXP803, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(7)),
+	AXP_DESC_IO(AXP803, LDO_IO0, "ldo_io0", "ips", 700, 3300, 100,
+		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_IO(AXP803, LDO_IO1, "ldo_io1", "ips", 700, 3300, 100,
+		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_FIXED(AXP803, RTC_LDO, "rtc_ldo", "ips", 1800),
+	/* secondary switchable output of DCDC1 */
+	AXP_DESC_SW(AXP803, DC1SW, "dc1sw", NULL, AXP22X_PWR_OUT_CTRL2,
+		    BIT(7)),
+};
+
+static const struct regmap_range axp803_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP22X_BATLOW_THRES1),
+};
+
+static const struct regmap_range axp803_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_PWR_INPUT_STATUS, AXP20X_PWR_OP_MODE),
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP22X_GPIO_STATE, AXP22X_GPIO_STATE),
+	regmap_reg_range(AXP20X_FG_RES, AXP20X_FG_RES),
+};
+
+static const struct regmap_access_table axp803_writeable_table = {
+	.yes_ranges	= axp803_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp803_writeable_ranges),
+};
+
+static const struct regmap_access_table axp803_volatile_table = {
+	.yes_ranges	= axp803_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp803_volatile_ranges),
+};
+
+static const struct regmap_config axp803_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp803_writeable_table,
+	.volatile_table	= &axp803_volatile_table,
+	.max_register	= AXP22X_BATLOW_THRES1,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+#define INIT_REGMAP_IRQ(_irq, _off, _bit)			\
+	[AXP809_IRQ_##_irq] = { .reg_offset = (_off), .mask = BIT(_bit) }
+
+static const struct regmap_irq axp803_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(PEK_SHORT,		4, 4),
+	INIT_REGMAP_IRQ(PEK_LONG,		4, 3),
+	INIT_REGMAP_IRQ(PEK_OVER_OFF,		4, 2),
+	INIT_REGMAP_IRQ(GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(GPIO0_INPUT,		4, 0),
+};
+
+static const struct regmap_irq_chip axp803_regmap_irq_chip = {
+	.name			= "axp803",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp803_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp803_regmap_irqs),
+	.num_regs		= 6,
+};
+
+static const struct axp_cfg axp803_cfg = {
+	.regulators = axp803_regulators,
+	.nregulators= ARRAY_SIZE(axp803_regulators),
+	.dcdc1_ix = AXP803_DCDC1,
+	.dcdc5_ix = -1,
+	.dc1sw_ix = AXP803_DC1SW,
+	.dc5ldo_ix = -1,
+};
+
+static struct axp20x_dev axp803_dev = {
+	.regmap_cfg = &axp803_regmap_config,
+	.regmap_irq_chip = &axp803_regmap_irq_chip,
+};
+
+static int axp803_rsb_probe(struct sunxi_rsb_device *rdev)
+{
+	return axp_rsb_probe(rdev, &axp803_dev, &axp803_cfg);
+}
+
+static const struct of_device_id axp803_of_match[] = {
+	{ .compatible = "x-powers,axp803", .data = (void *) AXP803_ID },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, axp803_of_match);
+
+static struct sunxi_rsb_driver axp803_rsb_driver = {
+	.driver = {
+		.name	= "axp803-rsb",
+		.of_match_table	= of_match_ptr(axp803_of_match),
+	},
+	.probe	= axp803_rsb_probe,
+	.remove	= axp_rsb_remove,
+};
+module_sunxi_rsb_driver(axp803_rsb_driver);
+
+MODULE_DESCRIPTION("AXP803 RSB driver");
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/regulator/axp813.c b/drivers/regulator/axp813.c
new file mode 100644
index 0000000..99bfaaa
--- /dev/null
+++ b/drivers/regulator/axp813.c
@@ -0,0 +1,229 @@
+/*
+ * AXP813 regulator driver
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/axp20x.h>
+#include <linux/regulator/driver.h>
+#include <linux/sunxi-rsb.h>
+
+#include "axp-regulator.h"
+
+enum {
+	AXP813_DLDO1 = 0,
+	AXP813_DLDO2,
+	AXP813_DLDO3,
+	AXP813_DLDO4,
+	AXP813_ELDO1,
+	AXP813_ELDO2,
+	AXP813_ELDO3,
+	AXP813_FLDO1,
+	AXP813_FLDO2,
+	AXP813_FLDO3,
+	AXP813_DCDC1,
+	AXP813_DCDC2,
+	AXP813_DCDC3,
+	AXP813_DCDC4,
+	AXP813_DCDC5,
+	AXP813_DCDC6,
+	AXP813_DCDC7,
+	AXP813_ALDO1,
+	AXP813_ALDO2,
+	AXP813_ALDO3,
+	AXP813_LDO_IO0,
+	AXP813_LDO_IO1,
+	AXP813_RTC_LDO,
+};
+
+/* AXP813 registers */
+#define AXP813_FLDO1_V_OUT		0x1c
+#define AXP813_FLDO2_V_OUT		0x1d
+#define AXP813_DCDC1_V_OUT		0x20
+#define AXP813_DCDC2_V_OUT		0x21
+#define AXP813_DCDC3_V_OUT		0x22
+#define AXP813_DCDC4_V_OUT		0x23
+#define AXP813_DCDC5_V_OUT		0x24
+#define AXP813_DCDC6_V_OUT		0x25
+#define AXP813_DCDC7_V_OUT		0x26
+
+static const struct regulator_linear_range axp813_dcdc2_4_ranges[] = {
+	REGULATOR_LINEAR_RANGE(500000, 0, 71, 10000),
+	REGULATOR_LINEAR_RANGE(1220000, 72, 76, 20000),
+};
+
+static const struct regulator_linear_range axp813_dcdc5_ranges[] = {
+	REGULATOR_LINEAR_RANGE(800000, 0, 33, 10000),
+	REGULATOR_LINEAR_RANGE(1140000, 34, 69, 20000),
+};
+
+static const struct regulator_linear_range axp813_dcdc6_7_ranges[] = {
+	REGULATOR_LINEAR_RANGE(600000, 0, 51, 10000),
+	REGULATOR_LINEAR_RANGE(1120000, 52, 72, 20000),
+};
+
+static const struct regulator_linear_range axp813_dldo2_ranges[] = {
+	REGULATOR_LINEAR_RANGE(700000, 0, 26, 100000),
+	REGULATOR_LINEAR_RANGE(3400000, 27, 31, 200000),
+};
+
+static const struct regulator_desc axp813_regulators[] = {
+	AXP_DESC(AXP813, DLDO1, "dldo1", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(3)),
+	AXP_DESC_RANGES(AXP813, DLDO2, "dldo2", "dldoin", axp813_dldo2_ranges,
+			31, AXP22X_DLDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2,
+			BIT(4)),
+	AXP_DESC(AXP813, DLDO3, "dldo3", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(5)),
+	AXP_DESC(AXP813, DLDO4, "dldo4", "dldoin", 700, 3300, 100,
+		 AXP22X_DLDO4_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(6)),
+	AXP_DESC(AXP813, ELDO1, "eldo1", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(0)),
+	AXP_DESC(AXP813, ELDO2, "eldo2", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(1)),
+	AXP_DESC(AXP813, ELDO3, "eldo3", "eldoin", 700, 1900, 50,
+		 AXP22X_ELDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL2, BIT(2)),
+	AXP_DESC(AXP813, FLDO1, "fldo1", "fldoin", 700, 1450, 50,
+		 AXP813_FLDO1_V_OUT, 0x0f, AXP22X_PWR_OUT_CTRL3, BIT(2)),
+	AXP_DESC(AXP813, FLDO2, "fldo2", "fldoin", 700, 1450, 50,
+		 AXP813_FLDO2_V_OUT, 0x0f, AXP22X_PWR_OUT_CTRL3, BIT(3)),
+/*	FLDO3 not described (output = DCDC5/2 or FLDOIN/2 */
+	AXP_DESC(AXP813, DCDC1, "dcdc1", "vin1", 1600, 3400, 100,
+		 AXP813_DCDC1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL1, BIT(0)),
+	AXP_DESC_RANGES(AXP813, DCDC2, "dcdc2", "vin2", axp813_dcdc2_4_ranges,
+			76, AXP813_DCDC2_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(1)),
+	AXP_DESC_RANGES(AXP813, DCDC3, "dcdc3", "vin3", axp813_dcdc2_4_ranges,
+			76, AXP813_DCDC3_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(2)),
+	AXP_DESC_RANGES(AXP813, DCDC4, "dcdc4", "vin4", axp813_dcdc2_4_ranges,
+			76, AXP813_DCDC4_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(3)),
+	AXP_DESC_RANGES(AXP813, DCDC5, "dcdc5", "vin5", axp813_dcdc5_ranges,
+			69, AXP813_DCDC5_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(4)),
+	AXP_DESC_RANGES(AXP813, DCDC6, "dcdc6", "vin6", axp813_dcdc6_7_ranges,
+			72, AXP813_DCDC6_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(5)),
+	AXP_DESC_RANGES(AXP813, DCDC7, "dcdc7", "vin7", axp813_dcdc6_7_ranges,
+			72, AXP813_DCDC7_V_OUT, 0x7f, AXP22X_PWR_OUT_CTRL1,
+			BIT(6)),
+	AXP_DESC(AXP813, ALDO1, "aldo1", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO1_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(5)),
+	AXP_DESC(AXP813, ALDO2, "aldo2", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO2_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(6)),
+	AXP_DESC(AXP813, ALDO3, "aldo3", "aldoin", 700, 3300, 100,
+		 AXP22X_ALDO3_V_OUT, 0x1f, AXP22X_PWR_OUT_CTRL3, BIT(7)),
+	AXP_DESC_IO(AXP813, LDO_IO0, "ldo_io0", "ips", 700, 3300, 100,
+		    AXP22X_LDO_IO0_V_OUT, 0x1f, AXP20X_GPIO0_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_IO(AXP813, LDO_IO1, "ldo_io1", "ips", 700, 3300, 100,
+		    AXP22X_LDO_IO1_V_OUT, 0x1f, AXP20X_GPIO1_CTRL, 0x07,
+		    AXP22X_IO_ENABLED, AXP22X_IO_DISABLED),
+	AXP_DESC_FIXED(AXP813, RTC_LDO, "rtc_ldo", "ips", 1800),
+};
+
+static const struct regmap_range axp813_writeable_ranges[] = {
+	regmap_reg_range(AXP20X_DATACACHE(0), AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP20X_DCDC_MODE, AXP22X_BATLOW_THRES1),
+};
+
+static const struct regmap_range axp813_volatile_ranges[] = {
+	regmap_reg_range(AXP20X_PWR_INPUT_STATUS, AXP20X_PWR_OP_MODE),
+	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
+	regmap_reg_range(AXP22X_GPIO_STATE, AXP22X_GPIO_STATE),
+	regmap_reg_range(AXP20X_FG_RES, AXP20X_FG_RES),
+};
+
+static const struct regmap_access_table axp813_writeable_table = {
+	.yes_ranges	= axp813_writeable_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp813_writeable_ranges),
+};
+
+static const struct regmap_access_table axp813_volatile_table = {
+	.yes_ranges	= axp813_volatile_ranges,
+	.n_yes_ranges	= ARRAY_SIZE(axp813_volatile_ranges),
+};
+
+static const struct regmap_config axp813_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.wr_table	= &axp813_writeable_table,
+	.volatile_table	= &axp813_volatile_table,
+	.max_register	= AXP22X_BATLOW_THRES1,
+	.cache_type	= REGCACHE_RBTREE,
+};
+
+#define INIT_REGMAP_IRQ(_irq, _off, _bit)			\
+	[AXP809_IRQ_##_irq] = { .reg_offset = (_off), .mask = BIT(_bit) }
+
+static const struct regmap_irq axp813_regmap_irqs[] = {
+	INIT_REGMAP_IRQ(PEK_RIS_EDGE,	        4, 6),
+	INIT_REGMAP_IRQ(PEK_FAL_EDGE,	        4, 5),
+	INIT_REGMAP_IRQ(PEK_SHORT,		4, 4),
+	INIT_REGMAP_IRQ(PEK_LONG,		4, 3),
+	INIT_REGMAP_IRQ(PEK_OVER_OFF,		4, 2),
+	INIT_REGMAP_IRQ(GPIO1_INPUT,		4, 1),
+	INIT_REGMAP_IRQ(GPIO0_INPUT,		4, 0),
+};
+
+static const struct regmap_irq_chip axp813_regmap_irq_chip = {
+	.name			= "axp813",
+	.status_base		= AXP20X_IRQ1_STATE,
+	.ack_base		= AXP20X_IRQ1_STATE,
+	.mask_base		= AXP20X_IRQ1_EN,
+	.mask_invert		= true,
+	.init_ack_masked	= true,
+	.irqs			= axp813_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(axp813_regmap_irqs),
+	.num_regs		= 6,
+};
+
+static const struct axp_cfg axp813_cfg = {
+	.regulators = axp813_regulators,
+	.nregulators= ARRAY_SIZE(axp813_regulators),
+	.dcdc1_ix = -1,
+	.dcdc5_ix = -1,
+	.dc1sw_ix = -1,
+	.dc5ldo_ix = -1,
+	.skip_bitmap = 1 << AXP813_FLDO3,
+};
+
+static struct axp20x_dev axp813_dev = {
+	.regmap_cfg = &axp813_regmap_config,
+	.regmap_irq_chip = &axp813_regmap_irq_chip,
+};
+
+static int axp813_rsb_probe(struct sunxi_rsb_device *rdev)
+{
+	return axp_rsb_probe(rdev, &axp813_dev, &axp813_cfg);
+}
+
+static const struct of_device_id axp813_of_match[] = {
+	{ .compatible = "x-powers,axp813", .data = (void *) AXP813_ID },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, axp813_of_match);
+
+static struct sunxi_rsb_driver axp813_rsb_driver = {
+	.driver = {
+		.name	= "axp813-rsb",
+		.of_match_table	= of_match_ptr(axp813_of_match),
+	},
+	.probe	= axp813_rsb_probe,
+	.remove	= axp_rsb_remove,
+};
+module_sunxi_rsb_driver(axp813_rsb_driver);
+
+MODULE_DESCRIPTION("AXP813 RSB driver");
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/thermal/sun8i_ths.c b/drivers/thermal/sun8i_ths.c
new file mode 100644
index 0000000..6dff905
--- /dev/null
+++ b/drivers/thermal/sun8i_ths.c
@@ -0,0 +1,478 @@
+/*
+ * Sunxi THS driver
+ *
+ * Copyright (C) 2015 Josef Gajdusek
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#if IS_ENABLED(CONFIG_NVMEM)
+#  include <linux/nvmem-consumer.h>
+#endif
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/printk.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/thermal.h>
+
+/* common A83T/H3 */
+#define THS_H3_CTRL0			0x00
+#define THS_H3_CTRL1			0x04
+#define THS_H3_CDAT				0x14
+#define THS_H3_CTRL2			0x40
+#define THS_H3_INT_CTRL			0x44
+#define THS_H3_STAT				0x48
+#define THS_H3_ALARM_CTRL		0x50
+#define THS_A83T_ALARM_CTRL1		0x54
+#define THS_A83T_ALARM_CTRL2		0x58
+#define THS_H3_SHUTDOWN_CTRL		0x60
+#define THS_A83T_SHUTDOWN_CTRL1		0x64
+#define THS_A83T_SHUTDOWN_CTRL2		0x68
+#define THS_H3_FILTER			0x70
+#define THS_H3_CDATA			0x74
+#define THS2_A83T_CDATA			0x78
+#define THS_H3_DATA			0x80
+#define THS1_A83T_DATA			0x84
+#define THS2_A83T_DATA			0x88
+
+#define THS_H3_CTRL0_SENSOR_ACQ0_OFFS   0
+#define THS_H3_CTRL0_SENSOR_ACQ0(x) \
+	((x) << THS_H3_CTRL0_SENSOR_ACQ0_OFFS)
+#define THS_H3_CTRL1_ADC_CALI_EN_OFFS   17
+#define THS_H3_CTRL1_ADC_CALI_EN \
+	BIT(THS_H3_CTRL1_ADC_CALI_EN_OFFS)
+#define THS_H3_CTRL1_OP_BIAS_OFFS       20
+#define THS_H3_CTRL1_OP_BIAS(x) \
+	((x) << THS_H3_CTRL1_OP_BIAS_OFFS)
+#define THS_H3_CTRL2_SENSE_EN_OFFS      0
+#define THS_H3_CTRL2_SENSE_EN \
+	BIT(THS_H3_CTRL2_SENSE_EN_OFFS)
+#define THS_H3_CTRL2_SENSOR_ACQ1_OFFS   16
+#define THS_H3_CTRL2_SENSOR_ACQ1(x) \
+	((x) << THS_H3_CTRL2_SENSOR_ACQ1_OFFS)
+
+#define THS_H3_INT_CTRL_ALARM_INT_EN_OFFS       0
+#define THS_H3_INT_CTRL_ALARM_INT_EN \
+	BIT(THS_H3_INT_CTRL_ALARM_INT_EN_OFFS)
+#define THS_H3_INT_CTRL_SHUT_INT_EN_OFFS		4
+#define THS_H3_INT_CTRL_SHUT_INT_EN \
+	BIT(THS_H3_INT_CTRL_SHUT_INT_EN_OFFS)
+#define THS_H3_INT_CTRL_DATA_IRQ_EN_OFFS		8
+#define THS_H3_INT_CTRL_DATA_IRQ_EN \
+	BIT(THS_H3_INT_CTRL_DATA_IRQ_EN_OFFS)
+#define THS_H3_INT_CTRL_THERMAL_PER_OFFS		12
+#define THS_H3_INT_CTRL_THERMAL_PER(x) \
+	((x) << THS_H3_INT_CTRL_THERMAL_PER_OFFS)
+
+#define THS_H3_STAT_ALARM_INT_STS_OFFS  0
+#define THS_H3_STAT_ALARM_INT_STS \
+	BIT(THS_H3_STAT_ALARM_INT_STS_OFFS)
+#define THS_H3_STAT_SHUT_INT_STS_OFFS   4
+#define THS_H3_STAT_SHUT_INT_STS \
+	BIT(THS_H3_STAT_SHUT_INT_STS_OFFS)
+#define THS_H3_STAT_DATA_IRQ_STS_OFFS   8
+#define THS_H3_STAT_DATA_IRQ_STS \
+	BIT(THS_H3_STAT_DATA_IRQ_STS_OFFS)
+#define THS_H3_STAT_ALARM_OFF_STS_OFFS  12
+#define THS_H3_STAT_ALARM_OFF_STS \
+	BIT(THS_H3_STAT_ALARM_OFF_STS_OFFS)
+
+#define THS_H3_ALARM_CTRL_ALARM0_T_HYST_OFFS    0
+#define THS_H3_ALARM_CTRL_ALARM0_T_HYST(x) \
+	((x) << THS_H3_ALARM_CTRL_ALARM0_T_HYST_OFFS)
+#define THS_H3_ALARM_CTRL_ALARM0_T_HOT_OFFS     16
+#define THS_H3_ALARM_CTRL_ALARM0_T_HOT(x) \
+	((x) << THS_H3_ALARM_CTRL_ALARM0_T_HOT_OFFS)
+
+#define THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT_OFFS   16
+#define THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT(x) \
+	((x) << THS_H3_SHUTDOWN_CTRL_SHUT0_T_HOT_OFFS)
+
+#define THS_H3_FILTER_TYPE_OFFS 0
+#define THS_H3_FILTER_TYPE(x) \
+	((x) << THS_H3_FILTER_TYPE_OFFS)
+#define THS_H3_FILTER_EN_OFFS   2
+#define THS_H3_FILTER_EN \
+	BIT(THS_H3_FILTER_EN_OFFS)
+
+#define THS_A83T_CTRL0_SENSOR_ACQ0_VALUE	0x17
+#define THS_A83T_CTRL2_SENSOR_ACQ1_VALUE	0x17
+#define THS_A83T_CTRL2_SENSE_EN(x) \
+		((x) << THS_H3_CTRL2_SENSE_EN_OFFS)
+#define THS_A83T_INT_CTRL_ALARM_INT_EN(x) \
+		((x) << THS_H3_INT_CTRL_ALARM_INT_EN_OFFS)
+#define THS_A83T_INT_CTRL_THERMAL_PER_VALUE		0x00001
+#define THS_A83T_FILTER_TYPE_VALUE			0x1
+
+#define THS_H3_CTRL0_SENSOR_ACQ0_VALUE			0xff
+#define THS_H3_INT_CTRL_THERMAL_PER_VALUE		0x79
+#define THS_H3_FILTER_TYPE_VALUE				0x2
+#define THS_H3_CTRL2_SENSOR_ACQ1_VALUE			0x3f
+
+struct sun8i_ths_data {
+	struct sun8i_ths_type *type;
+	struct reset_control *reset;
+	struct clk *clk;
+//	struct clk *busclk;
+	void __iomem *regs;
+#if IS_ENABLED(CONFIG_NVMEM)
+	struct nvmem_cell *calcell;
+#endif
+	struct platform_device *pdev;
+	struct thermal_zone_device *tzd;
+};
+
+struct sun8i_ths_type {
+	int (*init)(struct platform_device *, struct sun8i_ths_data *);
+	int (*get_temp)(struct sun8i_ths_data *, int *out);
+	void (*irq)(struct sun8i_ths_data *);
+	void (*deinit)(struct sun8i_ths_data *);
+};
+
+/* Formula and parameters from the Allwinner 3.4 kernel */
+static int sun8i_ths_reg_to_temperature(s32 reg, int divisor, int constant)
+{
+	return constant - (reg * 1000000) / divisor;
+}
+
+static int sun8i_ths_get_temp(void *_data, int *out)
+{
+	struct sun8i_ths_data *data = _data;
+
+	return data->type->get_temp(data, out);
+}
+
+static irqreturn_t sun8i_ths_irq_thread(int irq, void *_data)
+{
+	struct sun8i_ths_data *data = _data;
+
+	data->type->irq(data);
+	thermal_zone_device_update(data->tzd, THERMAL_EVENT_UNSPECIFIED);
+
+	return IRQ_HANDLED;
+}
+
+/* ----- A83T (sun8iw6p1) ----- */
+static int sun8i_ths_a83t_init(struct platform_device *pdev,
+			     struct sun8i_ths_data *data)
+{
+#if IS_ENABLED(CONFIG_NVMEM)
+	if (data->calcell) {
+		size_t callen;
+		s32 (*caldata)[];
+
+		caldata = nvmem_cell_read(data->calcell, &callen);
+		if (IS_ERR(caldata))
+			return PTR_ERR(caldata);
+		if ((*caldata)[0])
+			writel(be32_to_cpu((*caldata)[0]),
+				data->regs + THS_H3_CDATA);
+		if ((*caldata)[1])
+			writel(be32_to_cpu((*caldata)[1]),
+				data->regs + THS2_A83T_CDATA);
+		kfree(caldata);
+	}
+#endif
+
+	writel(THS_H3_CTRL0_SENSOR_ACQ0(THS_A83T_CTRL0_SENSOR_ACQ0_VALUE),
+	       data->regs + THS_H3_CTRL0);
+	writel(THS_H3_CTRL2_SENSOR_ACQ1(THS_A83T_CTRL2_SENSOR_ACQ1_VALUE) |
+			THS_A83T_CTRL2_SENSE_EN(7),
+	       data->regs + THS_H3_CTRL2);
+	writel(THS_H3_INT_CTRL_THERMAL_PER(THS_A83T_INT_CTRL_THERMAL_PER_VALUE) |
+			THS_A83T_INT_CTRL_ALARM_INT_EN(7),
+	       data->regs + THS_H3_INT_CTRL);
+	writel(THS_H3_FILTER_EN |
+			THS_H3_FILTER_TYPE(THS_A83T_FILTER_TYPE_VALUE),
+	       data->regs + THS_H3_FILTER);
+
+	return 0;
+}
+
+static int sun8i_ths_a83t_get_temp(struct sun8i_ths_data *data, int *out)
+{
+	int val = readl(data->regs + THS_H3_DATA);
+
+	*out = sun8i_ths_reg_to_temperature(val, 14186, 192000);
+	return 0;
+}
+
+static void sun8i_ths_a83t_irq(struct sun8i_ths_data *data)
+{
+	u32 status;
+
+	status = readl(data->regs + THS_H3_STAT);
+	writel(status, data->regs + THS_H3_STAT);
+}
+
+static void sun8i_ths_a83t_deinit(struct sun8i_ths_data *data)
+{
+}
+
+static const struct sun8i_ths_type sun8i_ths_device_a83t = {
+	.init = sun8i_ths_a83t_init,
+	.get_temp = sun8i_ths_a83t_get_temp,
+	.irq = sun8i_ths_a83t_irq,
+	.deinit = sun8i_ths_a83t_deinit,
+};
+
+/* ----- H3 (sun8iw7p1) ----- */
+static int sun8i_ths_h3_init(struct platform_device *pdev,
+			     struct sun8i_ths_data *data)
+{
+	int ret;
+
+#if 0
+	data->busclk = devm_clk_get(&pdev->dev, "ahb");
+	if (IS_ERR(data->busclk)) {
+		ret = PTR_ERR(data->busclk);
+		dev_err(&pdev->dev, "failed to get ahb clk: %d\n", ret);
+		return ret;
+	}
+#endif
+
+//	data->clk = devm_clk_get(&pdev->dev, "ths");
+	data->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(data->clk)) {
+		ret = PTR_ERR(data->clk);
+		dev_err(&pdev->dev, "failed to get ths clk: %d\n", ret);
+		return ret;
+	}
+
+	data->reset = devm_reset_control_get_optional(&pdev->dev, NULL);
+//	if (IS_ERR(data->reset)) {
+//		ret = PTR_ERR(data->reset);
+//		dev_err(&pdev->dev, "failed to get reset: %d\n", ret);
+//		return ret;
+//	}
+
+#if IS_ENABLED(CONFIG_NVMEM)
+	if (data->calcell) {
+		size_t callen;
+		s32 *caldata;
+
+		caldata = nvmem_cell_read(data->calcell, &callen);
+		if (IS_ERR(caldata))
+			return PTR_ERR(caldata);
+		if (*caldata)
+			writel(be32_to_cpu(*caldata),
+				data->regs + THS_H3_CDATA);
+		kfree(caldata);
+	}
+#endif
+
+#if 0
+	ret = clk_prepare_enable(data->busclk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable bus clk: %d\n", ret);
+		return ret;
+	}
+#endif
+
+	ret = clk_prepare_enable(data->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable ths clk: %d\n", ret);
+		goto err_disable_bus;
+	}
+
+	if (!IS_ERR(data->reset)) {
+		ret = reset_control_deassert(data->reset);
+		if (ret) {
+			dev_err(&pdev->dev, "reset deassert failed: %d\n", ret);
+			goto err_disable_ths;
+		}
+	}
+
+	/* The final sample period is calculated as follows:
+	 * (THERMAL_PER + 1) * 4096 / f_clk * 2^(FILTER_TYPE + 1)
+	 *
+	 * This results to about 1Hz with these settings.
+	 */
+	ret = clk_set_rate(data->clk, 4000000);
+	if (ret)
+		goto err_disable_ths;
+	writel(THS_H3_CTRL0_SENSOR_ACQ0(THS_H3_CTRL0_SENSOR_ACQ0_VALUE),
+	       data->regs + THS_H3_CTRL0);
+	writel(THS_H3_INT_CTRL_THERMAL_PER(THS_H3_INT_CTRL_THERMAL_PER_VALUE) |
+//jfm
+/*	       THS_H3_INT_CTRL_DATA_IRQ_EN, */
+		THS_H3_INT_CTRL_ALARM_INT_EN,
+	       data->regs + THS_H3_INT_CTRL);
+	writel(THS_H3_FILTER_EN | THS_H3_FILTER_TYPE(THS_H3_FILTER_TYPE_VALUE),
+	       data->regs + THS_H3_FILTER);
+	writel(THS_H3_CTRL2_SENSOR_ACQ1(THS_H3_CTRL2_SENSOR_ACQ1_VALUE) |
+	       THS_H3_CTRL2_SENSE_EN,
+	       data->regs + THS_H3_CTRL2);
+	return 0;
+
+err_disable_ths:
+	clk_disable_unprepare(data->clk);
+err_disable_bus:
+//	clk_disable_unprepare(data->busclk);
+
+	return ret;
+}
+
+static int sun8i_ths_h3_get_temp(struct sun8i_ths_data *data, int *out)
+{
+	int val = readl(data->regs + THS_H3_DATA);
+	*out = sun8i_ths_reg_to_temperature(val, 8253, 217000);
+	return 0;
+}
+
+#if 0
+static void sun8i_ths_h3_irq(struct sun8i_ths_data *data)
+{
+	writel(THS_H3_STAT_DATA_IRQ_STS |
+	       THS_H3_STAT_ALARM_INT_STS |
+	       THS_H3_STAT_ALARM_OFF_STS |
+	       THS_H3_STAT_SHUT_INT_STS,
+	       data->regs + THS_H3_STAT);
+}
+#endif
+
+static void sun8i_ths_h3_deinit(struct sun8i_ths_data *data)
+{
+	if (!IS_ERR(data->reset))
+		reset_control_assert(data->reset);
+	clk_disable_unprepare(data->clk);
+//	clk_disable_unprepare(data->busclk);
+}
+
+static const struct thermal_zone_of_device_ops sun8i_ths_thermal_ops = {
+	.get_temp = sun8i_ths_get_temp,
+};
+
+static const struct sun8i_ths_type sun8i_ths_device_h3 = {
+	.init = sun8i_ths_h3_init,
+	.get_temp = sun8i_ths_h3_get_temp,
+//	.irq = sun8i_ths_h3_irq,
+	.irq = sun8i_ths_a83t_irq,
+	.deinit = sun8i_ths_h3_deinit,
+};
+
+static const struct of_device_id sun8i_ths_id_table[] = {
+	{
+		.compatible = "allwinner,sun8i-h3-ths",
+		.data = &sun8i_ths_device_h3,
+	},
+	{
+		.compatible = "allwinner,sun8i-a83t-ths",
+		.data = &sun8i_ths_device_a83t,
+	},
+	{
+		/* sentinel */
+	},
+};
+MODULE_DEVICE_TABLE(of, sun8i_ths_id_table);
+
+static int sun8i_ths_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *match;
+	struct sun8i_ths_data *data;
+	struct resource *res;
+	int ret;
+	int irq;
+
+	match = of_match_node(sun8i_ths_id_table, np);
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->type = (struct sun8i_ths_type *)match->data;
+	data->pdev = pdev;
+
+#if IS_ENABLED(CONFIG_NVMEM)
+	data->calcell = devm_nvmem_cell_get(&pdev->dev, "calibration");
+	if (IS_ERR(data->calcell)) {
+		if (PTR_ERR(data->calcell) == -EPROBE_DEFER)
+			return PTR_ERR(data->calcell);
+		data->calcell = NULL; /* No calibration register */
+	}
+#endif
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	data->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(data->regs)) {
+		ret = PTR_ERR(data->regs);
+		dev_err(&pdev->dev,
+			"failed to ioremap THS registers: %d\n", ret);
+		return ret;
+	}
+
+//fixme: no interrupt in the A83T ??
+    if (data->type != &sun8i_ths_device_a83t) {
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
+		return irq;
+	}
+
+	ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+					sun8i_ths_irq_thread, IRQF_ONESHOT,
+					dev_name(&pdev->dev), data);
+	if (ret)
+		return ret;
+    }
+
+	ret = data->type->init(pdev, data);
+	if (ret)
+		return ret;
+
+	data->tzd = thermal_zone_of_sensor_register(&pdev->dev, 0, data,
+						    &sun8i_ths_thermal_ops);
+	if (IS_ERR(data->tzd)) {
+		ret = PTR_ERR(data->tzd);
+		dev_err(&pdev->dev, "failed to register thermal zone: %d\n",
+			ret);
+		goto err_deinit;
+	}
+
+	platform_set_drvdata(pdev, data);
+	return 0;
+
+err_deinit:
+	data->type->deinit(data);
+	return ret;
+}
+
+static int sun8i_ths_remove(struct platform_device *pdev)
+{
+	struct sun8i_ths_data *data = platform_get_drvdata(pdev);
+
+	thermal_zone_of_sensor_unregister(&pdev->dev, data->tzd);
+	data->type->deinit(data);
+	return 0;
+}
+
+static struct platform_driver sun8i_ths_driver = {
+	.probe = sun8i_ths_probe,
+	.remove = sun8i_ths_remove,
+	.driver = {
+		.name = "sun8i_ths",
+		.of_match_table = sun8i_ths_id_table,
+	},
+};
+
+module_platform_driver(sun8i_ths_driver);
+
+MODULE_AUTHOR("Josef Gajdusek <atx@xxxxxxxx>");
+MODULE_DESCRIPTION("Sunxi THS driver");
+MODULE_LICENSE("GPL v2");
diff --git a/include/dt-bindings/clock/sun8i-a83t.h b/include/dt-bindings/clock/sun8i-a83t.h
new file mode 100644
index 0000000..73c6126
--- /dev/null
+++ b/include/dt-bindings/clock/sun8i-a83t.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on the H3 version from
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN8I_A83T_H_
+#define _DT_BINDINGS_CLK_SUN8I_A83T_H_
+
+#define CLK_BUS_DMA		0
+#define CLK_BUS_EHCI0		1
+#define CLK_BUS_EHCI1		2
+#define CLK_BUS_MMC0		3
+#define CLK_BUS_MMC1		4
+#define CLK_BUS_MMC2		5
+#define CLK_BUS_OHCI0		6
+#define CLK_BUS_PIO		7
+#define CLK_BUS_UART0		8
+#define CLK_BUS_UART1		9
+#define CLK_BUS_UART2		10
+#define CLK_BUS_UART3		11
+#define CLK_BUS_UART4		12
+#define CLK_BUS_USBDRD		13
+#define CLK_I2S0		14
+#define CLK_I2S1		15
+#define CLK_I2S2		16
+#define CLK_HDMI		17
+#define CLK_HDMI_DDC		18
+#define CLK_MMC0		19
+#define CLK_MMC0_SAMPLE		20
+#define CLK_MMC0_OUTPUT		21
+#define CLK_MMC1		22
+#define CLK_MMC1_SAMPLE		23
+#define CLK_MMC1_OUTPUT		24
+#define CLK_MMC2		25
+#define CLK_MMC2_SAMPLE		26
+#define CLK_MMC2_OUTPUT		27
+#define CLK_OHCI0		28
+#define CLK_OSC12M		29
+#define CLK_PLL_AUDIO		30
+#define CLK_PLL_DE		31
+#define CLK_PLL_GPU		32
+#define CLK_PLL_HSIC		33
+#define CLK_PLL_PERIPH		34
+#define CLK_PLL_VE		35
+#define CLK_PLL_VIDEO0		36
+#define CLK_PLL_VIDEO1		37
+#define CLK_SPDIF		38
+#define CLK_SPI0		39
+#define CLK_SPI1		40
+#define CLK_TCON0		41
+#define CLK_TCON1		42
+#define CLK_TDM			43
+#define CLK_USB_PHY0		44
+#define CLK_USB_PHY1		45
+#define CLK_USB_HSIC		46
+#define CLK_VE			47
+
+#define CLK_BUS_R_PIO		48
+#define CLK_BUS_R_RSB		49
+
+#endif /* _DT_BINDINGS_CLK_SUN8I_A83T_H_ */
diff --git a/include/dt-bindings/clock/sun8i-h3.h b/include/dt-bindings/clock/sun8i-h3.h
new file mode 100644
index 0000000..0b8d419
--- /dev/null
+++ b/include/dt-bindings/clock/sun8i-h3.h
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN8I_H3_H_
+#define _DT_BINDINGS_CLK_SUN8I_H3_H_
+
+#define CLK_BUS_DMA		0
+#define CLK_BUS_EHCI0		1
+#define CLK_BUS_EHCI1		2
+#define CLK_BUS_EHCI2		3
+#define CLK_BUS_EHCI3		4
+#define CLK_BUS_MMC0		5
+#define CLK_BUS_MMC1		6
+#define CLK_BUS_MMC2		7
+#define CLK_BUS_OHCI0		8
+#define CLK_BUS_OHCI1		9
+#define CLK_BUS_OHCI2		10
+#define CLK_BUS_OHCI3		11
+#define CLK_BUS_PIO		12
+#define CLK_BUS_UART0		13
+#define CLK_BUS_UART1		14
+#define CLK_BUS_UART2		15
+#define CLK_BUS_UART3		16
+#define CLK_DE			17
+#define CLK_HDMI		18
+#define CLK_HDMI_DDC		19
+#define CLK_I2S0		20
+#define CLK_I2S1		21
+#define CLK_I2S2		22
+#define CLK_MMC0		23
+#define CLK_MMC0_SAMPLE		24
+#define CLK_MMC0_OUTPUT		25
+#define CLK_MMC1		26
+#define CLK_MMC1_SAMPLE		27
+#define CLK_MMC1_OUTPUT		28
+#define CLK_MMC2		29
+#define CLK_MMC2_SAMPLE		30
+#define CLK_MMC2_OUTPUT		31
+#define CLK_PLL_AUDIO		32
+#define CLK_PLL_DE		33
+#define CLK_PLL_GPU		34
+#define CLK_PLL_PERIPH0		35
+#define CLK_PLL_PERIPH1		36
+#define CLK_PLL_VE		37
+#define CLK_PLL_VIDEO		38
+#define CLK_SPDIF		39
+#define CLK_SPI0		40
+#define CLK_SPI1		41
+#define CLK_TCON0		42
+#define CLK_THS			43
+#define CLK_TVE			44
+#define CLK_USB_OHCI0		45
+#define CLK_USB_OHCI1		46
+#define CLK_USB_OHCI2		47
+#define CLK_USB_OHCI3		48
+#define CLK_USB_PHY0		49
+#define CLK_USB_PHY1		50
+#define CLK_USB_PHY2		51
+#define CLK_USB_PHY3		52
+#define CLK_VE			53
+#define CLK_BUS_R_PIO		54
+#define CLK_BUS_R_CIR		55
+#define CLK_R_CIR		56
+#define CLK_PLL_CPUX		57
+#define CLK_BUS_EMAC		58
+#define CLK_BUS_EPHY		59
+#define CLK_BUS_I2C0		60
+#define CLK_BUS_I2C1		61
+#define CLK_BUS_I2C2		62
+
+#endif /* _DT_BINDINGS_CLK_SUN8I_H3_H_ */
diff --git a/include/dt-bindings/reset/sun8i-a83t.h b/include/dt-bindings/reset/sun8i-a83t.h
new file mode 100644
index 0000000..aae03f8
--- /dev/null
+++ b/include/dt-bindings/reset/sun8i-a83t.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2016 Jean-Francois Moine <moinejf@free.fr>
+ * Based on the H3 version from
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN8I_A83T_H_
+#define _DT_BINDINGS_RST_SUN8I_A83T_H_
+
+#define RST_USB_PHY0	0
+#define RST_USB_PHY1	1
+#define RST_USB_HSIC	2
+#define RST_DRAM_CTR	3
+#define RST_MBUS	4
+#define RST_MIPI_DSI	5
+#define RST_CE		6
+#define RST_DMA		7
+#define RST_NAND	8
+#define RST_DRAM	9
+#define RST_EMAC	10
+#define RST_HSTIMER	11
+#define RST_SPI0	12
+#define RST_SPI1	13
+#define RST_USBDRD	14
+#define RST_EHCI0	15
+#define RST_EHCI1	16
+#define RST_OHCI0	17
+#define RST_VE		18
+#define RST_CSI		19
+#define RST_HDMI0	20
+#define RST_HDMI1	21
+#define RST_GPU		22
+#define RST_MSGBOX	23
+#define RST_SPINLOCK	24
+#define RST_LVDS	25
+#define RST_SPDIF	26
+#define RST_I2S0	27
+#define RST_I2S1	28
+#define RST_I2S2	29
+#define RST_TDM		30
+#define RST_I2C0	31
+#define RST_I2C1	32
+#define RST_I2C2	33
+#define RST_UART0	34
+#define RST_UART1	35
+#define RST_UART2	36
+#define RST_UART3	37
+#define RST_UART4	38
+
+#define RST_R_CIR	39
+#define RST_R_TIMER	40
+#define RST_R_RSB	41
+#define RST_R_UART	42
+#define RST_R_TWI	43
+
+#endif /* _DT_BINDINGS_RST_SUN8I_A83T_H_ */
diff --git a/include/dt-bindings/reset/sun8i-h3.h b/include/dt-bindings/reset/sun8i-h3.h
new file mode 100644
index 0000000..d1192c9
--- /dev/null
+++ b/include/dt-bindings/reset/sun8i-h3.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2016 Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN8I_H3_H_
+#define _DT_BINDINGS_RST_SUN8I_H3_H_
+
+#define RST_USB_PHY0	0
+#define RST_USB_PHY1	1
+#define RST_USB_PHY2	2
+#define RST_USB_PHY3	3
+#define RST_MBUS	4
+#define RST_BUS_CE	5
+#define RST_BUS_DMA	6
+#define RST_BUS_UART0	7
+#define RST_BUS_UART1	8
+#define RST_BUS_UART2	9
+#define RST_BUS_NAND	10
+#define RST_BUS_DRAM	11
+#define RST_BUS_EMAC	12
+#define RST_BUS_TS	13
+#define RST_BUS_HSTIMER	14
+#define RST_BUS_SPI0	15
+#define RST_BUS_SPI1	16
+#define RST_BUS_OTG	17
+#define RST_BUS_EHCI0	18
+#define RST_BUS_EHCI1	19
+#define RST_BUS_EHCI2	20
+#define RST_BUS_EHCI3	21
+#define RST_BUS_OHCI0	22
+#define RST_BUS_OHCI1	23
+#define RST_BUS_OHCI2	24
+#define RST_BUS_OHCI3	25
+#define RST_BUS_VE	26
+#define RST_BUS_DEINTERLACE 27
+#define RST_BUS_CSI	28
+#define RST_BUS_TVE	29
+#define RST_BUS_HDMI0	30
+#define RST_BUS_HDMI1	31
+#define RST_BUS_GPU	32
+#define RST_BUS_MSGBOX	33
+#define RST_BUS_SPINLOCK 34
+#define RST_BUS_DBG	35
+#define RST_BUS_EPHY	36
+#define RST_BUS_CODEC	37
+#define RST_BUS_SPDIF	38
+#define RST_BUS_THS	39
+#define RST_BUS_I2S0	40
+#define RST_BUS_I2S1	41
+#define RST_BUS_I2S2	42
+#define RST_BUS_I2C0	43
+#define RST_BUS_I2C1	44
+#define RST_BUS_I2C2	45
+#define RST_BUS_UART3	46
+#define RST_BUS_SCR	47
+#define RST_R_PIO	48
+#define RST_R_CIR	49
+
+#endif /* _DT_BINDINGS_RST_SUN8I_H3_H_ */
diff --git a/include/sound/sunxi_hdmi.h b/include/sound/sunxi_hdmi.h
new file mode 100644
index 0000000..0986bb9
--- /dev/null
+++ b/include/sound/sunxi_hdmi.h
@@ -0,0 +1,23 @@
+#ifndef __SUNXI_HDMI_H__
+#define __SUNXI_HDMI_H__
+/*
+ * Copyright (C) 2016 Jean-Franois Moine
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+struct sunxi_hdmi_codec {
+	u8 *eld;
+	int (*set_audio_input)(struct device *dev,
+				int enable,
+				unsigned sample_rate,
+				unsigned sample_bit);
+};
+
+int sunxi_hdmi_codec_register(struct device *dev);
+void sunxi_hdmi_codec_unregister(struct device *dev);
+
+#endif /* __SUNXI_HDMI_H__ */
diff --git a/sound/soc/codecs/sunxi-hdmi.c b/sound/soc/codecs/sunxi-hdmi.c
new file mode 100644
index 0000000..47e84cb
--- /dev/null
+++ b/sound/soc/codecs/sunxi-hdmi.c
@@ -0,0 +1,106 @@
+/*
+ * Allwinner HDMI codec
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <sound/pcm_drm_eld.h>
+#include <sound/pcm_params.h>
+
+#include "sound/sunxi_hdmi.h"
+
+#define SUNXI_HDMI_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
+			  SNDRV_PCM_FMTBIT_S16_LE | \
+			  SNDRV_PCM_FMTBIT_S20_3LE | \
+			  SNDRV_PCM_FMTBIT_S24_LE | \
+			  SNDRV_PCM_FMTBIT_S32_LE)
+
+static int sunxi_hdmi_codec_startup(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sunxi_hdmi_codec *priv = dev_get_drvdata(dai->dev);
+	u8 *eld;
+
+	eld = priv->eld;
+	if (!eld)
+		return -ENODEV;
+
+	return snd_pcm_hw_constraint_eld(runtime, eld);
+}
+
+static int sunxi_hdmi_hw_params(struct snd_pcm_substream *substream,
+			      struct snd_pcm_hw_params *params,
+			      struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_codec *priv = dev_get_drvdata(dai->dev);
+	unsigned sample_bit;
+
+	if (params_format(params) == SNDRV_PCM_FORMAT_S16_LE)
+		sample_bit = 16;
+	else
+		sample_bit = 24;
+//fixme params_channels(params) may change 'ca'
+	return priv->set_audio_input(dai->dev, true,
+					params_rate(params),
+					sample_bit);
+}
+
+static void sunxi_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
+				    struct snd_soc_dai *dai)
+{
+	struct sunxi_hdmi_codec *priv = dev_get_drvdata(dai->dev);
+
+	priv->set_audio_input(dai->dev, false, 0, 0);
+}
+
+static const struct snd_soc_dai_ops sunxi_hdmi_codec_ops = {
+	.startup = sunxi_hdmi_codec_startup,
+	.hw_params = sunxi_hdmi_hw_params,
+	.shutdown = sunxi_hdmi_codec_shutdown,
+};
+
+static struct snd_soc_dai_driver sunxi_hdmi_codec = {
+	.name = "hdmi",		/* must be the name of the node in the DT */
+	.playback = {
+		.stream_name	= "HDMI Playback",
+		.channels_min	= 1,
+		.channels_max	= 8,
+		.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+		.rate_min	= 8000,
+		.rate_max	= 192000,
+		.formats	= SUNXI_HDMI_FORMATS,
+	},
+	.ops = &sunxi_hdmi_codec_ops,
+};
+
+static const struct snd_soc_codec_driver sunxi_hdmi_codec_drv = {
+	.ignore_pmdown_time = true,
+};
+
+/* functions called from the HDMI video driver */
+int sunxi_hdmi_codec_register(struct device *dev)
+{
+	return snd_soc_register_codec(dev, &sunxi_hdmi_codec_drv,
+					&sunxi_hdmi_codec, 1);
+}
+EXPORT_SYMBOL_GPL(sunxi_hdmi_codec_register);
+
+void sunxi_hdmi_codec_unregister(struct device *dev)
+{
+	snd_soc_unregister_codec(dev);
+}
+EXPORT_SYMBOL_GPL(sunxi_hdmi_codec_unregister);
+
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_DESCRIPTION("Allwinner HDMI CODEC");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sunxi/sun8i-i2s.c b/sound/soc/sunxi/sun8i-i2s.c
new file mode 100644
index 0000000..5b6f0d6
--- /dev/null
+++ b/sound/soc/sunxi/sun8i-i2s.c
@@ -0,0 +1,832 @@
+/*
+ * Allwinner sun8i I2S sound card
+ *
+ * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <sound/pcm_params.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+
+/* --- hardware --- */
+
+#define I2S_CTL 	  	0x00
+	/* common */
+	#define I2S_CTL_SDO3EN		BIT(11)
+	#define I2S_CTL_SDO2EN		BIT(10)
+	#define I2S_CTL_SDO1EN		BIT(9)
+	#define I2S_CTL_SDO0EN		BIT(8)
+//	#define I2S_CTL_LOOP		BIT(3)
+	#define I2S_CTL_TXEN		BIT(2)
+	#define I2S_CTL_RXEN		BIT(1)
+	#define I2S_CTL_GEN		BIT(0)
+	/* a83t */
+	#define I2S_CTL_A83T_MS		BIT(5)
+	#define I2S_CTL_A83T_PCM	BIT(4)
+	/* h3 */
+	#define I2S_CTL_H3_BCLKOUT	BIT(18)
+	#define I2S_CTL_H3_LRCKOUT	BIT(17)
+//	#define I2S_CTL_H3_LRCKROUT	BIT(16)
+//	#define I2S_CTL_H3_OUTMUTE	BIT(6)
+	#define I2S_CTL_H3_MODE_MSK	(3 << 4)
+//		#define I2S_CTL_H3_MODE_DSP_A	(0 << 4)
+//		#define I2S_CTL_H3_MODE_DSP_B	(0 << 4)
+		#define I2S_CTL_H3_MODE_I2S	(1 << 4)
+//		#define I2S_CTL_H3_MODE_LEFT_J	(1 << 4)
+//		#define I2S_CTL_H3_MODE_RIGHT_J	(2 << 4)
+
+#define I2S_FAT0 		0x04
+	/* common */
+	/* a83t */
+	#define I2S_FAT0_A83T_LRCP		BIT(7)
+	#define I2S_FAT0_A83T_BCP		BIT(6)
+	#define I2S_FAT0_A83T_SR_16BIT		(0 << 4)
+	#define I2S_FAT0_A83T_SR_24BIT		(2 << 4)
+	#define I2S_FAT0_A83T_SR_MSK		(3 << 4)
+	#define I2S_FAT0_A83T_WSS_32BCLK	(3 << 2)
+	#define I2S_FAT0_A83T_FMT_I2S1		(0 << 0)
+	#define I2S_FAT0_A83T_FMT_LFT		(1 << 0)
+	#define I2S_FAT0_A83T_FMT_RGT		(2 << 0)
+	#define I2S_FAT0_A83T_FMT_MSK		(3 << 0)
+	/* h3 */
+//	#define I2S_FAT0_H3_SDI_SYNC_SEL	BIT(31)
+//	#define I2S_FAT0_H3_LRCK_WIDTH	BIT(30)
+	#define I2S_FAT0_H3_LRCKR_PERIOD(v) ((v) << 20)
+	#define I2S_FAT0_H3_LRCKR_PERIOD_MSK (0x3ff << 20)
+	#define I2S_FAT0_H3_LRCK_POLARITY	BIT(19)
+	#define I2S_FAT0_H3_LRCK_PERIOD(v)	((v) << 8)
+	#define I2S_FAT0_H3_LRCK_PERIOD_MSK (0x3ff << 8)
+	#define I2S_FAT0_H3_BCLK_POLARITY	BIT(7)
+	#define I2S_FAT0_H3_SR_16		(3 << 4)
+//	#define I2S_FAT0_H3_SR_20		(4 << 4)
+	#define I2S_FAT0_H3_SR_24		(5 << 4)
+	#define I2S_FAT0_H3_SR_MSK		(7 << 4)
+//	#define I2S_FAT0_H3_EDGE_TRANSFER	BIT(3)
+	#define I2S_FAT0_H3_SW_16		(3 << 0)
+//	#define I2S_FAT0_H3_SW_20		(4 << 0)
+//	#define I2S_FAT0_H3_SW_24		(5 << 0)
+	#define I2S_FAT0_H3_SW_32		(7 << 0)
+	#define I2S_FAT0_H3_SW_MSK		(7 << 0)
+
+#define I2S_FAT1		0x08
+//	#define I2S_FAT1_RX_MLS		BIT(7)
+//	#define I2S_FAT1_TX_MLS		BIT(6)
+//	#define I2S_FAT1_SEXT		(3 << 4)
+//	#define I2S_FAT1_RX_PDM		(3 << 2)
+//	#define I2S_FAT1_TX_PDM		(3 << 0)
+
+//#define I2S_ISTA 		0x0c
+//	#define I2S_STA_TXU_INT		BIT(6)
+//	#define I2S_STA_TXO_INT		BIT(5)
+//	#define I2S_STA_TXE_INT		BIT(4)
+//	#define I2S_STA_RXU_INT		BIT(2)
+//	#define I2S_STA_RXO_INT		BIT(1)
+//	#define I2S_STA_RXA_INT		BIT(0)
+
+//#define I2S_RXFIFO		0x10
+
+#define I2S_FCTL		0x14
+//	#define I2S_FCTL_HUBEN		BIT(31)
+	#define I2S_FCTL_FTX		BIT(25)
+	#define I2S_FCTL_FRX		BIT(24)
+	#define I2S_FCTL_TXTL(v)	((v) << 12)
+//	#define I2S_FCTL_RXTL(v)	((v) << 4)
+	#define I2S_FCTL_TXIM		BIT(2)
+//	#define I2S_FCTL_RXOM		BIT(0)
+
+//#define I2S_FSTA   		0x18
+//	#define I2S_FSTA_TXE		BIT(28)
+//	#define I2S_FSTA_TXECNT(v)	((v) << 16)
+//	#define I2S_FSTA_RXA		BIT(8)
+//	#define I2S_FSTA_RXACNT(v)	((v) << 0)
+	
+#define I2S_INT    		0x1c
+	#define I2S_INT_TXDRQEN		BIT(7)
+//	#define I2S_INT_TXUIEN		BIT(6)
+//	#define I2S_INT_TXOIEN		BIT(5)
+//	#define I2S_INT_TXEIEN		BIT(4)
+//	#define I2S_INT_RXDRQEN		BIT(3)
+//	#define I2S_INT_RXUIEN		BIT(2)
+//	#define I2S_INT_RXOIEN		BIT(1)
+//	#define I2S_INT_RXAIEN		BIT(0)
+
+#define I2S_TXFIFO		0x20
+	
+#define I2S_CLKD   		0x24
+	/* common */
+	#define I2S_CLKD_BCLKDIV(v)	((v) << 4)
+	#define I2S_CLKD_MCLKDIV(v)	((v) << 0)
+	/* a83t */
+	#define I2S_CLKD_A83T_MCLKOEN	BIT(7)
+	/* h3 */
+	#define I2S_CLKD_H3_MCLKOEN	BIT(8)
+
+#define I2S_TXCNT  		0x28
+
+#define I2S_RXCNT  		0x2c
+
+/* --- A83T --- */
+#define I2S_TXCHSEL_A83T	0x30
+	#define I2S_TXCHSEL_A83T_CHNUM(v)	(((v) - 1) << 0)
+	#define I2S_TXCHSEL_A83T_CHNUM_MSK	(7 << 0)
+
+#define I2S_TXCHMAP_A83T	0x34
+
+/* --- H3 --- */
+#define I2S_TXCHCFG_H3		0x30
+//	#define I2S_TXCHCFG_H3_TX_SLOT_HIZ	BIT(9)
+//	#define I2S_TXCHCFG_H3_TX_STATE	BIT(8)
+//	#define I2S_TXCHCFG_H3_RX_SLOT_NUM	(7 << 4)
+	#define I2S_TXCHCFG_H3_TX_SLOT_NUM_MSK (7 << 0)
+	#define I2S_TXCHCFG_H3_TX_SLOT_NUM(v) ((v) << 0)
+
+#define I2S_TX0CHSEL_H3		0x34		/* 0..3 */
+//#define I2S_TX1CHSEL_H3	0x38
+//#define I2S_TX2CHSEL_H3	0x3c
+//#define I2S_TX3CHSEL_H3	0x40
+	#define I2S_TXn_H3_OFFSET_MSK	(3 << 12)
+	#define I2S_TXn_H3_OFFSET(v)	((v) << 12)
+	#define I2S_TXn_H3_CHEN_MSK	(0xff << 4)
+	#define I2S_TXn_H3_CHEN(v)	((v) << 4)
+	#define I2S_TXn_H3_CHSEL_MSK	(7 << 0)
+	#define I2S_TXn_H3_CHSEL(v)	((v) << 0)
+
+#define I2S_TX0CHMAP_H3		0x44		/* 0..3 */
+//#define I2S_TX1CHMAP_H3	0x48
+//#define I2S_TX2CHMAP_H3	0x4c
+//#define I2S_TX3CHMAP_H3	0x50
+//	#define I2S_TXn_H3_CH7_MAP	(7 << 28)
+//	#define I2S_TXn_H3_CH6_MAP	(7 << 24)
+//	#define I2S_TXn_H3_CH5_MAP	(7 << 20)
+//	#define I2S_TXn_H3_CH4_MAP	(7 << 16)
+//	#define I2S_TXn_H3_CH3_MAP	(7 << 12)
+//	#define I2S_TXn_H3_CH2_MAP	(7 << 8)
+//	#define I2S_TXn_H3_CH1_MAP	(7 << 4)
+//	#define I2S_TXn_H3_CH0_MAP	(7 << 0)
+//#define I2S_RXCHSEL_H3	0x54
+//	#define I2S_RXCHSEL_H3_RXOFFSET	(3 << 12)
+//	#define I2S_RXCHSEL_H3_RXCHSET	(7 << 0)
+
+//#define I2S_RXCHMAP_H3	0x58
+//	#define I2S_RXCHMAP_H3_CH7	(7 << 28)
+//	#define I2S_RXCHMAP_H3_CH6	(7 << 24)
+//	#define I2S_RXCHMAP_H3_CH5	(7 << 20)
+//	#define I2S_RXCHMAP_H3_CH4	(7 << 16)
+//	#define I2S_RXCHMAP_H3_CH3	(7 << 12)
+//	#define I2S_RXCHMAP_H3_CH2	(7 << 8)
+//	#define I2S_RXCHMAP_H3_CH1	(7 << 4)
+//	#define I2S_RXCHMAP_H3_CH0	(7 << 0)
+
+//#define I2S_DBG		0x5c
+
+/* --- driver --- */
+
+#define DRV_NAME "sun8i-audio"
+
+#define I2S_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | \
+	 SNDRV_PCM_FMTBIT_S20_3LE | \
+	 SNDRV_PCM_FMTBIT_S24_LE | \
+	 SNDRV_PCM_FMTBIT_S32_LE)
+
+#define PCM_LRCK_PERIOD 32
+#define PCM_LRCKR_PERIOD 1
+
+struct priv {
+	void __iomem *mmio;
+	struct clk *clk;
+//	struct clk *clk_i2s;
+//	struct clk *gate;
+	struct reset_control *rstc;
+	int type;
+#define SOC_A83T 0
+#define SOC_H3 1
+	struct snd_dmaengine_dai_dma_data dma_data;
+};
+
+static const struct of_device_id sun8i_i2s_of_match[] = {
+	{ .compatible = "allwinner,sun8i-a83t-i2s",
+				.data = (void *) SOC_A83T },
+	{ .compatible = "allwinner,sun8i-h3-i2s",
+				.data = (void *) SOC_H3 },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, sun8i_i2s_of_match);
+
+/* --- CPU DAI --- */
+
+static void sun8i_i2s_init(struct priv *priv)
+{
+	u32 reg;
+
+	/* disable global */
+	reg = readl(priv->mmio + I2S_CTL);
+	reg &= ~(I2S_CTL_GEN |
+		 I2S_CTL_RXEN |
+		 I2S_CTL_TXEN);
+	writel(reg, priv->mmio + I2S_CTL);
+
+	/* A83T */
+	if (priv->type == SOC_A83T) {
+		reg &= ~(I2S_CTL_A83T_MS |	/* codec clk & FRM slave */
+			 I2S_CTL_A83T_PCM);	/* I2S mode */
+		writel(reg, priv->mmio + I2S_CTL);
+
+		reg = readl(priv->mmio + I2S_FAT0);
+		reg &= ~I2S_FAT0_A83T_FMT_MSK;
+		reg |= I2S_FAT0_A83T_FMT_I2S1;
+
+		reg &= ~(I2S_FAT0_A83T_LRCP | I2S_FAT0_A83T_BCP);
+		writel(reg, priv->mmio + I2S_FAT0);
+
+		reg = I2S_FCTL_TXIM |			/* fifo */
+			 I2S_FCTL_TXTL(0x40);
+		writel(reg, priv->mmio + I2S_FCTL);
+
+		reg = readl(priv->mmio + I2S_FAT0);
+		reg &= ~(I2S_FAT0_A83T_LRCP |	/* normal bit clock + frame */
+			 I2S_FAT0_A83T_BCP);
+		writel(reg, priv->mmio + I2S_FAT0);
+
+	/* H3 */
+	} else {
+		reg = readl(priv->mmio + I2S_FCTL);
+		reg &= ~(I2S_FCTL_FRX | I2S_FCTL_FTX);	/* clear the FIFOs */
+		writel(reg, priv->mmio + I2S_FCTL);
+
+		writel(0, priv->mmio + I2S_TXCNT);	/* FIFO counters */
+		writel(0, priv->mmio + I2S_RXCNT);
+
+		reg = readl(priv->mmio + I2S_CTL);
+		reg |= I2S_CTL_H3_LRCKOUT | I2S_CTL_H3_BCLKOUT;
+						/* codec clk & FRM slave */
+
+		reg &= ~I2S_CTL_H3_MODE_MSK;
+		reg |= I2S_CTL_H3_MODE_I2S;		/* I2S mode */
+		writel(reg, priv->mmio + I2S_CTL);
+
+		reg = readl(priv->mmio + I2S_TX0CHSEL_H3) &
+					~I2S_TXn_H3_OFFSET_MSK;
+		reg |= I2S_TXn_H3_OFFSET(1);
+		writel(reg, priv->mmio + I2S_TX0CHSEL_H3);
+
+		reg = readl(priv->mmio + I2S_FAT0);
+		reg &= ~(I2S_FAT0_H3_BCLK_POLARITY | /* normal bclk & frame */
+			 I2S_FAT0_H3_LRCK_POLARITY);
+		writel(reg, priv->mmio + I2S_FAT0);
+	}
+}
+
+static int sun8i_i2s_set_clock(struct priv *priv,
+				unsigned long rate)
+{
+	unsigned long freq;
+	int ret, i, div;
+	u32 reg;
+	static const u8 div_tb[] = {
+		1, 2, 4, 6, 8, 12, 16, 24, // 32, 48, 64, 96, 128, 176, 192
+	};
+
+	/* compute the sys clock rate and divide values */
+	if (rate % 1000 == 0)
+		freq = 24576000;
+	else
+		freq = 22579200;
+	div = freq / 2 / PCM_LRCK_PERIOD / rate;
+	if (priv->type == SOC_A83T)
+		div /= 2;			/* bclk_div==0 => mclk/2 */
+	for (i = 0; i < ARRAY_SIZE(div_tb) - 1; i++)
+		if (div_tb[i] >= div)
+			break;
+
+	ret = clk_set_rate(priv->clk, freq);
+	if (ret) {
+		pr_info("Setting sysclk rate failed %d\n", ret);
+		return ret;
+	}
+
+	/* set the mclk and bclk dividor register */
+	if (priv->type == SOC_A83T) {
+		reg = I2S_CLKD_A83T_MCLKOEN | I2S_CLKD_MCLKDIV(i);
+	} else {
+		reg = I2S_CLKD_H3_MCLKOEN | I2S_CLKD_MCLKDIV(1) |
+				I2S_CLKD_BCLKDIV(i + 1);
+	}
+	writel(reg, priv->mmio + I2S_CLKD);
+
+	/* format */
+	reg = readl(priv->mmio + I2S_FAT0);
+	if (priv->type == SOC_A83T) {
+		reg |= I2S_FAT0_A83T_WSS_32BCLK;
+		reg &= ~I2S_FAT0_A83T_SR_MSK;
+		reg |= I2S_FAT0_A83T_SR_16BIT;
+	} else {
+		reg &= ~(I2S_FAT0_H3_LRCKR_PERIOD_MSK |
+			 I2S_FAT0_H3_LRCK_PERIOD_MSK);
+		reg |= I2S_FAT0_H3_LRCK_PERIOD(PCM_LRCK_PERIOD - 1) |
+			I2S_FAT0_H3_LRCKR_PERIOD(PCM_LRCKR_PERIOD - 1);
+
+		reg &= ~I2S_FAT0_H3_SW_MSK;
+		reg |= I2S_FAT0_H3_SW_16;
+
+		reg &= ~I2S_FAT0_H3_SR_MSK;
+		reg |= I2S_FAT0_H3_SR_16;
+	}
+	writel(reg, priv->mmio + I2S_FAT0);
+
+	writel(0, priv->mmio + I2S_FAT1);
+
+	return 0;
+}
+
+static int sun8i_i2s_prepare(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct priv *priv = snd_soc_card_get_drvdata(card);
+	int nchan = substream->runtime->channels;
+	u32 reg;
+
+	if (priv->type == SOC_A83T) {
+		reg = readl(priv->mmio + I2S_TXCHSEL_A83T);
+		reg &= ~I2S_TXCHSEL_A83T_CHNUM_MSK;
+		reg |= I2S_TXCHSEL_A83T_CHNUM(substream->runtime->channels);
+		writel(reg, priv->mmio + I2S_TXCHSEL_A83T);
+
+		switch (substream->runtime->channels) {
+		case 1:
+			reg = 0x76543200;
+			break;
+		case 8:
+			reg = 0x54762310;
+			break;
+		default:
+/* left/right inversion of channels 0 and 1 */
+			reg = 0x76543201;
+			break;
+		}
+		writel(reg, priv->mmio + I2S_TXCHMAP_A83T);
+	} else {
+		reg = readl(priv->mmio + I2S_TXCHCFG_H3) &
+					~I2S_TXCHCFG_H3_TX_SLOT_NUM_MSK;
+		if (nchan != 1)
+			reg |= I2S_TXCHCFG_H3_TX_SLOT_NUM(1);
+		writel(reg, priv->mmio + I2S_TXCHCFG_H3);
+
+		reg = readl(priv->mmio + I2S_TX0CHSEL_H3);
+//fixme: set in sun8i_i2s_set_fmt
+//		reg |= I2S_TXn_H3_OFFSET(1);
+		reg &= ~(I2S_TXn_H3_CHEN_MSK |
+			 I2S_TXn_H3_CHSEL_MSK);
+		reg |= I2S_TXn_H3_CHEN(3) |
+			I2S_TXn_H3_CHSEL(1);
+		writel(reg, priv->mmio + I2S_TX0CHSEL_H3);
+
+		reg = nchan == 1 ? 0 : 0x10;
+		writel(reg, priv->mmio + I2S_TX0CHMAP_H3);
+	}
+
+	reg = readl(priv->mmio + I2S_CTL);
+	reg &= ~(I2S_CTL_SDO3EN |
+		 I2S_CTL_SDO2EN |
+		 I2S_CTL_SDO1EN);
+	if (nchan >= 7)
+		reg |= I2S_CTL_SDO3EN;
+	if (nchan >= 5)
+		reg |= I2S_CTL_SDO2EN;
+	if (nchan >= 3)
+		reg |= I2S_CTL_SDO1EN;
+	reg |= I2S_CTL_SDO0EN;
+	writel(reg, priv->mmio + I2S_CTL);
+
+	writel(0, priv->mmio + I2S_TXCNT);
+
+	return 0;
+}
+
+static void sun8i_i2s_shutdown(struct snd_pcm_substream *substream,
+			      struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct priv *priv = snd_soc_card_get_drvdata(card);
+	u32 reg;
+
+	reg = readl(priv->mmio + I2S_CTL);
+	reg &= ~I2S_CTL_GEN;
+	writel(reg, priv->mmio + I2S_CTL);
+}
+
+static int sun8i_i2s_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct priv *priv = snd_soc_card_get_drvdata(card);
+	u32 reg, reg2;
+	int sample_resolution;
+	int ret;
+
+//test:trace
+pr_info("de2 i2s fmt %d rate %d\n",
+ params_format(params) == SNDRV_PCM_FORMAT_S16_LE ? 16 : 24,
+ params_rate(params));
+
+	ret = sun8i_i2s_set_clock(priv, params_rate(params));
+	if (ret)
+		return ret;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		sample_resolution = 16;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		sample_resolution = 24;
+		break;
+	default:
+		return -EINVAL;
+	}
+	reg = readl(priv->mmio + I2S_FAT0);
+	reg2 = readl(priv->mmio + I2S_FCTL);
+	if (priv->type == SOC_A83T) {
+		reg &= ~I2S_FAT0_A83T_SR_MSK;
+		if (sample_resolution == 16) {
+			reg |= I2S_FAT0_A83T_SR_16BIT;
+			reg2 |= I2S_FCTL_TXIM;
+		} else {
+			reg |= I2S_FAT0_A83T_SR_24BIT;
+			reg2 &= ~I2S_FCTL_TXIM;
+		}
+	} else {
+		reg &= ~(I2S_FAT0_H3_SR_MSK | I2S_FAT0_H3_SW_MSK);
+		if (sample_resolution == 16) {
+			reg |= I2S_FAT0_H3_SR_16 |
+					I2S_FAT0_H3_SW_16;
+			reg2 |= I2S_FCTL_TXIM;
+		} else {
+			reg |= I2S_FAT0_H3_SR_24 |
+					I2S_FAT0_H3_SW_32;
+			reg2 &= ~I2S_FCTL_TXIM;
+		}
+	}
+	writel(reg, priv->mmio + I2S_FAT0);
+	writel(reg2, priv->mmio + I2S_FCTL);
+
+	/* enable audio interface */
+	reg = readl(priv->mmio + I2S_CTL);
+	reg |= I2S_CTL_GEN;
+	writel(reg, priv->mmio + I2S_CTL);
+	msleep(10);
+
+	/* flush TX FIFO */
+	reg = readl(priv->mmio + I2S_FCTL);
+	reg |= I2S_FCTL_FTX;
+	writel(reg, priv->mmio + I2S_FCTL);
+
+	return 0;
+}
+
+static int sun8i_i2s_trigger(struct snd_pcm_substream *substream,
+				int cmd, struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct priv *priv = snd_soc_card_get_drvdata(card);
+	u32 reg;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		reg = readl(priv->mmio + I2S_CTL);
+		reg |= I2S_CTL_TXEN;
+		writel(reg, priv->mmio + I2S_CTL);
+
+		/* enable DMA DRQ mode */
+		reg = readl(priv->mmio + I2S_INT);
+		reg |= I2S_INT_TXDRQEN;
+		writel(reg, priv->mmio + I2S_INT);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		reg = readl(priv->mmio + I2S_INT);
+		reg &= ~I2S_INT_TXDRQEN;
+		writel(reg, priv->mmio + I2S_INT);
+
+//fixme: test: not in Allwinner's
+		reg = readl(priv->mmio + I2S_CTL);
+		reg &= ~I2S_CTL_TXEN;
+		writel(reg, priv->mmio + I2S_CTL);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sun8i_i2s_dai_ops = {
+	.hw_params = sun8i_i2s_hw_params,
+	.prepare = sun8i_i2s_prepare,
+	.trigger = sun8i_i2s_trigger,
+	.shutdown = sun8i_i2s_shutdown,
+};
+
+static int sun8i_i2s_dai_probe(struct snd_soc_dai *dai)
+{
+	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
+	struct priv *priv = snd_soc_card_get_drvdata(card);
+
+	snd_soc_dai_init_dma_data(dai, &priv->dma_data, NULL);
+
+	return 0;
+}
+
+static struct snd_soc_dai_driver sun8i_i2s_dai = {
+	.probe = sun8i_i2s_dai_probe,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_CONTINUOUS,
+		.rate_min = 32000,
+		.rate_max = 192000,
+		.formats = I2S_FORMATS,
+	},
+	.ops = &sun8i_i2s_dai_ops,
+};
+
+static const struct snd_soc_component_driver i2s_component = {
+	.name = DRV_NAME,
+};
+
+/* --- dma --- */
+
+static const struct snd_pcm_hardware sun8i_i2s_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
+	.formats = I2S_FORMATS,
+	.rates = SNDRV_PCM_RATE_CONTINUOUS,
+	.rate_min = 32000,
+	.rate_max = 192000,
+	.channels_min = 1,
+	.channels_max = 8,
+	.buffer_bytes_max = 1024 * 1024,
+	.period_bytes_min = 156,
+	.period_bytes_max = 1024 * 1024,
+	.periods_min = 1,
+	.periods_max = 8,
+	.fifo_size = 128,
+};
+
+static const struct snd_dmaengine_pcm_config sun8i_i2s_config = {
+	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
+	.pcm_hardware = &sun8i_i2s_pcm_hardware,
+	.prealloc_buffer_size = 1024 * 1024,
+};
+
+/* --- audio card --- */
+
+static struct device_node *sun8i_get_codec(struct device *dev)
+{
+	struct device_node *ep, *remote;
+
+	ep = of_graph_get_next_endpoint(dev->of_node, NULL);
+	if (!ep)
+		return NULL;
+	remote = of_graph_get_remote_port_parent(ep);
+	of_node_put(ep);
+
+	return remote;
+}
+
+static int sun8i_card_create(struct device *dev, struct priv *priv)
+{
+	struct snd_soc_card *card;
+	struct snd_soc_dai_link *dai_link;
+	struct snd_soc_dai_link_component *codec;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+	dai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);
+	if (!dai_link)
+		return -ENOMEM;
+	codec = devm_kzalloc(dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->of_node = sun8i_get_codec(dev);
+	if (!codec->of_node) {
+		dev_err(dev, "no port node\n");
+		return -ENXIO;
+	}
+
+	card->name = codec->of_node->name;
+	card->dai_link = dai_link;
+	card->num_links = 1;
+	dai_link->name = codec->of_node->name;
+	dai_link->stream_name = codec->of_node->name;
+	dai_link->platform_name = dev_name(dev);
+	dai_link->cpu_name = dev_name(dev);
+
+	dai_link->codecs = codec;
+	dai_link->num_codecs = 1;
+
+	/* the DAI name must be the name of codec node */
+	codec->dai_name = codec->of_node->name;
+
+	card->dev = dev;
+	dev_set_drvdata(dev, card);
+	snd_soc_card_set_drvdata(card, priv);
+
+	return devm_snd_soc_register_card(dev, card);
+}
+
+/* --- module init --- */
+
+static int sun8i_i2s_dev_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct priv *priv;
+	struct resource *mem;
+	int ret;
+
+	if (!dev->of_node) {
+		dev_err(dev, "no DT!\n");
+		return -EINVAL;
+	}
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* get the resources */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	priv->mmio = devm_ioremap_resource(dev, mem);
+	if (IS_ERR(priv->mmio))
+		return PTR_ERR(priv->mmio);
+
+	/* get SoC type */
+	priv->type = (int) of_match_device(sun8i_i2s_of_match,
+						&pdev->dev)->data;
+
+	/* get and enable the clocks */
+#if 0
+	priv->gate = devm_clk_get(dev, "apb");	/* optional */
+//	if (IS_ERR(priv->gate)) {
+//		dev_err(dev, "no gate\n");
+//		return PTR_ERR(priv->gate);
+//	}
+#endif
+#if 1 // test set_rate_parent ds ccu clk -> ok
+	priv->clk = devm_clk_get(dev, "mod");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "no clock\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	ret = clk_set_rate(priv->clk, 24576000);
+	if (ret) {
+		dev_err(dev, "cannot set rate of i2s clock %d\n", ret);
+		return ret;
+	}
+#else
+	priv->clk = devm_clk_get(dev, "pll");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "no pll clock\n");
+		return PTR_ERR(priv->clk);
+	}
+	priv->clk_i2s = devm_clk_get(dev, "clock");
+	if (IS_ERR(priv->clk_i2s)) {
+		dev_err(dev, "no clock\n");
+		return PTR_ERR(priv->clk_i2s);
+	}
+#endif
+	priv->rstc = devm_reset_control_get_optional(dev, NULL);
+//	if (IS_ERR(priv->rstc)) {
+//		dev_err(dev, "reset controller err %d\n",
+//				(int) PTR_ERR(priv->rstc));
+//		return PTR_ERR(priv->rstc);
+//	}
+	if (!IS_ERR(priv->rstc)) {
+		ret = reset_control_deassert(priv->rstc);
+		if (ret < 0)
+			return ret;
+	}
+
+#if 0
+	if (!IS_ERR(priv->gate)) {
+		ret = clk_prepare_enable(priv->gate);
+		if (ret < 0)
+			goto err_gate;
+	}
+#endif
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret < 0)
+		goto err_enable;
+
+#if 0 // test set_rate_parent ds ccu clk
+//fixme: added 16-10-19 and removed from the DTS - useless
+	ret = clk_set_parent(priv->clk_i2s, priv->clk);
+	if (ret < 0) {
+		dev_err(dev, "cannot set clock as i2s parent %d\n", ret);
+		goto err_i2s;
+	}
+
+	ret = clk_prepare_enable(priv->clk_i2s);
+	if (ret < 0)
+		goto err_i2s;
+#endif
+
+	/* activate the audio subsystem */
+	sun8i_i2s_init(priv);
+
+	ret = devm_snd_soc_register_component(dev, &i2s_component,
+						&sun8i_i2s_dai, 1);
+	if (ret) {
+		dev_err(dev, "snd_soc_register_component failed %d\n", ret);
+		goto err_register;
+	}
+
+	ret = devm_snd_dmaengine_pcm_register(dev, &sun8i_i2s_config, 0);
+	if (ret) {
+		dev_err(dev, "pcm_register failed %d\n", ret);
+		goto err_register;
+	}
+
+	priv->dma_data.maxburst = priv->type == SOC_A83T ? 8 : 4;
+	priv->dma_data.addr = mem->start + I2S_TXFIFO;
+//fixme: useless
+	priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+
+	ret = sun8i_card_create(dev, priv);
+	if (ret) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "register card failed %d\n", ret);
+		goto err_register;
+	}
+
+	return 0;
+
+err_register:
+// test set_rate_parent ds ccu clk
+//	clk_disable_unprepare(priv->clk_i2s);
+//err_i2s:
+	clk_disable_unprepare(priv->clk);
+err_enable:
+#if 0
+	clk_disable_unprepare(priv->gate);
+err_gate:
+#endif
+	if (!IS_ERR(priv->rstc))
+		reset_control_assert(priv->rstc);
+
+	return ret;
+}
+
+static int sun8i_i2s_dev_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(&pdev->dev);
+	struct priv *priv = snd_soc_card_get_drvdata(card); 
+
+// test set_rate_parent ds ccu clk
+//	clk_disable_unprepare(priv->clk_i2s);
+	clk_disable_unprepare(priv->clk);
+//	clk_disable_unprepare(priv->gate);
+	if (!IS_ERR_OR_NULL(priv->rstc))
+		reset_control_assert(priv->rstc);
+
+	return 0;
+}
+
+static struct platform_driver sun8i_i2s_driver = {
+	.probe  = sun8i_i2s_dev_probe,
+	.remove = sun8i_i2s_dev_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = of_match_ptr(sun8i_i2s_of_match),
+	},
+};
+
+module_platform_driver(sun8i_i2s_driver);
+
+MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
+MODULE_DESCRIPTION("Allwinner sun8i I2S ASoC Interface");
+MODULE_LICENSE("GPL v2");
