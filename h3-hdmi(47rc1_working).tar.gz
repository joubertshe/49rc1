h3-hdmi/Makefile0000644000175000017500000000065612730564321012053 0ustar  jefjef# Makefile for the HDMI driver of the H3 based OrangePi boards

ifneq ($(KERNELRELEASE),)

sunxi-de2-hdmi-objs := de2_hdmi.o de2_hdmi_h3.o
snd-soc-de2-i2s2-objs := de2_snd_i2s2.o
snd-soc-de2-codec-objs := de2_snd_codec.o

obj-m += sunxi-de2-hdmi.o
obj-m += snd-soc-de2-i2s2.o snd-soc-de2-codec.o

else

#KDIR ?= /lib/modules/`uname -r`/build
KDIR ?= /lib/modules/4.7.0-rc3-dirty/build

default:
	$(MAKE) -C $(KDIR) M=$$PWD

endif
h3-hdmi/de2_hdmi.c0000644000175000017500000002721312734170436012234 0ustar  jefjef/*
 * Allwinner DRM driver - HDMI
 *
 * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 */

#include <linux/module.h>
#include <linux/component.h>
#include <linux/clk.h>
#include <linux/hdmi.h>
#include <linux/of_device.h>
#include <linux/of_graph.h>

#include <drm/drmP.h>
#include <drm/drm_atomic_helper.h>
#include <drm/drm_crtc_helper.h>
#include <drm/drm_edid.h>
#include <drm/drm_of.h>

#include "de2_hdmi.h"
#include "de2_hdmi_h3.h"

static const struct of_device_id de2_hdmi_dt_ids[] = {
	{ .compatible = "allwinner,sun8i-a83t-hdmi",
					.data = (void *) SOC_A83T },
	{ .compatible = "allwinner,sun8i-h3-hdmi",
					.data = (void *) SOC_H3 },
	{ }
};
MODULE_DEVICE_TABLE(of, de2_hdmi_dt_ids);

#define conn_to_priv(x) \
	container_of(x, struct de2_hdmi_priv, connector)

#define enc_to_priv(x) \
	container_of(x, struct de2_hdmi_priv, encoder)

#if IS_ENABLED(CONFIG_SND_SOC)
/* --- audio functions --- */
static int de2_hdmi_set_audio_input(struct device *dev,
				    int enable,
				    unsigned sample_rate,
				    unsigned sample_bit)
{
	struct de2_hdmi_priv *priv = dev_get_drvdata(dev);
	int ret;

	if (!enable)
		return 0;		// disable

	mutex_lock(&priv->mutex);
	ret = bsp_hdmi_audio(priv, sample_rate, sample_bit);
	mutex_unlock(&priv->mutex);

	return ret;
}
#endif

/* --- encoder functions --- */

static void de2_hdmi_encoder_mode_set(struct drm_encoder *encoder,
					struct drm_display_mode *mode,
					struct drm_display_mode *adjusted_mode)
{
	struct de2_hdmi_priv *priv = enc_to_priv(encoder);

	priv->cea_mode = drm_match_cea_mode(mode);

	DRM_DEBUG_DRIVER("cea_mode %d\n", priv->cea_mode);

	clk_set_rate(priv->clk, mode->clock * 1000);

	mutex_lock(&priv->mutex);
	bsp_hdmi_video(priv);
	mutex_unlock(&priv->mutex);
}

static void de2_hdmi_encoder_enable(struct drm_encoder *encoder)
{ 
	struct de2_hdmi_priv *priv = enc_to_priv(encoder);

	DRM_DEBUG_DRIVER("\n");

	mutex_lock(&priv->mutex);
	bsp_hdmi_set_video_en(priv, 1);
	mutex_unlock(&priv->mutex);
}

static void de2_hdmi_encoder_disable(struct drm_encoder *encoder)
{ 
	struct de2_hdmi_priv *priv = enc_to_priv(encoder);

	DRM_DEBUG_DRIVER("\n");

	mutex_lock(&priv->mutex);
	bsp_hdmi_set_video_en(priv, 0);
	mutex_unlock(&priv->mutex);
}

static const struct drm_encoder_helper_funcs de2_hdmi_encoder_helper_funcs = {
	.mode_set = de2_hdmi_encoder_mode_set,
	.enable = de2_hdmi_encoder_enable,
	.disable = de2_hdmi_encoder_disable,
};

static const struct drm_encoder_funcs de2_hdmi_encoder_funcs = {
	.destroy = drm_encoder_cleanup,
};

/* --- connector functions --- */
static int de2_hdmi_connector_mode_valid(struct drm_connector *connector,
					struct drm_display_mode *mode)
{
	int cea_mode = drm_match_cea_mode(mode);

	if (bsp_hdmi_mode_valid(cea_mode) < 0)
		return MODE_NOMODE;
	return MODE_OK;
}

static enum drm_connector_status de2_hdmi_connector_detect(
				struct drm_connector *connector, bool force)
{
	struct de2_hdmi_priv *priv = conn_to_priv(connector);
	int ret;

	mutex_lock(&priv->mutex);
	ret = bsp_hdmi_get_hpd(priv);
	mutex_unlock(&priv->mutex);

	return ret ? connector_status_connected :
			connector_status_disconnected;
}

static int read_edid_block(void *data, u8 *buf,
			   unsigned int blk, size_t length)
{
	struct de2_hdmi_priv *priv = data;
	int ret;

	mutex_lock(&priv->mutex);
	ret = bsp_hdmi_ddc_read(priv,
				6,
				blk / 2, (blk & 1) ? 128 : 0,
				length, buf);
	mutex_unlock(&priv->mutex);

	return ret;
}

/* values duplicated from edid_cea_modes[] */
static const struct drm_display_mode lmodes_tb[] = {
	/* 1 - 640x480@60Hz */
	{ DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
		   752, 800, 0, 480, 490, 492, 525, 0,
		   DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3, },
	/* 4 - 1280x720@60Hz */
	{ DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
		   1430, 1650, 0, 720, 725, 730, 750, 0,
		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
	/* 16 - 1920x1080@60Hz */
	{ DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
		   2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
		   DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
	  .vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9, },
};

static int de2_hdmi_connector_get_modes(struct drm_connector *connector)
{
	struct de2_hdmi_priv *priv = conn_to_priv(connector);
	struct drm_display_mode *mode;
	const struct drm_display_mode *lmode;
	struct edid *edid;
	int n;

	DRM_DEBUG_DRIVER("\n");

#if IS_ENABLED(CONFIG_SND_SOC)
	priv->eld = NULL;
#endif

	edid = drm_do_get_edid(connector, read_edid_block, priv);

	if (!edid) {
		dev_warn(priv->dev, "failed to read EDID\n");
//fixme: test
//		drm_debug = /*DRM_UT_CORE |*/ DRM_UT_DRIVER | DRM_UT_KMS;
		if (!connector->cmdline_mode.specified)
			return 0;

		if (connector->cmdline_mode.xres == 1920 &&
		    connector->cmdline_mode.yres == 1080)
			lmode = &lmodes_tb[2];
		else if (connector->cmdline_mode.xres == 1280 &&
			 connector->cmdline_mode.yres == 720)
			lmode = &lmodes_tb[1];
		else
			lmode = &lmodes_tb[0];

		mode = drm_mode_duplicate(connector->dev, lmode);
		if (!mode)
			return 0;
		drm_mode_probed_add(connector, mode);

		return 1;
	}

	drm_mode_connector_update_edid_property(connector, edid);
	n = drm_add_edid_modes(connector, edid);
	priv->is_hdmi_sink = drm_detect_hdmi_monitor(edid);

#if IS_ENABLED(CONFIG_SND_SOC)
	if (priv->is_hdmi_sink) {
		drm_edid_to_eld(connector, edid);
		priv->eld = connector->eld;
	}
#endif

	DRM_DEBUG_DRIVER("%s EDID ok %d modes\n",
		priv->is_hdmi_sink ? "HDMI" : "DVI", n);

	kfree(edid);

	return n;
}

static struct drm_encoder *
de2_hdmi_connector_best_encoder(struct drm_connector *connector)
{
	struct de2_hdmi_priv *priv = conn_to_priv(connector);

	DRM_DEBUG_DRIVER("\n");

	return &priv->encoder;
}

static const
struct drm_connector_helper_funcs de2_hdmi_connector_helper_funcs = {
	.get_modes = de2_hdmi_connector_get_modes,
	.mode_valid = de2_hdmi_connector_mode_valid,
	.best_encoder = de2_hdmi_connector_best_encoder,
};

static void de2_hdmi_connector_destroy(struct drm_connector *connector)
{
	drm_connector_unregister(connector);
	drm_connector_cleanup(connector);
}

static const struct drm_connector_funcs de2_hdmi_connector_funcs = {
	.dpms = drm_atomic_helper_connector_dpms,
	.reset = drm_atomic_helper_connector_reset,
	.fill_modes = drm_helper_probe_single_connector_modes,
	.detect = de2_hdmi_connector_detect,
	.destroy = de2_hdmi_connector_destroy,
	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
};

static void de2_hdmi_cleanup(struct de2_hdmi_priv *priv)
{
	clk_disable_unprepare(priv->clk_ddc);
	clk_disable_unprepare(priv->clk);
	clk_disable_unprepare(priv->gate);
	if (!IS_ERR_OR_NULL(priv->rstc1))
		reset_control_assert(priv->rstc1);
	if (!IS_ERR_OR_NULL(priv->rstc0))
		reset_control_assert(priv->rstc0);
}

static int de2_hdmi_bind(struct device *dev, struct device *master, void *data)
{
	struct drm_device *drm = data;
	struct de2_hdmi_priv *priv = dev_get_drvdata(dev);
	struct drm_encoder *encoder = &priv->encoder;
	struct drm_connector *connector = &priv->connector;
	int ret;

	encoder->possible_crtcs =
			drm_of_find_possible_crtcs(drm, dev->of_node);

	/* if no CRTC, delay */
	if (encoder->possible_crtcs == 0)
		return -EPROBE_DEFER;

	/* HDMI init */
	ret = reset_control_deassert(priv->rstc0);
	if (ret)
		goto err;
	ret = reset_control_deassert(priv->rstc1);
	if (ret)
		goto err;
	if (!IS_ERR(priv->gate)) {
		ret = clk_prepare_enable(priv->gate);
		if (ret)
			goto err;
	}
	ret = clk_prepare_enable(priv->clk);
	if (ret)
		goto err;
	ret = clk_prepare_enable(priv->clk_ddc);
	if (ret)
		goto err;

	mutex_lock(&priv->mutex);
	bsp_hdmi_init(priv);
	bsp_hdmi_hrst(priv);		/* hpd reset */
	mutex_unlock(&priv->mutex);

	/* encoder init */
	ret = drm_encoder_init(drm, encoder, &de2_hdmi_encoder_funcs,
			       DRM_MODE_ENCODER_TMDS, NULL);
	if (ret)
		goto err;

	drm_encoder_helper_add(encoder, &de2_hdmi_encoder_helper_funcs);

	/* connector init */
	ret = drm_connector_init(drm, connector,
				 &de2_hdmi_connector_funcs,
				 DRM_MODE_CONNECTOR_HDMIA);
	if (ret)
		goto err_connector;

	connector->interlace_allowed = 1;
	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
				 DRM_CONNECTOR_POLL_DISCONNECT;
	drm_connector_helper_add(connector,
				 &de2_hdmi_connector_helper_funcs);

	ret = drm_connector_register(connector);
	if (ret)
		goto err_register;

	drm_mode_connector_attach_encoder(connector, encoder);

	return 0;

err_register:
	drm_connector_cleanup(connector);
err_connector:
	drm_encoder_cleanup(encoder);
err:
	de2_hdmi_cleanup(priv);
	DRM_DEBUG_DRIVER("err %d\n", ret);
	return ret;
}

static void de2_hdmi_unbind(struct device *dev, struct device *master,
			   void *data)
{
	struct de2_hdmi_priv *priv = dev_get_drvdata(dev);

	drm_connector_unregister(&priv->connector);
	drm_connector_cleanup(&priv->connector);
	drm_encoder_cleanup(&priv->encoder);
	de2_hdmi_cleanup(priv);
}

static const struct component_ops de2_hdmi_ops = {
	.bind = de2_hdmi_bind,
	.unbind = de2_hdmi_unbind,
};

static int de2_hdmi_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct de2_hdmi_priv *priv;
	struct resource *res;

	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	dev_set_drvdata(dev, priv);
	priv->dev = dev;

	mutex_init(&priv->mutex);

	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	if (!res) {
		dev_err(dev, "failed to get memory resource\n");
		return -ENXIO;
	}
	priv->mmio = devm_ioremap_resource(dev, res);
	if (IS_ERR(priv->mmio)) {
		dev_err(dev, "failed to map registers\n");
		return PTR_ERR(priv->mmio);
	}

	priv->gate = devm_clk_get(dev, "gate");	/* optional */
//	if (IS_ERR(priv->gate)) {
//		dev_err(dev, "gate clock err %d\n",
//					(int) PTR_ERR(priv->gate));
//		return PTR_ERR(priv->gate);
//	}
	priv->clk = devm_clk_get(dev, "clock");
	if (IS_ERR(priv->clk)) {
		dev_err(dev, "hdmi clock err %d\n",
					(int) PTR_ERR(priv->clk));
		return PTR_ERR(priv->clk);
	}
	priv->clk_ddc = devm_clk_get(dev, "ddc-clock");
	if (IS_ERR(priv->clk_ddc)) {
		dev_err(dev, "hdmi-ddc clock err %d\n",
					(int) PTR_ERR(priv->clk_ddc));
		return PTR_ERR(priv->clk_ddc);
	}
	priv->rstc0 = devm_reset_control_get(dev, "hdmi0");	/* optional */
	if (IS_ERR(priv->rstc0)) {
		dev_err(dev, "reset controller err %d\n",
				(int) PTR_ERR(priv->rstc0));
		return PTR_ERR(priv->rstc0);
	}
	priv->rstc1 = devm_reset_control_get(dev, "hdmi1");	/* optional */
	if (IS_ERR(priv->rstc1)) {
		dev_err(dev, "reset controller err %d\n",
				(int) PTR_ERR(priv->rstc1));
		return PTR_ERR(priv->rstc1);
	}

	priv->soc_type = (int) of_match_device(de2_hdmi_dt_ids,
						&pdev->dev)->data;

#if IS_ENABLED(CONFIG_SND_SOC)
	priv->set_audio_input = de2_hdmi_set_audio_input;
	de2_hdmi_codec_register(dev);
#endif

	return component_add(dev, &de2_hdmi_ops);
}

static int de2_hdmi_remove(struct platform_device *pdev)
{
#if IS_ENABLED(CONFIG_SND_SOC)
	de2_hdmi_codec_unregister(&pdev->dev);
#endif
	component_del(&pdev->dev, &de2_hdmi_ops);

	return 0;
}

static struct platform_driver de2_hdmi_driver = {
	.probe = de2_hdmi_probe,
	.remove = de2_hdmi_remove,
	.driver = {
		.name = "sun8i-h3-hdmi",
		.of_match_table = of_match_ptr(de2_hdmi_dt_ids),
	},
};

module_platform_driver(de2_hdmi_driver);

MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
MODULE_DESCRIPTION("Allwinner DE2 HDMI encoder/connector");
MODULE_LICENSE("GPL");
h3-hdmi/de2_hdmi.h0000644000175000017500000000216312720635142012231 0ustar  jefjef#ifndef __DE2_HDMI_H__
#define __DE2_HDMI_H__
/*
 * Copyright (C) 2016 Jean-François Moine
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 */

#include <linux/clk.h>
#include <linux/reset.h>
#include <drm/drmP.h>

/* SoC types */
#define SOC_A83T 0
#define SOC_H3 1

struct de2_hdmi_priv {
	struct device *dev;
	void __iomem *mmio;

	struct drm_encoder encoder;
	struct drm_connector connector;

	struct clk *clk;
	struct clk *clk_ddc;
	struct clk *gate;
	struct reset_control *rstc0;
	struct reset_control *rstc1;

	struct mutex mutex;
	u8 soc_type;
	u8 cea_mode;
	bool is_hdmi_sink;
	bool is_yuv;
#if IS_ENABLED(CONFIG_SND_SOC)
	u8 *eld;
	int (*set_audio_input)(struct device *dev,
				int enable,
				unsigned sample_rate,
				unsigned sample_bit);
#endif
};

#if IS_ENABLED(CONFIG_SND_SOC)
int de2_hdmi_codec_register(struct device *dev);
void de2_hdmi_codec_unregister(struct device *dev);
#endif
#endif /* __DE2_HDMI_H__ */
h3-hdmi/de2_hdmi_h3.c0000644000175000017500000006213612735657147012643 0ustar  jefjef/*
 * Allwinner A83T and H3 HDMI lowlevel functions
 *
 * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
 *
 * Adapted from the files
 *	lichee/linux-3.4/drivers/video/sunxi/disp2/hdmi/aw/
 *		hdmi_bsp_sun8iw6.c and hdmi_bsp_sun8iw7.c
 * with no license nor copyright.
 */

/*
 * from https://linux-sunxi.org/DWC_HDMI_Controller
 * Synopsys DesignWare HDMI controller
 * doc: https://www.synopsys.com/dw/doc.php/ds/c/dwc_hdmi_tx_csds.pdf
 * PHY (unknown)
 *	10000: ?
 *		0000ff00: 03 or 00
 *	10004: ?
 *		ff000000: a0 (A83T)
 *	10010: HDMI_READ_LOCK
 *	10020: HDMI_H3_PHY_CTRL
 *		00000001: enable ?
 *		00000002: ??
 *		00000004: ??
 *		00000008: ??
 *		00000070: ??
 *		00000080: ??
 *		00000f00: video enable
 *		00010000: ??
 *		00040000: ??
 *		00080000: ??
 *		init: 01ff0f7f
 *	10024:
 *		init: 80639000
 *	10028:
 *		init: 0f81c405
 *	1002c:
 *		init: 39dc5040, | 02000000, | (parts of 10038)
 *	10030: HDMI_H3_PHY_CLK (clock divider parent PLL3 (video)
 *		init: 80084343
 *	10034:
 *		init:00000001
 *	10038: HDMI_H3_PHY_STATUS
 *		00000080: reset ok ?
 *		00080000: HDMI connected
 *		0001f800: ? -> (>> 11) | 1002c
 *		c0000000: ?? -> | 1002c
 */

#include <drm/drmP.h>

#include "de2_hdmi.h"
#include "de2_hdmi_h3.h"

/*
 * [0] = vic (cea Video ID)
 * [1] used in hdmi_phy_set / bsp_hdmi_audio
 * [2..17] used in bsp_hdmi_video
 */
static const struct para_tab {
	u32 para[18];
} ptbl[] = {
	{{  6,  1, 1,  1,  5,  3, 0, 1, 4, 0, 0, 160,  20,  38, 124, 240, 22, 0}},
	{{ 21, 11, 1,  1,  5,  3, 1, 1, 2, 0, 0, 160,  32,  24, 126,  32, 24, 0}},
	{{  2, 11, 0,  0,  2,  6, 1, 0, 9, 0, 0, 208, 138,  16,  62, 224, 45, 0}},
	{{ 17, 11, 0,  0,  2,  5, 2, 0, 5, 0, 0, 208, 144,  12,  64,  64, 49, 0}},
	{{ 19,  4, 0, 96,  5,  5, 2, 2, 5, 1, 0,   0, 188, 184,  40, 208, 30, 1}},
	{{  4,  4, 0, 96,  5,  5, 2, 1, 5, 0, 0,   0, 114, 110,  40, 208, 30, 1}},
	{{ 20,  4, 0, 97,  7,  5, 4, 2, 2, 2, 0, 128, 208,  16,  44,  56, 22, 1}},
	{{  5,  4, 0, 97,  7,  5, 4, 1, 2, 0, 0, 128,  24,  88,  44,  56, 22, 1}},
	{{ 31,  2, 0, 96,  7,  5, 4, 2, 4, 2, 0, 128, 208,  16,  44,  56, 45, 1}},
	{{ 16,  2, 0, 96,  7,  5, 4, 1, 4, 0, 0, 128,  24,  88,  44,  56, 45, 1}},
	{{ 32,  4, 0, 96,  7,  5, 4, 3, 4, 2, 0, 128,  62, 126,  44,  56, 45, 1}},
	{{ 33,  4, 0,  0,  7,  5, 4, 2, 4, 2, 0, 128, 208,  16,  44,  56, 45, 1}},
	{{ 34,  4, 0,  0,  7,  5, 4, 1, 4, 0, 0, 128,  24,  88,  44,  56, 45, 1}},
#if 0
	{{160,  2, 0, 96,  7,  5, 8, 3, 4, 1, 0, 128,  62, 126,  44, 157, 45, 1}},
	{{147,  2, 0, 96,  5,  5, 5, 2, 5, 1, 0,   0, 188, 184,  40, 190, 30, 1}},
	{{132,  2, 0, 96,  5,  5, 5, 1, 5, 0, 0,   0, 114, 110,  40, 160, 30, 1}},
	{{257,  1, 0, 96, 15, 10, 8, 2, 8, 0, 0,   0,  48, 176,  88, 112, 90, 1}},
	{{258,  1, 0, 96, 15, 10, 8, 5, 8, 4, 0,   0, 160,  32,  88, 112, 90, 1}},
#endif
};

#if IS_ENABLED(CONFIG_SND_SOC)
/* audio */
#if 0 /* 'ca' always 0 */
static const unsigned char ca_table[] = {
	0x11, 0x13, 0x31, 0x33, 0x15, 0x17, 0x35, 0x37,
	0x55, 0x57, 0x75, 0x77, 0x5d, 0x5f, 0x7d, 0x7f, 
	0xdd, 0xdf, 0xfd, 0xff, 0x99, 0x9b, 0xb9, 0xbb,
	0x9d, 0x9f, 0xbd, 0xbf, 0xdd, 0xdf, 0xfd, 0xff,
};
#endif

/* HDMI_FC_AUDSCHNLS7 values */
static const struct pcm_sf {
	u32 	sf;
	unsigned char	cs_sf;
} sf[] = {
	{44100,	0x00},
	{48000, 0x02},
	{96000, 0x0a},
	{192000,0x0e},
	{22050,	0x04},
	{24000,	0x06},
	{32000, 0x03},
	{88200,	0x08},
	{768000,0x09},
	{176400,0x0c},
};

static const struct {
	int rate;
	unsigned short n1, n2;
} n_table[] = {
	{32000,	3072,	4096},
	{44100,	4704,	6272},
	{88200,	4704*2,	6272*2},
	{176400,4704*4,	6272*4},
	{48000,	5120,	6144},
	{96000,	5120*2,	6144*2},
	{192000,5120*4,	6144*4},
};
#endif

static inline void hdmi_writeb(struct de2_hdmi_priv *priv,
			u32 addr, u8 data)
{
	writeb_relaxed(data, priv->mmio + addr);
}

static inline void hdmi_writel(struct de2_hdmi_priv *priv,
			u32 addr, u32 data)
{
	writel_relaxed(data, priv->mmio + addr);
}

static inline u8 hdmi_readb(struct de2_hdmi_priv *priv,
			u32 addr)
{
	return readb_relaxed(priv->mmio + addr);
}

static inline u32 hdmi_readl(struct de2_hdmi_priv *priv,
			u32 addr)
{
	return readl_relaxed(priv->mmio + addr);
}

static void hdmi_phy_init(struct de2_hdmi_priv *priv)
{
	int to_cnt;
	u32 tmp;

	if (priv->soc_type == SOC_H3) {
		hdmi_writel(priv, 0x10020, 0);
		hdmi_writel(priv, 0x10020, 1 << 0);
		udelay(5);
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 16));
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 1));
		udelay(10);
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 2));
		udelay(5);
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 3));
		usleep_range(40, 50);
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 19));
		usleep_range(100, 120);
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 18));
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (7 << 4));

		to_cnt = 10;
		while (1) {
			if (hdmi_readl(priv, 0x10038) & 0x80)
				break;
			usleep_range(200, 250);
			if (--to_cnt == 0) {
				pr_warn("hdmi phy init timeout\n");
				break;
			}
		}

		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (0xf << 8));
		hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) | (1 << 7));

		hdmi_writel(priv, 0x1002c, 0x39dc5040);
		hdmi_writel(priv, 0x10030, 0x80084343);
		msleep(10);
		hdmi_writel(priv, 0x10034, 0x00000001);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | 0x02000000);
		msleep(100);
		tmp = hdmi_readl(priv, 0x10038);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | 0xc0000000);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							((tmp >> 11) & 0x3f));
		hdmi_writel(priv, 0x10020, 0x01ff0f7f);
		hdmi_writel(priv, 0x10024, 0x80639000);
		hdmi_writel(priv, 0x10028, 0x0f81c405);
	} else {					/* A83T */
		hdmi_writeb(priv, 0x10000, 0x01);
		hdmi_writeb(priv, 0x10001, 0x00);
		hdmi_writeb(priv, 0x10002, 100 + 5);
		hdmi_writeb(priv, 0x10003, 0x00);
		hdmi_writeb(priv, 0x10007, 0xa0);
		hdmi_writeb(priv, 0x0083, 0x01);	// 4005 HDMI_MC_PHYRSTZ
		udelay(1);
		hdmi_writeb(priv, 0x0240, 0x06);	// 3000 HDMI_PHY_CONF0
							// seldataenpol | gen2_enhpdrxsense
		hdmi_writeb(priv, 0x0240, 0x16);	// | gen2_pddq
		hdmi_writeb(priv, 0x0240, 0x12);	// ^ gen2_enhpdrxsense
		hdmi_writeb(priv, 0x8242, 0xf0);	// 3006	HDMI_PHY_MASK0
		hdmi_writeb(priv, 0xa243, 0xff);	// 3007 HDMI_PHY_POL0
		hdmi_writeb(priv, 0x6240, 0xff);	// 3000	HDMI_PHY_CONF0
		hdmi_writeb(priv, 0x0012, 0xff);	// 0104 HDMI_IH_PHY_STAT0
		hdmi_writeb(priv, 0x4010, 0xff);	// 0108 HDMI_IH_I2CMPHY_STAT0
		hdmi_writeb(priv, 0x0083, 0x00);	// 4005 HDMI_MC_PHYRSTZ
		hdmi_writeb(priv, 0x0240, 0x16);	// 3000 HDMI_PHY_CONF0
		hdmi_writeb(priv, 0x0240, 0x06);
		hdmi_writeb(priv, 0x0241, 0x20);	// 3001 HDMI_PHY_TST0
							// testclr
		hdmi_writeb(priv, 0x2240, 100 + 5);	// 3020 HDMI_PHY_I2CM_SLAVE_ADDR
		hdmi_writeb(priv, 0x0241, 0x00);	// 3001
	}
}

static int get_vid(u32 id)
{
	u32 i;

	for (i = 0; i < ARRAY_SIZE(ptbl); i++) {
		if (id == ptbl[i].para[0])
			return i;
	}

	return -1;
}

static int hdmi_phy_set_h3(struct de2_hdmi_priv *priv, int i)
{
	u32 tmp;

	hdmi_writel(priv, 0x10020, hdmi_readl(priv, 0x10020) & ~0xf000);
	switch (ptbl[i].para[1]) {
	case 1:
		hdmi_writel(priv, 0x1002c, 0x31dc5fc0);	/* or 0x30dc5fc0 ? */
		hdmi_writel(priv, 0x10030, 0x800863c0);
		msleep(10);
		hdmi_writel(priv, 0x10034, 0x00000001);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
						0x02000000);
		msleep(200);
		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0xc0000000);
		if (tmp < 0x3d)
			tmp += 2;
		else
			tmp = 0x3f;
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
		msleep(100);
		hdmi_writel(priv, 0x10020, 0x01ffff7f);
		hdmi_writel(priv, 0x10024, 0x8063b000);
		hdmi_writel(priv, 0x10028, 0x0f8246b5);
		break;
	case 2:				/* 1080P @ 60 & 50 */
		hdmi_writel(priv, 0x1002c, 0x39dc5040);
		hdmi_writel(priv, 0x10030, 0x80084381);
		msleep(10);
		hdmi_writel(priv, 0x10034, 0x00000001);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0x02000000);
		msleep(100);
		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0xc0000000);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
		hdmi_writel(priv, 0x10020, 0x01ffff7f);
		hdmi_writel(priv, 0x10024, 0x8063a800);
		hdmi_writel(priv, 0x10028, 0x0f81c485);
		break;
	case 4:				/* 720P @ 50 & 60, 1080I, 1080P */
		hdmi_writel(priv, 0x1002c, 0x39dc5040);
		hdmi_writel(priv, 0x10030, 0x80084343);
		msleep(10);
		hdmi_writel(priv, 0x10034, 0x00000001);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0x02000000);
		msleep(100);
		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0xc0000000);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
		hdmi_writel(priv, 0x10020, 0x01ffff7f);
		hdmi_writel(priv, 0x10024, 0x8063b000);
		hdmi_writel(priv, 0x10028, 0x0f81c405);
		break;
	case 11:				/* 480P/576P */
		hdmi_writel(priv, 0x1002c, 0x39dc5040);
		hdmi_writel(priv, 0x10030, 0x8008430a);
		msleep(10);
		hdmi_writel(priv, 0x10034, 0x00000001);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0x02000000);
		msleep(100);
		tmp = (hdmi_readl(priv, 0x10038) >> 11) & 0x3f;
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) |
							0xc0000000);
		hdmi_writel(priv, 0x1002c, hdmi_readl(priv, 0x1002c) | tmp);
		hdmi_writel(priv, 0x10020, 0x01ffff7f);
		hdmi_writel(priv, 0x10024, 0x8063b000);
		hdmi_writel(priv, 0x10028, 0x0f81c405);
		break;
	default:
		return -1;
	}

	return 0;
}

static void hdmi_i2cm_write(struct de2_hdmi_priv *priv,
			    int addr, u8 valh, u8 vall)
{
	hdmi_writeb(priv, 0x2241, addr); // 3021 HDMI_PHY_I2CM_ADDRESS_ADDR
	hdmi_writeb(priv, 0xa240, valh); // 3022 HDMI_PHY_I2CM_DATAO_1_ADDR
	hdmi_writeb(priv, 0xa241, vall); // 3023 HDMI_PHY_I2CM_DATAO_0_ADDR
	hdmi_writeb(priv, 0xa242, 0x10); // 3026 HDMI_PHY_I2CM_OPERATION_ADDR
					 // write
	usleep_range(2000, 2500);
}

static int hdmi_phy_set_a83t(struct de2_hdmi_priv *priv, int i)
{
	switch (ptbl[i].para[1]) {
	case 1:
		hdmi_i2cm_write(priv, 0x06, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x15, 0x00, 0x0f);
		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x19, 0x00, 0x02);
		hdmi_i2cm_write(priv, 0x0e, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x09, 0x80, 0x2b);
		break;
	case 2:				/* 1080P @ 60 & 50 */
		hdmi_i2cm_write(priv, 0x06, 0x04, 0xa0);
		hdmi_i2cm_write(priv, 0x15, 0x00, 0x0a);
		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x19, 0x00, 0x02);
		hdmi_i2cm_write(priv, 0x0e, 0x00, 0x21);
		hdmi_i2cm_write(priv, 0x09, 0x80, 0x29);
		break;
	case 4:				/* 720P @ 50 & 60, 1080I, 1080P */
		hdmi_i2cm_write(priv, 0x06, 0x05, 0x40);
		hdmi_i2cm_write(priv, 0x15, 0x00, 0x05);
		hdmi_i2cm_write(priv, 0x10, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x19, 0x00, 0x07);
		hdmi_i2cm_write(priv, 0x0e, 0x02, 0xb5);
		hdmi_i2cm_write(priv, 0x09, 0x80, 0x09);
		break;
	case 11:				/* 480P/576P */
		hdmi_i2cm_write(priv, 0x06, 0x01,
					ptbl[i].para[2] ? 0xe3 : 0xe0);
		hdmi_i2cm_write(priv, 0x15, 0x00, 0x00);
		hdmi_i2cm_write(priv, 0x10, 0x08, 0xda);
		hdmi_i2cm_write(priv, 0x19, 0x00, 0x07);
		hdmi_i2cm_write(priv, 0x0e, 0x03, 0x18);
		hdmi_i2cm_write(priv, 0x09, 0x80, 0x09);
		break;
	default:
		return -1;
	}
	hdmi_i2cm_write(priv, 0x1e, 0x00, 0x00);
	hdmi_i2cm_write(priv, 0x13, 0x00, 0x00);
	hdmi_i2cm_write(priv, 0x17, 0x00, 0x00);
	hdmi_writeb(priv, 0x0240, 0x0e);

	return 0;
}

static void hdmi_read_lock(struct de2_hdmi_priv *priv)
{
	hdmi_writeb(priv, 0x10010, 0x45);
	hdmi_writeb(priv, 0x10011, 0x45);
	hdmi_writeb(priv, 0x10012, 0x52);
	hdmi_writeb(priv, 0x10013, 0x54);
}
static void hdmi_read_unlock(struct de2_hdmi_priv *priv)
{
	hdmi_writeb(priv, 0x10010, 0x52);
	hdmi_writeb(priv, 0x10011, 0x54);
	hdmi_writeb(priv, 0x10012, 0x41);
	hdmi_writeb(priv, 0x10013, 0x57);
}

static void bsp_hdmi_inner_init(struct de2_hdmi_priv *priv)
{
	hdmi_read_lock(priv);

	// software reset
	hdmi_writeb(priv, 0x8080,  0x00);		// 4002 HDMI_MC_SWRSTZ
	udelay(2);

	// mask all interrupt
	hdmi_writeb(priv, 0xf01f, 0x00);		// 01ff HDMI_IH_MUTE
	hdmi_writeb(priv, 0x8403, 0xff);		// 0807 HDMI_VP_MASK
	hdmi_writeb(priv, 0x904c, 0xff);		// 10d2 HDMI_FC_MASK0
	hdmi_writeb(priv, 0x904e, 0xff);		// 10d6 HDMI_FC_MASK1
	hdmi_writeb(priv, 0xd04c, 0xff);		// 10da HDMI_FC_MASK2
	hdmi_writeb(priv, 0x8250, 0xff);		// 3102 HDMI_AUD_INT
	hdmi_writeb(priv, 0x8a50, 0xff);		// 3302 HDMI_AUD_SPDIFINT
	hdmi_writeb(priv, 0x8272, 0xff);		// 3506 HDMI_GP_POL
	hdmi_writeb(priv, 0x40c0, 0xff);		// 5008 HDMI_A_APIINTMSK
	hdmi_writeb(priv, 0x86f0, 0xff);		// 7d02 HDMI_CEC_MASK
	hdmi_writeb(priv, 0x0ee3, 0xff);		// 7e05 HDMI_I2CM_INT
	hdmi_writeb(priv, 0x8ee2, 0xff);		// 7e06 HDMI_I2CM_CTLINT

	hdmi_writeb(priv, 0xa049, 0xf0);		// 1063 HDMI_FC_AUDSCONF
	hdmi_writeb(priv, 0xb045, 0x1e);		// 10b3 HDMI_FC_DATAUTO0
	hdmi_writeb(priv, 0x00c1, 0x00);		// 5001 HDMI_A_HDCPCFG1
	hdmi_writeb(priv, 0x00c1, 0x03);
	hdmi_writeb(priv, 0x00c0, 0x00);		// 5000 HDMI_A_HDCPCFG0
	hdmi_writeb(priv, 0x40c1, 0x10);		// 5009 HDMI_A_VIDPOLCFG
	if (priv->soc_type == SOC_H3) {
// from FriendlyARM - tkaiser
		hdmi_writeb(priv, 0x0081, 0xfd);	// 4001 HDMI_MC_CLKDIS
		hdmi_writeb(priv, 0x0081, 0x00);
		hdmi_writeb(priv, 0x0081, 0xfd);
	} else {
		hdmi_writeb(priv, 0x0081, 0xff);	// 4001 HDMI_MC_CLKDIS
		hdmi_writeb(priv, 0x0081, 0x00);
		hdmi_writeb(priv, 0x0081, 0xff);
	}
	hdmi_writeb(priv, 0x0010, 0xff);		// 0100 HDMI_IH_FC_STAT0
	hdmi_writeb(priv, 0x0011, 0xff);		// 0101 HDMI_IH_FC_STAT1
	hdmi_writeb(priv, 0x8010, 0xff);		// 0102 HDMI_IH_FC_STAT2
	hdmi_writeb(priv, 0x8011, 0xff);		// 0103 HDMI_IH_AS_STAT0
	hdmi_writeb(priv, 0x0013, 0xff);		// 0105 HDMI_IH_I2CM_STAT0
	hdmi_writeb(priv, 0x8012, 0xff);		// 0106 HDMI_IH_CEC_STAT0
	hdmi_writeb(priv, 0x8013, 0xff);		// 0107 HDMI_IH_VP_STAT0
}

void bsp_hdmi_init(struct de2_hdmi_priv *priv)
{
	if (priv->soc_type == SOC_H3)
		hdmi_phy_init(priv);
	bsp_hdmi_inner_init(priv);
	if (priv->soc_type != SOC_H3)
		hdmi_phy_init(priv);
}

void bsp_hdmi_set_video_en(struct de2_hdmi_priv *priv,
			unsigned char enable)
{
	if (priv->soc_type == SOC_H3) {
		if (enable)
			hdmi_writel(priv, 0x10020,
				hdmi_readl(priv, 0x10020) | (0x0f << 12));
		else
			hdmi_writel(priv, 0x10020,
				hdmi_readl(priv, 0x10020) & ~(0x0f << 12));
	} else {
#if 0
		hdmi_writeb(priv, 0x0840, enable ? 0 : 1);	// 1200
#endif
	}
}

#if IS_ENABLED(CONFIG_SND_SOC)
/* start audio */
int bsp_hdmi_audio(struct de2_hdmi_priv *priv,
		int sample_rate, int sample_bit)
{
	int id = get_vid(priv->cea_mode);	/* ptbl index */
	unsigned int i, n;

//test
pr_info("hdmi audio cea %d id %d rate %d bit %d\n",
 priv->cea_mode, id, sample_rate, sample_bit);
	if (id < 0)
		return id;

// always 2 channels
//	hdmi_writeb(priv, 0xa049, audio->ch_num > 2 ? 0xf1 : 0xf0);
	hdmi_writeb(priv, 0xa049, 0xf0);		// 1063 HDMI_FC_AUDSCONF

#if 1 // audio->ca always 0
	hdmi_writeb(priv, 0x204b, ~0x11);		// 1065 HDMI_FC_AUDSV
#else
	i = audio->ca;
	if (i < ARRAY_SIZE(ca_table))
		hdmi_writeb(priv, 0x204b, ~ca_table[i]);
#endif

	hdmi_writeb(priv, 0xa04a, 0x00);		// 1066 HDMI_FC_AUDSU
	hdmi_writeb(priv, 0xa04b, 0x30);		// 1067 HDMI_FC_AUDSCHNLS0
	hdmi_writeb(priv, 0x6048, 0x00);		// 1068 HDMI_FC_AUDSCHNLS1
	hdmi_writeb(priv, 0x6049, 0x01);		// 1069 HDMI_FC_AUDSCHNLS2
	hdmi_writeb(priv, 0xe048, 0x42);		// 106a HDMI_FC_AUDSCHNLS3
	hdmi_writeb(priv, 0xe049, 0x86);		// 106b HDMI_FC_AUDSCHNLS4
	hdmi_writeb(priv, 0x604a, 0x31);		// 106c HDMI_FC_AUDSCHNLS5
	hdmi_writeb(priv, 0x604b, 0x75);		// 106d HDMI_FC_AUDSCHNLS6
	hdmi_writeb(priv, 0xe04a, 0x01);		// 106e HDMI_FC_AUDSCHNLS7
	for (i = 0; i < ARRAY_SIZE(sf); i++) {
		if (sample_rate == sf[i].sf) {
			hdmi_writeb(priv, 0xe04a, sf[i].cs_sf); // 106e
			break;
		}
	}
	hdmi_writeb(priv, 0xe04b,			// 106f HDMI_FC_AUDSCHNLS8
		(sample_bit == 16) ? 0x02 :
			(sample_bit == 24 ? 0x0b :
					    0x00));

	hdmi_writeb(priv, 0x0251, sample_bit);		// 3101 HDMI_AUD_CONF1

	n = 6272;
	for (i = 0; i < ARRAY_SIZE(n_table); i++) {
		if (sample_rate == n_table[i].rate) {
			if (ptbl[id].para[1] == 1)
				n = n_table[i].n1;
			else
				n = n_table[i].n2;
			break;
		}
	}

	hdmi_writeb(priv, 0x0a40, n);			// 3200 HDMI_AUD_N1
	hdmi_writeb(priv, 0x0a41, n >> 8);		// 3201 HDMI_AUD_N2
	hdmi_writeb(priv, 0x8a40, n >> 16);		// 3202 HDMI_AUD_N3
	hdmi_writeb(priv, 0x0a43, 0x00);		// 3205 HDMI_AUD_CTS3
	hdmi_writeb(priv, 0x8a42, 0x04);		// 3206 HDMI_AUD_INPUTCLKFS
// always 2 channels
//	hdmi_writeb(priv, 0xa049, audio->ch_num > 2 ? 0x01 : 0x00);
//	hdmi_writeb(priv, 0x2043, audio->ch_num * 16);
	hdmi_writeb(priv, 0xa049, 0x00);		// 1063 HDMI_FC_AUDSCONF
							//	layout0
	hdmi_writeb(priv, 0x2043, 2 * 16);		// 1025 HDMI_FC_AUDICONF0
	hdmi_writeb(priv, 0xa042, 0x00);		// 1026 HDMI_FC_AUDICONF1
// audio->ca always 0 for 2 channels
//	hdmi_writeb(priv, 0xa043, audio->ca);
	hdmi_writeb(priv, 0xa043, 0x00);		// 1027 HDMI_FC_AUDICONF2
	hdmi_writeb(priv, 0x6040, 0x00);		// 1028 HDMI_FC_AUDICONF3

#if 1 // PCM only
	hdmi_writeb(priv, 0x8251, 0x00);		// 3103 HDMI_AUD_CONF2
#else
	if (audio->type == PCM) {
		hdmi_writeb(priv, 0x8251, 0x00);
	} else if (audio->type == DTS_HD || audio->type == DDP) {
		hdmi_writeb(priv, 0x8251, 0x03);
		hdmi_writeb(priv, 0x0251, 0x15);
		hdmi_writeb(priv, 0xa043, 0);
	} else {
		hdmi_writeb(priv, 0x8251, 0x02);
		hdmi_writeb(priv, 0x0251, 0x15);
		hdmi_writeb(priv, 0xa043, 0);
	}
#endif

	hdmi_writeb(priv, 0x0250, 0x00);		// 3100 HDMI_AUD_CONF0
	hdmi_writeb(priv, 0x0081, 0x08);		// 4001 HDMI_MC_CLKDIS
							//	AUDCLK_DISABLE
	hdmi_writeb(priv, 0x8080, 0xf7);		// 4002 HDMI_MC_SWRSTZ
	usleep_range(100, 120);
	hdmi_writeb(priv, 0x0250, 0xaf);		// 3100 HDMI_AUD_CONF0
	usleep_range(100, 120);
	hdmi_writeb(priv, 0x0081, 0x00);		// 4001 HDMI_MC_CLKDIS
							//	enable all clocks

	return 0;
}
#endif

/* initialize */
int bsp_hdmi_video(struct de2_hdmi_priv *priv)
{
	int i = get_vid(priv->cea_mode);	/* ptbl index */
	int csc;				/* color space */

	if (i < 0)
		return i;

	switch (priv->cea_mode) {
	case 2:				/* 480P */
	case 4: // (a83t)
	case 6:				/* 1440x480I */
	case 17:			/* 576P */
	case 19: // (a83t)
	case 21:			/* 1440x576I */
		csc = 1;		/* BT601 */
		break;
	default:
		csc = 2;		/* BT709 */
		break;
	}

	if (priv->soc_type == SOC_H3) {
		if (hdmi_phy_set_h3(priv, i) != 0)
			return -1;
		bsp_hdmi_inner_init(priv);
	} else {
		bsp_hdmi_init(priv);
	}

	hdmi_writeb(priv, 0x0840, 0x01);		// 1200 HDMI_FC_DBGFORCE
	hdmi_writeb(priv, 0x4845, 0x00);		// 1219 HDMI_FC_DBGTMDS0
	hdmi_writeb(priv, 0x0040, ptbl[i].para[3] | 0x10); // 1000 HDMI_FC_INVIDCONF
	hdmi_writeb(priv, 0x10001, ptbl[i].para[3] < 96 ? 0x03 : 0x00);
	hdmi_writeb(priv, 0x8040, ptbl[i].para[4]);	// 1200 HDMI_FC_DBGFORCE
	hdmi_writeb(priv, 0x4043, ptbl[i].para[5]);	// 100d HDMI_FC_VSYNCINWIDTH
	hdmi_writeb(priv, 0x8042, ptbl[i].para[6]);	// 1006 HDMI_FC_INVACTV1
	hdmi_writeb(priv, 0x0042, ptbl[i].para[7]);	// 1004 HDMI_FC_INHBLANK1
	hdmi_writeb(priv, 0x4042, ptbl[i].para[8]);	// 100c HDMI_FC_VSYNCINDELAY
	hdmi_writeb(priv, 0x4041, ptbl[i].para[9]);	// 1009 HDMI_FC_HSYNCINDELAY1
	hdmi_writeb(priv, 0xc041, ptbl[i].para[10]);	// 100b HDMI_FC_HSYNCINWIDTH1
	hdmi_writeb(priv, 0x0041, ptbl[i].para[11]);	// 1001 HDMI_FC_INHACTV0
	hdmi_writeb(priv, 0x8041, ptbl[i].para[12]);	// 1003 HDMI_FC_INHBLANK0
	hdmi_writeb(priv, 0x4040, ptbl[i].para[13]);	// 1008 HDMI_FC_HSYNCINDELAY0
	hdmi_writeb(priv, 0xc040, ptbl[i].para[14]);	// 100a HDMI_FC_HSYNCINWIDTH1
	hdmi_writeb(priv, 0x0043, ptbl[i].para[15]);	// 1005 HDMI_FC_INVACTV0
	hdmi_writeb(priv, 0x8043, ptbl[i].para[16]);	// 1007 HDMI_FC_INVBLANK
	hdmi_writeb(priv, 0x0045, 0x0c);		// 1011 HDMI_FC_CTRLDUR
	hdmi_writeb(priv, 0x8044, 0x20);		// 1012 HDMI_FC_EXCTRLDUR
	hdmi_writeb(priv, 0x8045, 0x01);		// 1013 HDMI_FC_EXCTRLSPAC
	hdmi_writeb(priv, 0x0046, 0x0b);		// 1014 HDMI_FC_CH0PREAM
	hdmi_writeb(priv, 0x0047, 0x16);		// 1015 HDMI_FC_CH1PREAM
	hdmi_writeb(priv, 0x8046, 0x21);		// 1016 HDMI_FC_CH2PREAM
	hdmi_writeb(priv, 0x3048, ptbl[i].para[2] ? 0x21 : 0x10); // 10e0 HDMI_FC_PRCONF
	hdmi_writeb(priv, 0x0401, ptbl[i].para[2] ? 0x41 : 0x40); // 0801 HDMI_VP_PR_CD
	hdmi_writeb(priv, 0x8400, 0x07);		// 0802 HDMI_VP_STUFF
	hdmi_writeb(priv, 0x8401, 0x00);		// 0803 HDMI_VP_REMAP
	hdmi_writeb(priv, 0x0402, 0x47);		// 0804 HDMI_VP_CONF
	hdmi_writeb(priv, 0x0800, 0x01);		// 0200 HDMI_TX_INVID0
	hdmi_writeb(priv, 0x0801, 0x07);		// 0201 HDMI_TX_INSTUFFING
	hdmi_writeb(priv, 0x8800, 0x00);		// 0202 HDMI_TX_GYDATA0
	hdmi_writeb(priv, 0x8801, 0x00);		// 0203 HDMI_TX_GYDATA1
	hdmi_writeb(priv, 0x0802, 0x00);		// 0204 HDMI_TX_RCRDATA0
	hdmi_writeb(priv, 0x0803, 0x00);		// 0205 HDMI_TX_RCRDATA1
	hdmi_writeb(priv, 0x8802, 0x00);		// 0206 HDMI_TX_BCBDATA0
	hdmi_writeb(priv, 0x8803, 0x00);		// 0207 HDMI_TX_BCBDATA1

	if (priv->is_hdmi_sink) {
		hdmi_writeb(priv, 0xb045, 0x08);	// 10b3 HDMI_FC_DATAUTO0
		hdmi_writeb(priv, 0x2045, 0x00);	// 1031 HDMI_FC_VSDIEEEID2
		hdmi_writeb(priv, 0x2044, 0x0c);	// 1030 HDMI_FC_VSDIEEEID1
		hdmi_writeb(priv, 0x6041, 0x03);	// 1029 HDMI_FC_VSDIEEEID0
		hdmi_writeb(priv, 0xa044, (ptbl[i].para[0] & 0x100) ?	// 1032 HDMI_FC_VSDPAYLOAD0
					0x20 : (ptbl[i].para[0] & 0x80) ?
					0x40 :
					0x00 );
		hdmi_writeb(priv, 0xa045, (ptbl[i].para[0] & 0x100) ?	// 1033 HDMI_FC_VSDPAYLOAD1
					(ptbl[i].para[0] & 0x7f) : 0x00);
		hdmi_writeb(priv, 0x2046, 0x00);	// 1034 HDMI_FC_VSDPAYLOAD2
		hdmi_writeb(priv, 0x3046, 0x01);	// 10b4 HDMI_FC_DATAUTO1
		hdmi_writeb(priv, 0x3047, 0x11);	// 10b5 HDMI_FC_DATAUTO2
		hdmi_writeb(priv, 0x4044, 0x00);	// 1018 HDMI_FC_GCP
		hdmi_writeb(priv, 0x0052, 0x00);	// 1104 HDMI_FC_GMD_HB
		hdmi_writeb(priv, 0x8051, 0x11);	// 1103 HDMI_FC_GMD_CONF

		hdmi_read_lock(priv);
		hdmi_writeb(priv, 0x0040, hdmi_readb(priv, 0x0040) | 0x08); // 1000 HDMI_FC_INVIDCONF
		hdmi_read_unlock(priv);

		/* AVI */
		hdmi_writeb(priv, 0x4045, priv->is_yuv ? 0x02 : 0x00);	// 1019 HDMI_FC_AVICONF0
		if (ptbl[i].para[17] == 0)
			hdmi_writeb(priv, 0xc044, (csc << 6) | 0x18);	// 101a HDMI_FC_AVICONF1
		else if (ptbl[i].para[17] == 1)
			hdmi_writeb(priv, 0xc044, (csc << 6) | 0x28);
		else
			hdmi_writeb(priv, 0xc044, (csc << 6) | 0x08);

		if (priv->soc_type == SOC_H3)
			hdmi_writeb(priv, 0xc045, priv->is_yuv ? 0x00 : 0x08);	// 101b HDMI_FC_AVICONF2
		else
			hdmi_writeb(priv, 0xc045, 0x00);		// 101b HDMI_FC_AVICONF2
		hdmi_writeb(priv, 0x4046, ptbl[i].para[0] & 0x7f);	// 101c HDMI_FC_AVIVID
	}

	hdmi_writeb(priv, 0x0082, 0x00);		// 4004 HDMI_MC_FLOWCTRL
	hdmi_writeb(priv, 0x0081, 0x00);		// 4001 HDMI_MC_CLKDIS
							//	enable all clocks

	if (priv->soc_type != SOC_H3) {
		if (hdmi_phy_set_a83t(priv, i) != 0)
			return -1;
	}

	hdmi_writeb(priv, 0x0840, 0x00);		// 1200 HDMI_FC_DBGFORCE

	return 0;
}

/* get a block of EDID */
int bsp_hdmi_ddc_read(struct de2_hdmi_priv *priv,
			char cmd, char pointer, char off,
			int nbyte, char *pbuf)
{
	unsigned to_cnt;
	u8 reg;
	int ret = 0;
	
	if (priv->soc_type == SOC_H3) {
		hdmi_read_lock(priv);
		hdmi_writeb(priv, 0x4ee1, 0x00);	// 7e09 HDMI_I2CM_SOFTRSTZ
		to_cnt = 50;
		while ((hdmi_readb(priv, 0x4ee1) & 0x01) != 0x01) {
			udelay(10);
			if (--to_cnt == 0) {	/* wait for 500us for timeout */
				pr_warn("hdmi ddc reset timeout\n");
				break;
			}
		}

//fixme: strange values / IMx.6 doc
// (0x08 - fast - for 7e07 and 0x05 for 7e05 would be more logical)
		hdmi_writeb(priv, 0x8ee3, 0x05);	// 7e07 HDMI_I2CM_DIV
								// ?? nothing known
		hdmi_writeb(priv, 0x0ee3, 0x08);	// 7e05 HDMI_I2CM_INT
		hdmi_writeb(priv, 0x4ee2, 0xd8);	// 7e0c HDMI_I2CM_SS_SCL_HCNT_0_ADDR
		hdmi_writeb(priv, 0xcee2, 0xfe);	// 7e0e HDMI_I2CM_SS_SCL_LCNT_0_ADDR
	} else {
		hdmi_writeb(priv, 0x8ee3, 0x05);	// 7e07 HDMI_I2CM_DIV
		hdmi_writeb(priv, 0x0ee3, 0x08);	// 7e05 HDMI_I2CM_INT
	}

	while (nbyte > 0) {
		hdmi_writeb(priv, 0x0ee0, 0xa0 >> 1);	/* 7e00 HDMI_I2CM_SLAVE */
		hdmi_writeb(priv, 0x0ee1, off);		/* 7e01 HDMI_I2CM_ADDRESS */
		hdmi_writeb(priv, 0x4ee0, 0x60 >> 1);	/* 7e08 HDMI_I2CM_SEGADDR */
		hdmi_writeb(priv, 0xcee0, pointer);	/* 7e0a HDMI_I2CM_SEGPTR */
		hdmi_writeb(priv, 0x0ee2, 0x02);	/* 7e04 HDMI_I2CM_OPERATION */
								/* rd_ext = DDC read */
		if (priv->soc_type != SOC_H3)
			hdmi_read_lock(priv);

		to_cnt = 200;				/* timeout 100ms */
		while (1) {
			reg = hdmi_readb(priv, 0x0013);	// 0105 HDMI_IH_I2CM_STAT0
// from IMX6DQRM.pdf 33.5.14, the bits are cleared on read/write => useless
//			hdmi_writeb(priv, 0x0013, reg & 0x03);
//			hdmi_writeb(priv, 0x0013, 0x03);
			if (reg & 0x02) {
				*pbuf++ = hdmi_readb(priv, 0x8ee1); // 7e03 HDMI_I2CM_DATAI
				hdmi_writeb(priv, 0x0013, 0x02);
				break;
			}
			if (reg & 0x01) {
				hdmi_writeb(priv, 0x0013, 0x01);
				pr_warn("hdmi ddc read error, byte cnt = %d\n",
					 nbyte);
				ret = -1;
				break;
			}
			if (--to_cnt == 0) {
				if (!ret) {
					pr_warn("hdmi ddc read timeout, byte cnt = %d\n",
						 nbyte);
					ret = -1;
				}
				break;
			}
			usleep_range(800, 1000);
		}
		if (ret)
			break;
		nbyte--;
		off++;
	}
	hdmi_read_unlock(priv);

	return ret;
}

int bsp_hdmi_get_hpd(struct de2_hdmi_priv *priv)
{
	int ret;

	hdmi_read_lock(priv);

	if (priv->soc_type == SOC_H3)
		ret = hdmi_readl(priv, 0x10038) & 0x80000;
	else
		ret = hdmi_readb(priv, 0x0243) & 0x02;	// 3005 HDMI_PHY_INT0

	hdmi_read_unlock(priv);
//test
pr_info("hdmi hpd: %d\n", ret != 0);

	return ret != 0;
}

void bsp_hdmi_hrst(struct de2_hdmi_priv *priv)
{
	hdmi_writeb(priv, 0x00c1, 0x04);		// 5001 HDMI_A_HDCPCFG1
}

int bsp_hdmi_mode_valid(int cea_mode)
{
	return get_vid(cea_mode);
}
h3-hdmi/de2_hdmi_h3.h0000644000175000017500000000112712662054103012617 0ustar  jefjef#ifndef __DE2_HDMI_H3_H__
#define __DE2_HDMI_H3_H__

void bsp_hdmi_set_video_en(struct de2_hdmi_priv *priv,
			unsigned char enable);
int bsp_hdmi_audio(struct de2_hdmi_priv *priv,
		int sample_rate, int sample_bit);
int bsp_hdmi_video(struct de2_hdmi_priv *priv);
int bsp_hdmi_ddc_read(struct de2_hdmi_priv *priv,
			char cmd, char pointer, char offset,
			int nbyte, char *pbuf);
int bsp_hdmi_get_hpd(struct de2_hdmi_priv *priv);
void bsp_hdmi_init(struct de2_hdmi_priv *priv);
void bsp_hdmi_hrst(struct de2_hdmi_priv *priv);
int bsp_hdmi_mode_valid(int cea_mode);

#endif /* __DE2_HDMI_H3_H__ */
h3-hdmi/de2_snd_codec.c0000644000175000017500000000536512667053353013243 0ustar  jefjef/*
 * Allwinner DRM driver - DE2 HDMI codec
 *
 * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 */

#include <linux/module.h>
#include <sound/soc.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <sound/pcm_drm_eld.h>
#include <sound/pcm_params.h>

#include "de2_hdmi.h"

#define DE2_HDMI_FORMATS (SNDRV_PCM_FMTBIT_S8 | \
			  SNDRV_PCM_FMTBIT_S16_LE | \
			  SNDRV_PCM_FMTBIT_S20_3LE | \
			  SNDRV_PCM_FMTBIT_S24_LE | \
			  SNDRV_PCM_FMTBIT_S32_LE)

static int de2_hdmi_codec_startup(struct snd_pcm_substream *substream,
				  struct snd_soc_dai *dai)
{
	struct snd_pcm_runtime *runtime = substream->runtime;
	struct de2_hdmi_priv *priv = dev_get_drvdata(dai->dev);
	u8 *eld;

	eld = priv->eld;
	if (!eld)
		return -ENODEV;

	return snd_pcm_hw_constraint_eld(runtime, eld);
}

static int de2_hdmi_hw_params(struct snd_pcm_substream *substream,
			      struct snd_pcm_hw_params *params,
			      struct snd_soc_dai *dai)
{
	struct de2_hdmi_priv *priv = dev_get_drvdata(dai->dev);
	unsigned sample_bit;

//test
//pr_info("codec hw_params\n");
	if (params_format(params) == SNDRV_PCM_FORMAT_S16_LE)
		sample_bit = 16;
	else
		sample_bit = 24;
//fixme params_channels(params) may change 'ca'
	return priv->set_audio_input(dai->dev, true,
					params_rate(params),
					sample_bit);
}

static void de2_hdmi_codec_shutdown(struct snd_pcm_substream *substream,
				    struct snd_soc_dai *dai)
{
	struct de2_hdmi_priv *priv = dev_get_drvdata(dai->dev);

	priv->set_audio_input(dai->dev, false, 0, 0);
}

static const struct snd_soc_dai_ops de2_hdmi_codec_ops = {
	.startup = de2_hdmi_codec_startup,
	.hw_params = de2_hdmi_hw_params,
	.shutdown = de2_hdmi_codec_shutdown,
};

static struct snd_soc_dai_driver de2_hdmi_codec = {
	.name = "hdmi-codec",
	.playback = {
		.stream_name	= "HDMI Playback",
		.channels_min	= 1,
		.channels_max	= 8,
		.rates		= SNDRV_PCM_RATE_CONTINUOUS,
		.rate_min	= 8000,
		.rate_max	= 192000,
		.formats	= DE2_HDMI_FORMATS,
	},
	.ops = &de2_hdmi_codec_ops,
};

static const struct snd_soc_codec_driver de2_hdmi_codec_drv = {
	.ignore_pmdown_time = true,
};

int de2_hdmi_codec_register(struct device *dev)
{
	return snd_soc_register_codec(dev, &de2_hdmi_codec_drv,
					&de2_hdmi_codec, 1);
}
EXPORT_SYMBOL_GPL(de2_hdmi_codec_register);

void de2_hdmi_codec_unregister(struct device *dev)
{
	snd_soc_unregister_codec(dev);
}
EXPORT_SYMBOL_GPL(de2_hdmi_codec_unregister);

MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
MODULE_DESCRIPTION("Allwinner DE2 HDMI CODEC");
MODULE_LICENSE("GPL");
h3-hdmi/de2_snd_i2s2.c0000644000175000017500000004644212734501667012747 0ustar  jefjef/*
 * de2_snd_i2s2.c
 *
 * Copyright (C) 2016 Jean-Francois Moine <moinejf@free.fr>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 */

#include <linux/init.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/clk.h>
#include <linux/reset.h>
#include <sound/pcm_params.h>
#include <sound/dmaengine_pcm.h>
#include <linux/of.h>

/* --- hardware --- */
#define SUNXI_DAUDIOCTL 	  	0x00
	#define SUNXI_DAUDIOCTL_BCLKOUT		BIT(18)
	#define SUNXI_DAUDIOCTL_LRCKOUT		BIT(17)
	#define SUNXI_DAUDIOCTL_LRCKROUT	BIT(16)
	#define SUNXI_DAUDIOCTL_SDO3EN		BIT(11)
	#define SUNXI_DAUDIOCTL_SDO2EN		BIT(10)
	#define SUNXI_DAUDIOCTL_SDO1EN		BIT(9)
	#define SUNXI_DAUDIOCTL_SDO0EN		BIT(8) 
	#define SUNXI_DAUDIOCTL_OUTMUTE		BIT(6)
	#define SUNXI_DAUDIOCTL_MODESEL		(3 << 4)
#define SUNXI_DAUDIOCTL_MODE_DSP_A		(0 << 4)
#define SUNXI_DAUDIOCTL_MODE_DSP_B		(0 << 4)
#define SUNXI_DAUDIOCTL_MODE_I2S		(1 << 4)
#define SUNXI_DAUDIOCTL_MODE_LEFT_J		(1 << 4)
#define SUNXI_DAUDIOCTL_MODE_RIGHT_J		(2 << 4)
	#define SUNXI_DAUDIOCTL_LOOP		BIT(3)
	#define SUNXI_DAUDIOCTL_TXEN		BIT(2)
	#define SUNXI_DAUDIOCTL_RXEN		BIT(1)
	#define SUNXI_DAUDIOCTL_GEN		BIT(0)

#define SUNXI_DAUDIOFAT0 		0x04
	#define SUNXI_DAUDIOFAT0_SDI_SYNC_SEL	BIT(31)
	#define SUNXI_DAUDIOFAT0_LRCK_WIDTH	BIT(30)
	#define SUNXI_DAUDIOFAT0_LRCKR_PERIOD(v) ((v) << 20)
	#define SUNXI_DAUDIOFAT0_LRCKR_PERIOD_MSK (0x3ff << 20)
	#define SUNXI_DAUDIOFAT0_LRCK_POLARITY	BIT(19)
	#define SUNXI_DAUDIOFAT0_LRCK_PERIOD(v)	((v) << 8)
	#define SUNXI_DAUDIOFAT0_LRCK_PERIOD_MSK (0x3ff << 8)
	#define SUNXI_DAUDIOFAT0_BCLK_POLARITY	BIT(7)
	#define SUNXI_DAUDIOFAT0_SR_16		(3 << 4)
	#define SUNXI_DAUDIOFAT0_SR_20		(4 << 4)
	#define SUNXI_DAUDIOFAT0_SR_24		(5 << 4)
	#define SUNXI_DAUDIOFAT0_SR_MSK		(7 << 4)
	#define SUNXI_DAUDIOFAT0_EDGE_TRANSFER	BIT(3)
	#define SUNXI_DAUDIOFAT0_SW_16		(3 << 0)
	#define SUNXI_DAUDIOFAT0_SW_20		(4 << 0)
	#define SUNXI_DAUDIOFAT0_SW_24		(5 << 0)
	#define SUNXI_DAUDIOFAT0_SW_32		(7 << 0)
	#define SUNXI_DAUDIOFAT0_SW_MSK		(7 << 0)

#define SUNXI_DAUDIOFAT1		0x08
	#define SUNXI_DAUDIOFAT1_RX_MLS		BIT(7)
	#define SUNXI_DAUDIOFAT1_TX_MLS		BIT(6)
	#define SUNXI_DAUDIOFAT1_SEXT		(3 << 4)
	#define SUNXI_DAUDIOFAT1_RX_PDM		(3 << 2)
	#define SUNXI_DAUDIOFAT1_TX_PDM		(3 << 0)

#define SUNXI_DAUDIOISTA 		0x0c
	#define SUNXI_DAUDIOSTA_TXU_INT		BIT(6)
	#define SUNXI_DAUDIOSTA_TXO_INT		BIT(5)
	#define SUNXI_DAUDIOSTA_TXE_INT		BIT(4)
	#define SUNXI_DAUDIOSTA_RXU_INT		BIT(2)
	#define SUNXI_DAUDIOSTA_RXO_INT		BIT(1)
	#define SUNXI_DAUDIOSTA_RXA_INT		BIT(0)

#define SUNXI_DAUDIORXFIFO		0x10

#define SUNXI_DAUDIOFCTL		0x14
	#define SUNXI_DAUDIOFCTL_HUBEN		BIT(31)
	#define SUNXI_DAUDIOFCTL_FTX		BIT(25)
	#define SUNXI_DAUDIOFCTL_FRX		BIT(24)
	#define SUNXI_DAUDIOFCTL_TXTL(v)	((v) << 12)
	#define SUNXI_DAUDIOFCTL_RXTL(v)	((v) << 4)
	#define SUNXI_DAUDIOFCTL_TXIM		BIT(2)
	#define SUNXI_DAUDIOFCTL_RXOM		BIT(0)

#define SUNXI_DAUDIOFSTA   		0x18
	#define SUNXI_DAUDIOFSTA_TXE		BIT(28)
	#define SUNXI_DAUDIOFSTA_TXECNT(v)	((v) << 16)
	#define SUNXI_DAUDIOFSTA_RXA		BIT(8)
	#define SUNXI_DAUDIOFSTA_RXACNT(v)	((v) << 0)
	
#define SUNXI_DAUDIOINT    		0x1c
	#define SUNXI_DAUDIOINT_TXDRQEN		BIT(7)
	#define SUNXI_DAUDIOINT_TXUIEN		BIT(6)
	#define SUNXI_DAUDIOINT_TXOIEN		BIT(5)
	#define SUNXI_DAUDIOINT_TXEIEN		BIT(4)
	#define SUNXI_DAUDIOINT_RXDRQEN		BIT(3)
	#define SUNXI_DAUDIOINT_RXUIEN		BIT(2)
	#define SUNXI_DAUDIOINT_RXOIEN		BIT(1)
	#define SUNXI_DAUDIOINT_RXAIEN		BIT(0)

#define SUNXI_DAUDIOTXFIFO		0x20
	
#define SUNXI_DAUDIOCLKD   		0x24
	#define SUNXI_DAUDIOCLKD_MCLKOEN	BIT(8)
	#define SUNXI_DAUDIOCLKD_BCLKDIV(v)	((v) << 4)
	#define SUNXI_DAUDIOCLKD_MCLKDIV(v)	((v) << 0)

#define SUNXI_DAUDIOTXCNT  		0x28

#define SUNXI_DAUDIORXCNT  		0x2c

#define SUNXI_TXCHCFG			0x30
	#define SUNXI_TXCHCFG_TX_SLOT_HIZ	BIT(9)
	#define SUNXI_TXCHCFG_TX_STATE		BIT(8)
	#define SUNXI_TXCHCFG_RX_SLOT_NUM	(7 << 4)
	#define SUNXI_TXCHCFG_TX_SLOT_NUM_MSK	(7 << 0)
	#define SUNXI_TXCHCFG_TX_SLOT_NUM(v)	((v) << 0)

#define SUNXI_DAUDIOTX0CHSEL		0x34
#define SUNXI_DAUDIOTX1CHSEL		0x38
#define SUNXI_DAUDIOTX2CHSEL		0x3c
#define SUNXI_DAUDIOTX3CHSEL		0x40
	#define SUNXI_DAUDIOTXn_OFFSET_MSK	(3 << 12)
	#define SUNXI_DAUDIOTXn_OFFSET(v)	((v) << 12)
	#define SUNXI_DAUDIOTXn_CHEN_MSK	(0xff << 4)
	#define SUNXI_DAUDIOTXn_CHEN(v)		((v) << 4)
	#define SUNXI_DAUDIOTXn_CHSEL_MSK	(7 << 0)
	#define SUNXI_DAUDIOTXn_CHSEL(v)	((v) << 0)

#define SUNXI_DAUDIOTX0CHMAP		0x44
#define SUNXI_DAUDIOTX1CHMAP		0x48
#define SUNXI_DAUDIOTX2CHMAP		0x4c
#define SUNXI_DAUDIOTX3CHMAP		0x50
	#define SUNXI_DAUDIOTXn_CH7_MAP		(7 << 28)
	#define SUNXI_DAUDIOTXn_CH6_MAP		(7 << 24)
	#define SUNXI_DAUDIOTXn_CH5_MAP		(7 << 20)
	#define SUNXI_DAUDIOTXn_CH4_MAP		(7 << 16)
	#define SUNXI_DAUDIOTXn_CH3_MAP		(7 << 12)
	#define SUNXI_DAUDIOTXn_CH2_MAP		(7 << 8)
	#define SUNXI_DAUDIOTXn_CH1_MAP		(7 << 4)
	#define SUNXI_DAUDIOTXn_CH0_MAP		(7 << 0)
#define SUNXI_DAUDIORXCHSEL		0x54
	#define SUNXI_DAUDIORXCHSEL_RXOFFSET	(3 << 12)
	#define SUNXI_DAUDIORXCHSEL_RXCHSET	(7 << 0)

#define SUNXI_DAUDIORXCHMAP		0x58
	#define SUNXI_DAUDIORXCHMAP_CH7		(7 << 28)
	#define SUNXI_DAUDIORXCHMAP_CH6		(7 << 24)
	#define SUNXI_DAUDIORXCHMAP_CH5		(7 << 20)
	#define SUNXI_DAUDIORXCHMAP_CH4		(7 << 16)
	#define SUNXI_DAUDIORXCHMAP_CH3		(7 << 12)
	#define SUNXI_DAUDIORXCHMAP_CH2		(7 << 8)
	#define SUNXI_DAUDIORXCHMAP_CH1		(7 << 4)
	#define SUNXI_DAUDIORXCHMAP_CH0		(7 << 0)

#define SUNXI_DAUDIODBG			0x5c

#define SUNXI_DAUDIO_DIV_MCLK	0
#define SUNXI_DAUDIO_DIV_BCLK	1

/* --- driver --- */

#define DRV_NAME "de2-hdmi-audio"

#define I2S2_FORMATS \
	(SNDRV_PCM_FMTBIT_S16_LE | \
	 SNDRV_PCM_FMTBIT_S20_3LE | \
	 SNDRV_PCM_FMTBIT_S24_LE | \
	 SNDRV_PCM_FMTBIT_S32_LE)

#define PCM_LRCK_PERIOD 32
#define PCM_LRCKR_PERIOD 1

struct priv {
	void __iomem *mmio;
	struct clk *clk;
	struct clk *clk_i2s2;
#if 0
	struct clk *gate;
	struct reset_control *rstc;
#endif
	struct snd_dmaengine_dai_dma_data dma_data;
};

/* --- CPU DAI --- */

static void de2_i2s2_init(struct priv *priv)
{
	u32 reg;

	/* disable global */
	reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
	reg &= ~(SUNXI_DAUDIOCTL_GEN |
		 SUNXI_DAUDIOCTL_RXEN |
		 SUNXI_DAUDIOCTL_TXEN);
	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);

	/* clear the FIFOs */
	reg = readl(priv->mmio + SUNXI_DAUDIOFCTL);
	reg &= ~(SUNXI_DAUDIOFCTL_FRX |
		 SUNXI_DAUDIOFCTL_FTX);
	writel(reg, priv->mmio + SUNXI_DAUDIOFCTL);

	/* clear the FIFO counters */
	writel(0, priv->mmio + SUNXI_DAUDIOTXCNT);
	writel(0, priv->mmio + SUNXI_DAUDIORXCNT);

	/* codec clk & FRM slave */
	reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
	reg |= SUNXI_DAUDIOCTL_LRCKOUT | SUNXI_DAUDIOCTL_BCLKOUT;
//	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);

	/* I2S mode */
//	reg = readl(priv->mmio + SUNXI_DAUDIOCTL) &
	reg &=
				~SUNXI_DAUDIOCTL_MODESEL;
	reg |= SUNXI_DAUDIOCTL_MODE_I2S;
	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);

	reg = readl(priv->mmio + SUNXI_DAUDIOTX0CHSEL) &
				~SUNXI_DAUDIOTXn_OFFSET_MSK;
	reg |= SUNXI_DAUDIOTXn_OFFSET(1);
	writel(reg, priv->mmio + SUNXI_DAUDIOTX0CHSEL);

	/* normal bit clock + frame */
	reg = readl(priv->mmio + SUNXI_DAUDIOFAT0);
	reg &= ~(SUNXI_DAUDIOFAT0_BCLK_POLARITY |
		 SUNXI_DAUDIOFAT0_LRCK_POLARITY);
	writel(reg, priv->mmio + SUNXI_DAUDIOFAT0);
}

static int de2_i2s2_set_clock(struct priv *priv,
				unsigned long rate)
{
	unsigned long freq;
	int ret, i, div;
	u32 reg;
	static const u8 div_tb[] = {
		1, 2, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 176, 192
	};

	/* compute the sys clock rate and divide value */
	switch (rate) {
	case 192000:
	case 96000:
	case 48000:
	case 32000:
		freq = 24576000;
		break;
	default:
		freq = 22579200;
		break;
	}
	div = freq / 2 / PCM_LRCK_PERIOD / rate;
	for (i = 0; i < ARRAY_SIZE(div_tb) - 1; i++)
		if (div_tb[i] >= div)
			break;
	div = i + 1;

	ret = clk_set_rate(priv->clk, freq);
	if (ret) {
		pr_info("Setting sysclk rate failed %d\n", ret);
		return ret;
	}

	/* enable mclk output */
	reg = SUNXI_DAUDIOCLKD_MCLKOEN | SUNXI_DAUDIOCLKD_MCLKDIV(1);

	/* clock divide */
	reg |= SUNXI_DAUDIOCLKD_BCLKDIV(div);
	writel(reg, priv->mmio + SUNXI_DAUDIOCLKD);

	/* format */
	reg = readl(priv->mmio + SUNXI_DAUDIOFAT0);
	reg &= ~(SUNXI_DAUDIOFAT0_LRCKR_PERIOD_MSK |
		 SUNXI_DAUDIOFAT0_LRCK_PERIOD_MSK);
	reg |= SUNXI_DAUDIOFAT0_LRCK_PERIOD(PCM_LRCK_PERIOD - 1) |
		SUNXI_DAUDIOFAT0_LRCKR_PERIOD(PCM_LRCKR_PERIOD - 1);

	/* slot size select */
	reg &= ~SUNXI_DAUDIOFAT0_SW_MSK;
	reg |= SUNXI_DAUDIOFAT0_SW_16;

	reg &= ~SUNXI_DAUDIOFAT0_SR_MSK;
	reg |= SUNXI_DAUDIOFAT0_SR_16;
	writel(reg, priv->mmio + SUNXI_DAUDIOFAT0);

	writel(0, priv->mmio + SUNXI_DAUDIOFAT1);

	return 0;
}

static int de2_i2s2_prepare(struct snd_pcm_substream *substream,
			     struct snd_soc_dai *dai)
{
	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
	struct priv *priv = snd_soc_card_get_drvdata(card);
	int nchan = substream->runtime->channels;
	u32 reg;

	reg = readl(priv->mmio + SUNXI_TXCHCFG) &
				~SUNXI_TXCHCFG_TX_SLOT_NUM_MSK;
	if (nchan != 1)
		reg |= SUNXI_TXCHCFG_TX_SLOT_NUM(1);
	writel(reg, priv->mmio + SUNXI_TXCHCFG);

	reg = readl(priv->mmio + SUNXI_DAUDIOTX0CHSEL);
//fixme: set in de2_i2s2_set_fmt
//	reg |= SUNXI_DAUDIOTXn_OFFSET(1);
	reg &= ~(SUNXI_DAUDIOTXn_CHEN_MSK |
		 SUNXI_DAUDIOTXn_CHSEL_MSK);
	reg |= SUNXI_DAUDIOTXn_CHEN(3) |
		SUNXI_DAUDIOTXn_CHSEL(1);
	writel(reg, priv->mmio + SUNXI_DAUDIOTX0CHSEL);

	reg = nchan == 1 ? 0 : 0x10;
	writel(reg, priv->mmio + SUNXI_DAUDIOTX0CHMAP);

	reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
	reg &= ~(SUNXI_DAUDIOCTL_SDO3EN |
		 SUNXI_DAUDIOCTL_SDO2EN |
		 SUNXI_DAUDIOCTL_SDO1EN);
	if (nchan >= 7)
		reg |= SUNXI_DAUDIOCTL_SDO3EN;
	if (nchan >= 5)
		reg |= SUNXI_DAUDIOCTL_SDO2EN;
	if (nchan >= 3)
		reg |= SUNXI_DAUDIOCTL_SDO1EN;
	reg |= SUNXI_DAUDIOCTL_SDO0EN;
	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);

	writel(0, priv->mmio + SUNXI_DAUDIOTXCNT);

	return 0;
}

static void de2_i2s2_shutdown(struct snd_pcm_substream *substream,
			      struct snd_soc_dai *dai)
{
	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
	struct priv *priv = snd_soc_card_get_drvdata(card);
	u32 reg;

	reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
	reg &= ~SUNXI_DAUDIOCTL_GEN;
	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);
}

static int de2_i2s2_hw_params(struct snd_pcm_substream *substream,
				struct snd_pcm_hw_params *params,
				struct snd_soc_dai *dai)
{
	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
	struct priv *priv = snd_soc_card_get_drvdata(card);
	u32 reg, reg2;
	int sample_resolution;
	int ret;

//test:trace
pr_info("de2 i2s2 fmt %d rate %d\n",
 params_format(params) == SNDRV_PCM_FORMAT_S16_LE ? 16 : 24,
 params_rate(params));

	ret = de2_i2s2_set_clock(priv, params_rate(params));
	if (ret)
		return ret;

	switch (params_format(params)) {
	case SNDRV_PCM_FORMAT_S16_LE:
		priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
		sample_resolution = 16;
		break;
	case SNDRV_PCM_FORMAT_S20_3LE:
	case SNDRV_PCM_FORMAT_S24_LE:
	case SNDRV_PCM_FORMAT_S32_LE:
		priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
		sample_resolution = 24;
		break;
	default:
		return -EINVAL;
	}
	reg = readl(priv->mmio + SUNXI_DAUDIOFAT0);
	reg2 = readl(priv->mmio + SUNXI_DAUDIOFCTL);
	reg &= ~(SUNXI_DAUDIOFAT0_SR_MSK | SUNXI_DAUDIOFAT0_SW_MSK);
	if (sample_resolution == 16) {
		reg |= SUNXI_DAUDIOFAT0_SR_16 |
			SUNXI_DAUDIOFAT0_SW_16;
		reg2 |= SUNXI_DAUDIOFCTL_TXIM;
	} else {
		reg |= SUNXI_DAUDIOFAT0_SR_24 |
			SUNXI_DAUDIOFAT0_SW_32;
		reg2 &= ~SUNXI_DAUDIOFCTL_TXIM;
	}
	writel(reg, priv->mmio + SUNXI_DAUDIOFAT0);
	writel(reg2, priv->mmio + SUNXI_DAUDIOFCTL);

	/* enable audio interface */
	reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
	reg |= SUNXI_DAUDIOCTL_GEN;
	writel(reg, priv->mmio + SUNXI_DAUDIOCTL);
	msleep(10);

	/* flush TX FIFO */
	reg = readl(priv->mmio + SUNXI_DAUDIOFCTL);
	reg |= SUNXI_DAUDIOFCTL_FTX;
	writel(reg, priv->mmio + SUNXI_DAUDIOFCTL);

	return 0;
}

static int de2_i2s2_trigger(struct snd_pcm_substream *substream,
				int cmd, struct snd_soc_dai *dai)
{
	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
	struct priv *priv = snd_soc_card_get_drvdata(card);
	u32 reg;

	switch (cmd) {
	case SNDRV_PCM_TRIGGER_START:
	case SNDRV_PCM_TRIGGER_RESUME:
	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
		reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
		reg |= SUNXI_DAUDIOCTL_TXEN;
		writel(reg, priv->mmio + SUNXI_DAUDIOCTL);

		/* enable DMA DRQ mode */
		reg = readl(priv->mmio + SUNXI_DAUDIOINT);
		reg |= SUNXI_DAUDIOINT_TXDRQEN;
		writel(reg, priv->mmio + SUNXI_DAUDIOINT);
		break;
	case SNDRV_PCM_TRIGGER_STOP:
	case SNDRV_PCM_TRIGGER_SUSPEND:
	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
		reg = readl(priv->mmio + SUNXI_DAUDIOINT);
		reg &= ~SUNXI_DAUDIOINT_TXDRQEN;
		writel(reg, priv->mmio + SUNXI_DAUDIOINT);

//fixme: test: not in Allwinner's
		reg = readl(priv->mmio + SUNXI_DAUDIOCTL);
		reg &= ~SUNXI_DAUDIOCTL_TXEN;
		writel(reg, priv->mmio + SUNXI_DAUDIOCTL);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static const struct snd_soc_dai_ops de2_i2s2_dai_ops = {
	.hw_params = de2_i2s2_hw_params,
	.prepare = de2_i2s2_prepare,
	.trigger = de2_i2s2_trigger,
	.shutdown = de2_i2s2_shutdown,
};

static int de2_i2s2_dai_probe(struct snd_soc_dai *dai)
{
	struct snd_soc_card *card = snd_soc_dai_get_drvdata(dai);
	struct priv *priv = snd_soc_card_get_drvdata(card);

	snd_soc_dai_init_dma_data(dai, &priv->dma_data, NULL);

	return 0;
}

static struct snd_soc_dai_driver i2s2_dai = {
	.name = "i2s2",
	.probe = de2_i2s2_dai_probe,
	.playback = {
		.stream_name = "Playback",
		.channels_min = 1,
		.channels_max = 8,
		.rates = SNDRV_PCM_RATE_CONTINUOUS,
		.rate_min = 32000,
		.rate_max = 192000,
		.formats = I2S2_FORMATS,
	},
	.ops = &de2_i2s2_dai_ops,
};

static const struct snd_soc_component_driver i2s2_component = {
	.name = DRV_NAME,
};

/* --- dma --- */

static const struct snd_pcm_hardware de2_i2s2_pcm_hardware = {
	.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER |
		SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID |
		SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
	.formats = I2S2_FORMATS,
	.rates = SNDRV_PCM_RATE_CONTINUOUS,
	.rate_min = 32000,
	.rate_max = 192000,
	.channels_min = 1,
	.channels_max = 8,
	.buffer_bytes_max = 1024 * 1024,
	.period_bytes_min = 156,
	.period_bytes_max = 1024 * 1024,
	.periods_min = 1,
	.periods_max = 8,
	.fifo_size = 128,
};

static const struct snd_dmaengine_pcm_config de2_i2s2_config = {
	.prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config,
	.pcm_hardware = &de2_i2s2_pcm_hardware,
	.prealloc_buffer_size = 1024 * 1024,
};

/* --- card --- */

static struct snd_soc_card *de2_card_create(struct device *dev)
{
	struct snd_soc_card *card;
	struct snd_soc_dai_link *dai_link;
	struct snd_soc_dai_link_component *codec;

	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
	if (!card)
		return NULL;
	dai_link = devm_kzalloc(dev, sizeof(*dai_link), GFP_KERNEL);
	if (!dai_link)
		return NULL;
	codec = devm_kzalloc(dev, sizeof(*codec), GFP_KERNEL);
	if (!codec)
		return NULL;

	card->name = "hdmi-audio";
	card->dai_link = dai_link;
	card->num_links = 1;
	dai_link->name = "HDMI Audio";
	dai_link->stream_name = "HDMI Audio";
	dai_link->platform_name = dev_name(dev);
	dai_link->cpu_name = dev_name(dev);
	dai_link->codecs = codec;
	dai_link->num_codecs = 1;
//fixme: should use graph of ports
	codec->name = "1ee0000.hdmi";		/* H3 specific */
	codec->dai_name = "hdmi-codec";

	return card;
}

/* --- module init --- */

static int de2_i2s2_dev_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct priv *priv;
	struct snd_soc_card *card;
	struct resource *mem;
	int ret;

	if (!dev->of_node) {
		dev_err(dev, "no DT!\n");
		return -EINVAL;
	}

	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	/* get the resources */
	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	priv->mmio = devm_ioremap_resource(dev, mem);
	if (IS_ERR(priv->mmio))
		return PTR_ERR(priv->mmio);

	/* get and enable the clocks */
#if 0
	priv->gate = devm_clk_get(dev, "gate");	/* optional */
//	if (IS_ERR(priv->gate)) {
//		dev_err(dev, "no gate\n");
//		return PTR_ERR(priv->gate);
//	}
#endif
	priv->clk = devm_clk_get(dev, "clock");
	if (IS_ERR(priv->clk)) {
		dev_err(dev, "no pll clock\n");
		return PTR_ERR(priv->clk);
	}
	priv->clk_i2s2 = devm_clk_get(dev, "i2s2");
	if (IS_ERR(priv->clk_i2s2)) {
		dev_err(dev, "no i2s2 clock\n");
		return PTR_ERR(priv->clk_i2s2);
	}
#if 0
	priv->rstc = devm_reset_control_get_optional(dev, NULL);
//	if (IS_ERR(priv->rstc)) {
//		dev_err(dev, "reset controller err %d\n",
//				(int) PTR_ERR(priv->rstc));
//		return PTR_ERR(priv->rstc);
//	}

	if (!IS_ERR(priv->rstc)) {
		ret = reset_control_deassert(priv->rstc);
		if (ret < 0)
			return ret;
	}

	if (!IS_ERR(priv->gate)) {
		ret = clk_prepare_enable(priv->gate);
		if (ret < 0)
			goto err_gate;
	}
#endif

#if 1
//--fixme: should be enabled when clk_i2s2 is enabled
	/* activate the audio subsystem */
	ret = clk_prepare_enable(priv->clk);
	if (ret < 0)
		goto err_enable;
#endif

#if 0
//--fixme: default value
	ret = clk_set_rate(priv->clk, 24576000);
	if (ret) {
		dev_err(dev, "cannot set rate of i2s2 clock %d\n", ret);
		goto err_???;
	}
#endif

#if 0
//fixme: done in the DTS
	ret = clk_set_parent(priv->clk_i2s2, priv->clk);
	if (ret < 0) {
		dev_err(dev, "cannot set clock as i2s2 parent %d\n", ret);
		goto err_???;
	}
#endif

	ret = clk_prepare_enable(priv->clk_i2s2);
	if (ret < 0)
		goto err_i2s2;

	de2_i2s2_init(priv);

	ret = devm_snd_soc_register_component(dev, &i2s2_component, &i2s2_dai, 1);
	if (ret) {
		dev_err(dev, "snd_soc_register_component failed %d\n", ret);
		goto err_register;
	}

	ret = devm_snd_dmaengine_pcm_register(dev, &de2_i2s2_config, 0);
	if (ret) {
		dev_err(dev, "pcm_register failed %d\n", ret);
		goto err_register;
	}

	priv->dma_data.maxburst = 4;
	priv->dma_data.addr = mem->start + SUNXI_DAUDIOTXFIFO;
//fixme: useless
	priv->dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;

	card = de2_card_create(dev);
	if (!card) {
		ret = -ENOMEM;
		goto err_register;
	}

	card->dev = dev;
	dev_set_drvdata(dev, card);
	snd_soc_card_set_drvdata(card, priv);

	ret = devm_snd_soc_register_card(dev, card);
	if (ret) {
		dev_err(dev, "register card failed %d\n", ret);
		goto err_register;
	}

	return 0;

err_register:
	clk_disable_unprepare(priv->clk_i2s2);
err_i2s2:
	clk_disable_unprepare(priv->clk);
err_enable:
#if 0
	clk_disable_unprepare(priv->gate);
err_gate:
	reset_control_assert(priv->rstc);
#endif

	return ret;
}

static int de2_i2s2_dev_remove(struct platform_device *pdev)
{
	struct snd_soc_card *card = dev_get_drvdata(&pdev->dev);
	struct priv *priv = snd_soc_card_get_drvdata(card); 

	clk_disable_unprepare(priv->clk_i2s2);
	clk_disable_unprepare(priv->clk);
#if 0
	clk_disable_unprepare(priv->gate);
	if (!IS_ERR_OR_NULL(priv->rstc))
		reset_control_assert(priv->rstc);
#endif

	return 0;
}

static const struct of_device_id de2_i2s2_of_match[] = {
	{ .compatible = "allwinner,sun8i-h3-hdmi-audio" },
	{ }
};
MODULE_DEVICE_TABLE(of, de2_i2s2_of_match);

static struct platform_driver de2_i2s2_driver = {
	.probe  = de2_i2s2_dev_probe,
	.remove = de2_i2s2_dev_remove,
	.driver = {
		.name = DRV_NAME,
		.of_match_table = of_match_ptr(de2_i2s2_of_match),
	},
};

module_platform_driver(de2_i2s2_driver);

/* Module information */
MODULE_AUTHOR("Jean-Francois Moine <moinejf@free.fr>");
MODULE_DESCRIPTION("Allwinner DE2 I2S2 ASoC Interface");
MODULE_LICENSE("GPL v2");
